## 硬盘和显卡的访问控制

处理器工作模式将内存分成逻辑上的段，按照“段地址：偏移地址”进行。一个规范的程序要包含代码段、数据段、附加段、栈段。

nasm使用SECTION或SEGMENT来定义段

SECTION 段名称

SEGMENT 段名称

段名要表示其含义，一旦定义一个段，后面的内容都属于该段，除非新定义段。有时，程序并不以段定义语句开始，这种情况下，这些内容自成一个段。比如整个程序没有段，整个程序自成一个段。

nasm对段数量没有显示，大型程序可能包含多个代码段数据段。

Intel处理器要求段在内存起始物理地址必须是16字节对齐。

汇编语言各个段也有对齐要求。使用align=，指定某个SECTION的汇编对齐方式，align=16表示段是16字节对齐，align=32，表示是32字节对齐。

<img src="/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 084604.png" style="zoom:100%;" />

![屏幕截图 2023-03-09 084932](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 084932.png)

![屏幕截图 2023-03-09 085326](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 085326.png)



![屏幕截图 2023-03-09 094629](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 094629.png)

用户程序头部需要有一些信息，供加载器使用，头部要以一个段在源程序中出现

SECTION header vstart = 0

用户程序头部要包含以下信息：

1. 用户程序的尺寸，即以字节为单位的大小。加载器需要根据这一信息来决定读取多少个逻辑扇区。
2. 应用程序的入口点，包括段地址和偏移地址，因为加载器不知道第一条指令在程序中的位置。
3. 段重定位表。段重定位是加载器的工作，它需要知道每个段在用户程序内的位置，因此需要在程序头部给出段重定位表，每个表项4个字节。



### 加载器程序的工作流程

#### 初始化和决定加载位置

加载并执行一个程序加载器要决定两件事，看内存哪里空闲，从哪个内存地址开始加载程序；用户程序位于硬盘哪里，逻辑扇区号是多少。

app_lba_start equ 100   类似于C语言# define ax 30

伪指令equ用来声明常数，equ意思是“等于”。本句意思为用标号app_lba_start来代替100，用到100时可以这么写：mov al, app_lba_start，它等价于mov al, 100。equ声明不占内存，也不占汇编地址。

<img src="/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 102600.png" alt="屏幕截图 2023-03-09 102600" style="zoom:75%;" />



0x0FFFF以下是加载器及其栈的势力范围，A0000以上，是BIOS和外围设备，可用的空间位于0x10000~9FFFF，差不多500KB。

#### 准备加载用户程序

<img src="/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 110447.png" alt="屏幕截图 2023-03-09 110447" style="zoom:80%;" />



mov ax, [cs:phy_base]

mov dx, [cs:phy_base+0x02]

#### 外围设备及其接口

外围设备分为输入设备和输出设备，键盘、鼠标、麦克风、摄像头，显示器、打印机、扬声器。

I/O设备接口各不相同。麦克风和扬声器需要声卡，显示器需要显卡，USB键盘需要USB接口。

I/O接口是个变换器（翻译器），按处理器的信号规程工作，负责把处理器的信号转换成外围设备能接受的另一种信号；也把外围设备信号转换成处理器可以接收的形式。

有俩麻烦问题：

1.不可能将所有I/O接口直接和处理器相连。

2.每个设备的I/O接口都抢着和处理器说话。

解决第一个问题采用总线技术。可认为总线是一排电线，所有外围设备包括处理器连接到这个排线上。

解决第二个问题使用输入输出控制设备集中器（I/O Controller Hub， ICH）芯片，该芯片可以连接不同的总线，协调各个I/O接口对处理器的访问，这块芯片就是南桥。

<img src="/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 111915.png" alt="屏幕截图 2023-03-09 111915" style="zoom:100%;" />

#### I/O端口和端口访问

处理器通过I/O接口和外设打交道，即端口（Port），就是一些寄存器，不过在I/O接口电路中。每一个I/O接口可能拥有多个端口，用于不同目的。连接硬盘的PATA/SATA接口就有多个端口，命令端口（写入0x20表示从硬盘读取；写入0x30表示向硬盘写数据）、状态端口（根据这个端口判断硬盘是否正常，发生哪种错误），参数端口（处理器通过这些端口告诉硬盘读写的扇区数量，和逻辑扇区号）和数据端口（通过这个端口连续的取得要读的数据，或向硬盘写数据）。端口可以是8位，16位，32位。

一些计算机中端口映射到内存地址空间。比如0x00000-0xE0000是真实的物理内存地址，而0xE0001-0xFFFFF是从I/O接口哪里映射。

另一些计算机端口独立编址。这种计算机处理器即连接内存也连接每一个端口。处理器有一个特殊引脚M/IO#，‘#’表示低电平有效。当处理器访问内存时，M/IO#引脚呈高电平，内存电路打开，访问I/O，M/IO#低电平，内存电路被禁止。处理器发出的地址和M/IO#信号一起用于打开某个I/O接口，如果该I/O接口和处理器地址相吻合的话。

<img src="/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 113354.png" alt="屏幕截图 2023-03-09 113354" style="zoom:75%;" />

或者in ax， dx

in的目的寄存器必须是al或ax。in指令的源操作数应当是寄存器DX



in al,dx机器指令码是0xEC，in ax, dx机器指令码是0xED，都为1字节。in指令不允许使用别的通用寄存器，也不允许使用内存单元作为操作数。

in也有2字节形式，前一字节是操作码0xE4或者0xE5，分别是8位或16位端口访问，后一字节是立即数，指示端口号。只能访问0~255号端口。

E4 F0相当于汇编的 in al, 0xf0

E5 03相当于会变得 in ax, 0x03

in ax, 0x5fd是非法的，0x5fd>255

in 不影响标志位。

out指令目的操作数可以是8位立即数或寄存器DX，源操作数必须是AL或者AX

out 0x37, al

out 0xf5, ax

out dx, al

out dx, ax

#### 通过硬盘控制器端口读写扇区数据

硬盘读写的基本单位是扇区。读写数据最经典的就是硬盘控制器分别发送磁头号、柱面号、扇区号，这称为CHS模式。

很多时候希望扇区统一编址，从0开始编号，不管在哪个盘面或柱面。最早LBA28，使用28个比特表示逻辑扇区，从0x0000000-0xFFFFFFF，可表示268435456个扇区，一个扇区512字节，一共128G。

现在是LAB48，48个比特表示扇区号，可表示131072TB硬盘容量。本章采用LBA28

主硬盘控制器分配了8位端口，从0x1f0到0x1f7。从硬盘度逻辑扇区过程如下：

1. 设置要读的扇区数量，从0x1f2端口写入，这是个8位端口。

mov dx, 0x1f2

mov al, 0x01

out dx, al

写入0表示要读取256个扇区。每读一个扇区，这个数值就减一。如果读写错误，该端口包含着未读取的扇区数量。

2. 设置起始LBA扇区号，扇区读写是连续的。28位扇区号分别写入端口0x1f3、0x1f4、0x1f5、0x1f6。0x1f3存放0-7位以此类推。如果要读写起始逻辑扇区为0x02，可编写如下：

```assembly
mov dx, 0x1f3
mov al, 0x02
out dx, al		;LBA地址7-0
inc dx			;0x1f4
mov al, 0x00
out dx, al		;LBA地址15~8
inc dx			;0x1f5
out dx, al		;LBA地址23~16
inc dx			;0x1f6
mov al, 0xe0	;LBA模式，主硬盘，以及LBA地址27~24
out dx, al
```

<img src="/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 120626.png" alt="屏幕截图 2023-03-09 120626" style="zoom:75%;" />

3. 向0x1f7写入0x20，请求读硬盘，这也是一个8位端口

```assembly
mov dx, 0x1f7
mov al, 0x20		;读命令
out dx, al
```

4. 等待读完写操作完成。端口0x1f7既是命令端口，又是状态端口。这个端口发送读写命令后，硬盘开始工作。在内部操作期间，将0x1f7端口第七位置1，表示自己忙。一旦硬盘准备就绪，此位清零。第三位置1表示自己准备好了，请求主机发送或者接收数据。完成这一步典型代码如下：

```assembly
mov dx, 0x1f7
.waits:
in al, dx
and al, 0x88
cmp al, 0x08
jnz .waits			;不忙，且硬盘已经准备就绪
```

![屏幕截图 2023-03-09 121157](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 121157.png)

5. 连续取出数据。0x1f0是硬盘接口的数据端口，而且是16位端口。如下代码从硬盘读一个扇区（512字节，或256字），读取的数据存放到由DS指定的数据段，偏移地址由BX指定

```assembly
mov cx, 256		;要读取的字节数
mov dx, 0x1f0
.readw:
in ax, dx
mov [bx], ax
add bx, 2
loop .readw
```

最后0x1f1端口是错误寄存器，包含硬盘驱动器最后一次执行命令后的状态（错误原因）。

#### 过程调用

<img src="/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 122045.png" alt="屏幕截图 2023-03-09 122045" style="zoom:100%;" />

app_lba_start，用户程序起始逻辑扇区号。

参数传递最简单的办法是通过寄存器

call是调用，8086处理器支持4种调用方式。

第一种是16位相对近调用。近的意思是被调用的目标过程位于当前代码段内，只需要得到偏移地址即可。3字节指令，操作码0xE8，后跟16位操作数，因为是相对调用，该操作数是当前call指令相对于目标过程的偏移量。计算过程：用目标过程的汇编地址减去当前call指令的汇编地址，再减去当前call指令以字节为单位的长度（3），保留16位结果。被调用过程必须位于call指令-32768~32767字节的地方

call near proc_1  等价于call proc_1

near不是必须的，如果没near默认是近调用。

指令执行阶段，处理器看到0xE8知道这是一个过程调用。于是，它用指令指针寄存器IP的当前内容加上指令中的操作数再加上3，得到一个新的偏移地址。接着将IP原有内容压入栈中。最后，用刚才计算出的IP取代原有IP。

```assembly
call 0x0500
```

编译后0x0500并不会原封不动的出现在机械码，它依然会去减去当前指令的汇编地址，来得到偏移量。

第二种是16位间接绝对近调用。也是近调用，只能调用当前代码段内的过程，操作数不是偏移量，而是被调用过程的真实偏移地址，故称绝对地址。偏移地址不是直接出现在指令中而是由16位通用寄存器或内存单元间接给出

```assembly
call cx		;目标地址在CX中。省略了关键字“near”，下同 机械码FF D1
call [0x3000]	;FF 16 00 30
call [bx]
call [bx+si+0x02]
```

间接绝对调用首先计算出被调用过程偏移地址，然后将指令指针寄存器IP当前值压入栈，用计算出的偏移地址取代IP原有内容

第三种是16位直接绝对远调用。段间调用，所以称为远调用（far call）。即需要被调用过程所在的段地址，也需要该过程在段内的偏移地址。16位是针对偏移地址说的，而不是限定段地址，尽管段地址也是16位。直接的意思是段地址和偏移地址直接在call中给出。这里地址也是绝对地址

```assembly
call 0x2000:0x0030		;机器码9A 30 00 00 20,0x9A是操作码，后面两个字分别是偏移地址和段地址
;偏移地址在前，段地址在后
```

处理器首先将代码段寄存器CS的当前内容压栈，接着把IP内容压栈，用指令中段地址代替CS原有内容，指令偏移地址代替原有IP

第四种是16位间接绝对远调用。也属于段间调用，被调用过程位于另一代码段内，而且段地址和偏移地址是间接给出的。16位同样是来限定偏移地址的

```assembly
call far [0x2000]
call far [proc_1]
call far [bx]
call far [bx+si]
;前两条指令等效，一个数值，一个标号
```

间接远调用必须用far。是远调用，也是段间调用，必须给出段地址和偏移地址。指令中仅仅给出该位置的偏移地址，段地址和偏移地址在其他位置。

假设在数据段内声明标号proc_1并初始化俩字

proc_1 dw 0x0102, 0x2000

这俩字分别是某个过程调用的的段地址和偏移地址。偏移地址在前，段地址在后。调用该过程可以使用如下指令：

call far [proc_1]

执行这条指令，处理器访问DS指向的数据段，从指令中指定的偏移地址（由proc_1提供）处取得两个字（段地址0x2000，偏移地址0x0102），然后将CS和IP压栈，更改CS和IP

ret和retf经常用做call和call far的配对指令。ret是近返回指令，处理器从栈中弹出一个字到IP中。

reft是远返回指令，处理器分别从栈中弹出两个字到IP和CS中。

![屏幕截图 2023-03-09 134915](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-09 134915.png)

#### 加载用户程序

![屏幕截图 2023-03-11 190637](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 190637.png)

![屏幕截图 2023-03-11 190935](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 190935.png)

#### 用户程序重定位

![屏幕截图 2023-03-11 191757](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 191757.png)

![屏幕截图 2023-03-11 191824](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 191824.png)

adc dx,[cs:phy_base+0x02]    

adc是带进位加法，将目的操作数和源操作数相加，再加上标志寄存器CF的值

shr是逻辑右移，操作数每次移除来的数都会被移到标志寄存器的CF位，左边空出来的数用0填充。

![屏幕截图 2023-03-11 193614](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 193614.png)

![屏幕截图 2023-03-11 194033](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 194033.png)

#### 将控制权交给用户程序

![屏幕截图 2023-03-11 194252](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 194252.png)

#### 8086处理器的无条件转移指令

![屏幕截图 2023-03-11 194727](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 194727.png)

![屏幕截图 2023-03-11 194953](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 194953.png)

![屏幕截图 2023-03-11 195113](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 195113.png)

### 用户程序的工作流程

#### 初始化段寄存器和栈切换

![屏幕截图 2023-03-11 200420](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 200420.png)

![屏幕截图 2023-03-11 200441](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 200441.png)

![屏幕截图 2023-03-11 201946](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 201946.png)

![屏幕截图 2023-03-11 202501](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 202501.png)

![屏幕截图 2023-03-11 202720](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 202720.png)

![屏幕截图 2023-03-11 203251](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 203251.png)

![屏幕截图 2023-03-11 203307](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 203307.png)

![屏幕截图 2023-03-11 203331](/home/cccmmf/操作系统/x86/chap8/屏幕截图 2023-03-11 203331.png)
