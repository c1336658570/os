## chap10 32位x86处理器编程架构

处理器（编程）架构指一整套硬件结构，以及与之相适应的工作状态。

### IA-32架构的基本执行环境

#### 寄存器的拓展

![屏幕截图 2023-03-15 202545](/home/cccmmf/操作系统/x86/chap10/屏幕截图 2023-03-15 202545.png)

32位模式下和16位一样，EIP寄存器只能由处理器内部使用，程序中是无法直接访问的。对IP和EIP修改只能通过某些指令隐式进行。这些指令包括JMP、CALL、RET和IRET等等。

![屏幕截图 2023-03-17 103237](/home/cccmmf/操作系统/x86/chap10/屏幕截图 2023-03-17 103237.png)

16位处理器中标志寄存器FLAGS是16位，在32位寄存器中拓展到了32位。

32位模式下理论不需要分段，因为有32根地址线可以访问内存中的任何位置。但是，IA-32架构处理器基于分段模型。因此，32位处理器依然需要以段为单位访问内存。也提供另一种方案，只分一个段，段基址是0x00000000，长度为4GB。此模式称平坦模型（Flag Mode）。

32下，处理器要求在加载程序时，先定义该程序所拥有的段，然后允许使用这些段。定义段时，除了基地址（起始地址）外，还附加了段界符、特权级别、类型属性等。当程序访问一个段时，处理器将固件实施各种检查工作，以防止对内存的违规访问。

32位模式下，传统段寄存器，如CS、SS、DS、ES，保存的不是16位段基址，而是段的选择子（段选择器），即用于选择要访问的段。每个段寄存器还包括一个不可访问的部分叫描述符高速缓存器，里面有段的基地址和各种访问属性，供处理器使用，程序无法访问。

32位处理器还增加了俩额外寄存器FS和GS。

#### 基本的工作模式

![屏幕截图 2023-03-17 105658](/home/cccmmf/操作系统/x86/chap10/屏幕截图 2023-03-17 105658.png)

![屏幕截图 2023-03-17 105753](/home/cccmmf/操作系统/x86/chap10/屏幕截图 2023-03-17 105753.png)

#### 线性地址

IA-32处理器编程，访问内存，需要在程序给出段地址和偏移量。传统上，段地址和偏移地址称为逻辑地址，偏移地址叫做有效地址（Effective Address，EA），在指令中给出有效地址的方式叫做寻址方式（Addressing Mode）。比如：

```assembly
inc word [bx+si+0x06]	;基地址+变址
```

![屏幕截图 2023-03-17 110459](/home/cccmmf/操作系统/x86/chap10/屏幕截图 2023-03-17 110459.png)

### 现代处理器的结构和特点

#### 流水线

指令执行时，如果总线是空闲的（没有访问内存操作），就可以在指令执行的同时预取指令并提前译码。

执行一条指令需要从内存取指令、译码、访问操作数和结果，并进行移位、加法、减法、乘法以及其他任何需要的操作。可以把一条指令执行分解成若干细小的步骤，并分给相应单元完成，各个单元独立并行，各个步骤的执行就会在时间上重叠起来。

![屏幕截图 2023-03-17 110952](/home/cccmmf/操作系统/x86/chap10/屏幕截图 2023-03-17 110952.png)

#### 高速缓存

利用程序的局部性规律，可以把处理器正在访问和即将访问的指令和数据块从内存调入高速缓存中。当处理器要访问内存首先访问告诉胡安从，如果能极快的从高速缓存中取得，这成为命中（Hit）；否则，称为不中（miss）。不中的情况下，处理器在取得需要的内容之前必须重新装载高速缓存，而不只是直接到内存中取那个内容。高速缓存以块为单位装载，包括那个所需数据的临近内容。为此，需要额外时间来等待从内存载入高速缓存，在该过程损失的事件称为不中惩罚（miss penalty）。

每一款处理器的高速缓存都可能有不同实现，在一些复杂处理器存在多级Cache，分别应用于各个独立的执行部件。

#### 乱序执行

为实现流水线，需将指令拆分为更小的可独立执行的部分，即拆分成微操作（microoperations），简写uops

某些指令很简单，只需要一个微操作，如：

```assembly
add eax, ebx
```

```assembly
add eax,[mem]	;拆分成俩操作，从内存读数据并保存到临时寄存器，然后将EAX和临时寄存器数值相加
```

```assembly
add [mem], eax	;3个微操作，从内存读数据，执行相加，将相加结果写会内存
```

一单指令拆分成微操作，处理器可以再必要时候乱序执行（Out-Of-Order Execution）

```assembly
mov eax, [mem1]
shl exa, 5
add eax, [mem2]

mov [mem3], eax
```

add eax, mem[2]可拆分为2微操作，在执行逻辑左移的同时，处理器可以提前从内存读取mem2内容。典型的，如果数据不在高速缓存，name处理器在取得mem1内容后，会立即取mem2的内容，与此同时，shl指令的执行早就开始了。

将指令拆分成微操作，可以使栈的操作更有效率

```assembly
push eax
call func
```

push eax可分为俩操作等价如下：

```assembly
sub esp, 4
mop [esp], eax
```

这有一个好处，即使EAX寄存器还没准备好，微操作sub esp,4也可以执行。call指令需要在当前栈中保存返回地址，以前call需要等push eax执行结束，现在call等sub esp,4结束就可以执行

#### 寄存器重命名

```assembly
mov eax, [mem1]
shl eax, 3
mov [mem2], eax
mov eax, [mem3]
add eax, 2
mov [mem4], eax
```

以上代码做两件互不想干的事，将mem1左移3次，并将mem3加2。如果最后三条指令使用不同寄存器就可以看出两件事无关性。处理器也这么做，处理器为最后三条指令使用另一个不同的临时寄存器，左移和加法并行的处理。

在处理器内部，有大量临时寄存器可用，处理器可以重命名这些寄存器以代表一个逻辑寄存器，比如EAX。

寄存器重命名以一种完全自动和简单的方式工作。每当指令写逻辑寄存器时，处理器就为那个逻辑寄存器分配一个新的临时寄存器。

```assembly
mov eax, [mem1]
mov ebx, [mem2]
add ebx, eax
shl eax, 3
mov [mem3], eax
mov [mem4], ebx
```

假设mem1在高速缓存，可立刻取得，mem2不在高速缓存。这意味着左移操作可以再加法执行。为左移的结果使用一个新的临时寄存器。如果没有寄存器命名机制，左移操作不得不等从内存取mem2内容到EBX寄存器以及加法操作完成。

当所有操作完成后，代表EAX寄存器最终结果的临时寄存器的内容被写入真实的EAX寄存器，该处理结果称为引退（Retirement）。

所有的寄存器，栈指针、标志、浮点寄存器，甚至段寄存器都可能被重命名。

#### 分支目标预测

如果遇到一条转移指令，则后面哪些已经进入流水线的指令都无效了。我们必须清空（Flush）流水线，从要转移到的目标位置处重新取指令放入流水线。

流水线最大的问题是代码中经常有分支，处理器不知道应该用哪个分支填充流水线。流水线越长，处理器在错误分支填充流水线时，浪费的时间越多。

1996年Pentium Pro处理器上引入了分支预测技术（Branch Prediction）。分支预测核心问题是，转移是发生还是不会发生。

在处理器内部，有一个小容量高速缓存器，叫分支目标缓存器（Branch Target Buffer，BTB）。当处理器执行一条分支语句后，会在BTB中记录当前指令的地址、分支目标地址，以及本次分枝预测结果。下一次，在那条转移指令执行前，处理器会查找BTB，看有没有最近的转移记录。如果有，则推测执行和上一次相同的分支，把该分支的指令送入流水线。

当该指令实际执行时，如果预测失败，那么清空流水线，同时刷新BTB中的记录。

### 32位模式的指令系统

#### 32位处理器的寻址方式

![屏幕截图 2023-03-20 163330](/home/cccmmf/操作系统/x86/chap10/屏幕截图 2023-03-20 163330.png)

原有16位处理器寻址方式已经形成，让16位指令和32位指令共用相同的指令码，但通过不同的指令前缀，结合处理器当前的运行状态来决定指令的寻址方式。

比如，处理器运行在16位模式时，如果没有指令前缀0x66，则认为是传统的16位寻址方式；若有0x66，则指令是32位寻址方式。如果运行在32位模式下且没有指令前缀0x66，则视为默认的32位寻址，否则就是16位寻址。

32位模式下，默认使用32位宽度寄存器：

```assembly
mov eax, ebx
```

如果指令使用立即数，默认是32位

```assembly
mov ecx, 0x55	;ECX<-0x00000055
```

如果指令中的操作数指向内存单元的地址，该地址默认是32位的段内偏移地址（段内偏移量）

```assembly
mov edx, [mem]	;mem是一个32位段内偏移地址
```

如果指令中包含了内存地址操作数，name，它必然默认地是一个32位有效地址。通过有效地址可以取得32位的实际操作数。

![屏幕截图 2023-03-20 164202](/home/cccmmf/操作系统/x86/chap10/屏幕截图 2023-03-20 164202.png)

如下例子：

```assembly
add eax, [0x2008]			;有效地址为0x00002008
sub eax, [eax+0x08]			;有效地址是32位
mov ecx, [eax+ebx*8+0x02]	;有效地址是32位
```

在16位模式下，内存寻址操作数不允许是栈指针寄存器SP。

```assembly
mov ax, [sp]	;错误
```

32模式下，允许在内存操作数中使用栈指针寄存器ESP。

```assembly
mov eax, [esp]	;正确
```

#### 操作数大小的指令前缀

Intel每一条处理器指令都可以拥有前缀，比如重复前缀（REP/REPE/REPNE）、段超越前缀（ES:）、总线封锁前缀（LOCK）等。前缀是可选的，前缀长度为1字节，每条指令可有1-4条前缀。

前缀（如果有的话）后面是操作码。

操作码之后是操作数类型和寻址方式。

指令的最后是立即数和偏移量。如下：

```assembly
mov cx, [0x2000]
mov ecx, [eax+ebx*8+0x02]
```

![屏幕截图 2023-03-20 165357](/home/cccmmf/操作系统/x86/chap10/屏幕截图 2023-03-20 165357.png)

```assembly
mov dx, [bx+si+0x02]
```

如上指令在16位编码中，操作码0x8B。如图10-8(a)，操作码0x8b后是1字节的寻址方式和操作数类型。位7和6表示使用基地址变址的寻址方式，并带有8位偏移量。位5~3是010，指示目的操作数位寄存器DX，位2~0是000表示寻址方式是BX+SI+8位偏移量。该字节之后是1位偏移量0x02。该指令机器代码如下

```assembly
8B 50 02
```

32位使用相同编码格式，但寻址方式和寄存器定义完全不同。如图10-8(b)，32位处理器下，位7和6是01，表示使用基地址寻址方式，并带有8位偏移量。位5~3的值是010，指示目的操作数是寄存器EDX。位2~0是000，表示寻址方式是EAX+8位偏移量。该字节之后是1字节偏移量0x02，相同机器码却对应不同的32位指令

```assembly
mov edx, [eax+0x02]
```

![屏幕截图 2023-03-20 170208](/home/cccmmf/操作系统/x86/chap10/屏幕截图 2023-03-20 170208.png)

指令0x66具有反转当前默认操作数大小的作用，在写程序时，需要考虑指令的运行环境。编译器提供了伪指令bits，用于指明其后的指令应该被编译成16位还是32位。比如：

```assembly
bits 16
mov cx, dx		;89 D1
mov eax, ebx	;66 89 D8

bits 32
mov cx, dx		;66 89 D1
mov eax, ebx	;89 D8
```

16位模式是默认编译模式，如果没有指定指令的编译模式，默认是bits 16的。

#### 一般指令的拓展

32位处理器拥有32位寄存器和算数逻辑部件，而且通过内存芯片之间数据通路至少是32位。所有寄存器或内存单元位操作数的指令都被扩充。比如加法指令add，在32位处理器上，除允许8位或16位操作数外，32位操作数也可用。

```assembly
add al, bl
add ax, bx
add eax, ebx
add dword [ecx], 0x0000005f
```

除双操作数指令，单操作数指令也与允许2位操作数

```assembly
inc al
inc dword [0x2000]
inc dword [eax*2]
```

shl, shr等，目的操作数也拓展至32位。用于指定移动次数的源操作数足够应付32位环境，无变化。

```assembly
shl eax, 1
shl eax, 9
shl dword [eax*2+0x08], cl
```

同16位处理器，32位处理器上，逻辑移动指令源操作数如果是寄存器的话必须使用cl。32位处理器在实际执行时，现将源操作数（CL内）同0x1F做逻辑与。也就是仅保留源操作数低5位。实际移动最大位次数为31。

16位处理器，loop指令循环次数在CX中。32位处理器上，如果当前运行模式是16位，loop依然使用CX，否则，如果运行在32位模式下，则使用ECX。

16位处理器上，无符号乘法指令mul格式为

```assembly
mul r/m8			;AX<-AL*r/m8
mul r/m16			;DX:AX<-AX*r/m16
```

32位处理器，除支持上述操作，还支持拓展

```assembly
mul r/m32		;EDX:EAX<-EAX*r/m32
```

俩32位相乘得到64位结果

```assembly
mov eax, 0x10000
mov ebx, 0x20000
mul ebx
```

有符号乘法imul与此相同。

无符号除法和有符号处发也做了32位拓展

```assembly
div r/m32
idiv r/m32
```

在这里被除数是64位的，高32位在EDX，低32位在EAX。除数是32位的，位于32位寄存器，或者存放有32位实际操作数的内存地址。指令执行后，32位的商在EAX，32位余数在EDX。

32位处理器push和pop也拓展，允许压入双字操作数。特别是支持立即数压栈操作

```assembly
push imm8		;操作码6A
push imm16		;操作码68
push imm32		;操作码68
```

如下例子：

```assembly
push byte 0x55
```

byte给编译器用，告诉他压入的是字节。

该指令16位和32位形式一样，机器代码都是6A 55

执行时就不一样了。任何时候，处理器都不会压入一个字节，要么压入字要么压入双字。16位模式下，默认操作数字长是16位，处理器执行时，将该字节的符号位拓展到高8位，然后压入栈，压栈时使用SP寄存器，且现将SP内容减2.这就是说，实际压入的数值是0x0055.32位模式下，该字节操作数符号位拓展到高24位，即0x00000055。压栈时使用ESP，且现将ESP减4。

如果压入字必须使用word修饰。

```assembly
push word 0xfffb
```

压入双字操作数，必须使用dword

```assembly
push dowrd 0xfb
```

无论16位或32位模式下，压入的都是0x000000fb，且站指针寄存器（SP或ESP）都先减4

对于实际操作数位于通用寄存器或内存单元，只能压入字或双字。

```assembly
push r/m16
push r/m32
```

```assembly
push ax
push edx
```

如果被压入16位或32位操作数位于内存单元，必须使用word或dword修饰

```assembly
push word [0x2000]
push dword [ecx+esi*2+0x02]
```

无论压入的数位于寄存器或内存单元，16位下，压入字，先将SP减2，压入双字，先将SP减4。32位为ESP

压入段寄存器操作比较特殊

```assembly
push cx		;0E
push dx		;1E
push es		;06
push fs		;0F A0
push gs		;0F A8
push ss		;16
```

16位下，先将SP减2，然后直接压入段寄存器内容。32位下先将段寄存器内容零拓展到32位，然后ESP减4，再压入32位的值。



















































