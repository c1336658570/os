# 分页机制和动态页面分配

Intel 处理器访问内存的基本策略是分段。在16 位实模式下，段的起始位置必须对齐在16 字节边界上，而且段的长度最大为64KB。

进入32 位保护模式之后，段可以起始于任何位置，段的长度可以扩展到处理器的最大寻址范围边界。典型地，早期的32 位处理器拥有32根地址线，因此，段的长度可以扩展到4GB。

在32 位保护模式下，对段的访问本着“先登记，后访问”的原则进行。登记就是在GDT 或LDT 中登记段的描述符，规定了段的地址和边界，以及访问权限；访问时，则需要拿着一个段描述符的选择子才行。处理器用段界限和特权级别来审查对段的访问，任何非法的造访行为都会被处理器阻止，并立即拉响警报，也就是所谓的异常中断。

一般来说，人们使用计算机要先安装一个操作系统。在这种情况下，段是由操作系统负责管理的。操作系统加载应用程序，根据程序的要求，为它创建一个或多个段，然后把控制权交给它。

当同时运行的程序和任务很多时，内存可能就不够用了。这时，操作系统的价值就体现出来了。每个段描述符有A 位，每当访问一个段时，处理器会将其置位。A 位的清零由操作系统定时进行，它可以借此机会统计段的访问频度。当内存不够用时，它可以将那些较少访问的段换出到磁盘上，以腾出空间来给马上要运行的段使用。一旦某个段被挪到磁盘上，操作系统应当将其描述符的P 位清零。过一段时间，当这个段又被访问时，因其描述符的P 位是“0”，处理器引发段不存在异常（中断号为11）。这类中断通常是由操作系统负责处理的，它会用同样的方法腾出空间，将这个段的内容从磁盘调入内存。当这类中断返回时，处理器会再次执行引发异常的那条指令（而不是下一条指令），于是程序又能继续执行了。

但是，因为段的长度不定，在分配内存时，可能会发生内存中的空闲区域小于要加载的段，或者空闲区域远远大于要加载的段。在前一种情况下，需要另外寻找合适的空闲区域；在后一种情况下，分配会成功，但太过于浪费。为了解决这个问题，从80386 处理器开始，引入了分页机制。

分页功能从总体上说，是用长度固定的页来代替长度不一定的段，藉此解决因段长度不同而带来的内存空间管理问题。尽管操作系统也可以用软件来实施固定长度的内存分配，但太过于复杂，由处理器固件来做这件事，可以使速度和效率最大化。

## 分页机制概述

### 简单的分页模型

如图16-1 所示，在处理器中有负责分段管理的段部件。每个程序或任务都有自己的段，这些段都用段描述符定义。随着程序的执行，当要访问内存时，就用段地址加上偏移量，段部件就会输出一个线性地址。在单纯的分段模式下，线性地址就是物理地址。

![截图 2023-06-04 12-31-59](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 12-31-59.png)

如图16-1 所示，描述符中的段基地址为0x00200000，界限值为0x2007。因为段的粒度是字节，故该段的长度为8200 字节。当访问内存时，用段基地址0x00200000 加上段内偏移量0x1008，段部件就会形成线性地址0x00201008，这也是物理地址。

一旦决定采用页式内存管理，就应当把4GB 内存分成大小相同的页。但是，页在物理内存中位置是有讲究的，并不是在内存中随便找个位置，说：“来，页就从这里开始！”事实上，不是这样的。如图16-2 所示，页的最小单位是4KB，也就是4096 字节，用十六进制数表示就是0x1000。因此，第1 个页的物理地址是0x00000000，第2 个页的物理地址是0x00001000，第3 个页的物理地址是0x00002000，……，最后一个页的物理地址是0xFFFFF000。这样，可以将4GB内存划分为1048576（0x100000）个页。很显然，页的物理地址，其低12 位始终为全零。

段管理机制对于Intel 处理器来说是最基本的，任何时候都无法关闭。也就是说，即使启用页管理功能，分段机制依然是起作用的，段部件也依然工作。

分页机制也没有增加程序员的负担，程序依然是按段来组织的。问题在于，如何将较大的段，映射到大小相同的页面上呢？

![截图 2023-06-04 12-33-47](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 12-33-47.png)

如图16-3 所示，内存的分配涉及段空间的分配和页分配。请仔细看这幅图，左边是虚幻的，或者说虚拟的4GB 内存空间，称为虚拟内存；右边呢，是实实在在的内存，被分成1048576 个 4KB 页面。

![截图 2023-06-04 12-34-33](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 12-34-33.png)

在分页模式下，操作系统可以创建一个为所有任务共用的4GB 虚拟内存空间，也可以为每一个任务创建独立的4GB 虚拟内存空间，这都是可行的。当一个程序加载时，操作系统既在要左边的虚拟内存中分配段空间，又要在右边的物理内存中分配相应的页面。因此，第一个步骤是寻找空闲的段空间，该段空间既没有被其他程序使用，也没有被同一程序内的其他段使用。比如图16-3 所示，假设已经成功找到并分配了一个段空间，基地址为0x00200000，长度为8200 字节。

页的最小尺寸是4KB，也就是4096 字节。因此，8200 字节的段，需要占用3 个页面，其中最后一个页面只用了8 个字节，其余都浪费着，但这无关紧要，如果允许页共享，多个段或多个程序可以用同一个页来存放各自的数据。

在分段之后，操作系统的任务是把段拆开，并分别映射到物理页。注意，段必须是连续的，但不要求所分配的页都是连续的、挨在一起的。事实上，在开机之后，会运行不同的程序，这都要分配页。然后，有些程序关闭了，页面要回收。几个回合下来，空闲的页零零散散地分布在物理内存中，一般不会是连续的。分配页面时，操作系统会搜索那些空闲的页，并分配给程序使用，所分配页面的总长度要大于等于段长度。

作为一个具体的例子，操作系统为程序分配了一个段，段是在虚拟内存中分配的，起始地址为0x00200000。该段有8200 字节，需要分配3 个页面。为此，操作系统在物理内存中搜索可用的空闲页，还真找到了，这三个页面的物理地址分别是0x00002000、0x00004000 和0x00007000。接下来，要建立线性地址和页之间的对应关系，在图中，0x00200000～0x00200FFF 对应着物理地址为0x00002000 的页， 0x00201000 ～ 0x00201FFF 对应着物理地址为0x00004000 的页，0x00202000～0x00202007 对应着物理地址为0x00007000 的页。当然，这里只是示例，线性地址区间和页的对应关系可以随意。

4GB 虚拟内存空间不可能用来保存任何数据，因为它是虚拟的，它只是用来指示内存的使用情况。当操作系统加载一个程序并创建为任务时，操作系统在虚拟内存空间寻找空闲的段，并映射到空闲的页。然后，到真正开始加载程序时，再把原本属于段的数据按页的尺寸拆开，分开写入对应的页中。

从段部件输出的是线性地址，或者叫虚拟地址。为了根据线性地址找到页的物理地址，操作系统必须维护一张表，把线性地址转换成物理地址，这是一个反过程。

如图16-4 所示，因为有1048576 个页，所以转换表也有1048576 项。这是个一维表格，每个表项占4 字节，内容为页的物理地址。这个表格的用法是这样的：因为页的尺寸是4KB，故，线性地址的低12 位可用于访问页内偏移，高20 位可用于指定一个物理页。因此，把线性地址的高20 位当成索引，乘以4，作为表内偏移量，从表中取出一个双字，那就是该线性地址所对应的页的物理地址。

如图16-4 所示，如果执行指令

```assembly
mov edx, [0x2002]
```

那么，段部件用段地址0x00200000 加上指令中给出的偏移量0x2002，得到线性地址0x00202002。线性地址的高20 位是表格索引，即0x00202。将索引乘以4，得到0x00808，这就是表内偏移。看图，从该单元可以取出一个双字0x00007000，这就是页物理地址。

线性地址的低12 位是页内偏移量，用页物理地址加上页内偏移量，就是最终的物理内存地址。0x00007000 加上0x002，得到0x00007002，这就是实际要访问的物理内存地址。

问题在于，为什么在表内偏移量为0x00808 的地方，会恰好是页地址0x00007000，而不是其他页地址呢？问得好。当程序加载时，操作系统会首先在虚拟内存中分配段。然后，根据段需要分成多少页，来搜索空闲页面。当段较大时，要按页的尺寸分成好几个地址区段，操作系统用每个区段的首地址，取高20 位，乘以4，作为偏移量访问表格，并将分配给该区段的页的物理地址写入该表项。最后，把原本需要写入每个区段的程序数据，写到对应的页中。

![截图 2023-06-04 12-41-05](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 12-41-05.png)

注意了，在页式内存管理中，页面的管理和分配是独立的，和分段以及段地址没有关系。操作系统所要做的，就是寻找空闲页面，把它分配给需要的段，并将页的物理地址填写到映射表内。很显然，也很重要的结论是，线性地址，包括线性地址空间，和页面分配机制没有关系。

基于以上特点，同时为了充分挖掘分页内存管理的潜力，一般来说，每个任务都可以拥有4GB 的虚拟内存空间；同时，每个任务都有自己的页映射表，如图16-5 所示。

尽管有很多任务，而且每个任务都有自己的4GB 虚拟内存空间，但是，很重要的是，在整个系统中，物理页面是统一调配的。考虑这样一种情景：任务A 有一个段，段基地址为0x00050000，段长度为3000 字节，操作系统为它分配了一个物理地址为0x08001000 的页。过了一会儿，另一个任务B 加载了，它也有一个段，段基地址也是0x00050000，段长度为4096 字节。此时，操作系统则分配另一个不同的、物理地址为0x00700000 的页。在这种情况下，在任务A 内访问线性地址0x00050006，访问的其实是物理地址0x08001006；在任务B 内访问同样的线性地址时，访问的其实是物理地址0x00700006。

另一个会被质疑的问题是，每个任务都有4GB 虚拟内存空间，而物理内存只有一个，最大也才4GB，根本不够分的。事实上，的确不够分配。但是，操作系统可以将暂时不用的页退避到磁盘，调入马上就要使用的页，通过这种手段来实现分页内存管理。这就是为什么内存容量较小时，程序越来越慢，硬盘工作指示灯不停地闪烁的原因。

以上，就是基本的段页式内存管理机制。

![截图 2023-06-04 12-41-30](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 12-41-30.png)

### 页目录、页表和页

第一个支持分页内存管理模式的Intel 处理器是80386，那个时候，分页机制是很简单的。从最初的分页机制开始学习，可以很容易进一步理解其他分页机制，毕竟它们是一脉相承的。

我们知道，为了完成从虚拟地址（线性地址）到物理地址的转换，操作系统应当为每个任务准备一张页映射表。因为任务的虚拟地址空间为4GB，可以分出1048576 个页，所以，映射表需要1048576 个表项，用于存放页的物理地址。又因为每个表项占4 字节，所以，映射表的总大小为4MB。

没错，这张表很大，要占用相当一部分内存空间，考虑到在实践中，没有哪个任务会真的用到所有表项，充其量只是很小一部分，这就很浪费了。

当然，你可能会建议先划出一小块内存给它，然后，根据需要再动态扩展。的确，这是可行的。但是，因为一个特殊的原因，这张表在实际使用的时候，它的前半部分和后半部分会被同时用到。具体是什么原因，马上就要讲到，也正是因为这个尚未说明的原因，这张表从一开始就必须完全定义，而且不可避免地要占用4MB 内存空间。为了解决这个问题，同时又不会浪费宝贵的内存空间，处理器设计了层次化的分页结构。

分页结构层次化的主要手段是不采用单一的映射表，取而代之的是页目录表和页表。如图16-6所示，首先，因为4GB 的虚拟内存空间对应着1048576 个4KB 的页，可以随机地抽取这些页，将它们组织在1024 个页表内，每个页表可以容纳1024 个页。页表内的每个项目叫做页表项，占4 字节，存放的是页的物理地址，故每个页表的大小是4KB，正好是一个标准页的长度。

注意，页在页表内的分布是随机的，哪个页位于哪个页表中，这是没有规律的。在一个真实的系统中，老任务不断被关闭，新任务不断被创建并投入运行，页面的回收和再分配没有什么规律可言。

由于页表中存放的是页的物理地址，故每个页表项占4 字节，这样，每个页表占4096 字节，正好是一个物理页的大小，可以很方便地用一个物理页来定义每个页表。

如图16-6 所示，在将1048576 个页归拢到1024 个页表之后，接着，再用一个表来指向1024个页表，这就是页目录表（Page Directory Table，PDT），和页表一样，页目录项的长度为4 字节，填写的是页表的物理地址，共指向1024 个表页，所以页目录表的大小是4KB，正好是一个标准页的长度。

![截图 2023-06-04 13-06-44](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 13-06-44.png)

这样的层次化分页结构是每个任务都拥有的，或者说，每个任务都有自己的页目录和页表。如图16-7 所示，在处理器内部，有一个控制寄存器CR3，存放着当前任务页目录的物理地址，故又叫做页目录基址寄存器（Page Directory Base Register，PDBR）。

每个任务都有自己的任务状态段（TSS），它是任务的标志性结构，存放了和任务相关的各种数据，其中就包括了CR3 寄存器域，存放了任务自己的页目录物理地址。当任务切换时，处理器切换到新任务开始执行，而CR3 寄存器的内容也被更新，以指向新任务的页目录位置。相应地，页目录又指向一个个的页表，这就使得每个任务都只在自己的地址空间内运行。

从图16-7 中还可以看出，页目录和页表也是普通的页，混迹于全部的物理页中。它们和普通页的不同之处仅仅在于功能不一样。当任务撤销之后，它们和任务所占用的普通页一样会被回收，并分配给其他任务。

![截图 2023-06-04 13-08-19](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 13-08-19.png)

### 地址变换的具体过程

对于Intel 处理器来说，有关分页，最简单和最基本的机制就是这些：CR3 寄存器给出了页目录的物理基地址；页目录给出了所有页表的物理地址，而每个页表给出了它所包含的页的物理地址。好了，该清楚的都清楚了，唯一还不明白的，应该是如何用这种层次性的分页结构把线性地址转换成物理地址？

这里有个例子。

假如某个任务加载后，操作系统根据它的实际情况，在其4GB 虚拟地址空间里创建了一个段，段的起始地址为0x00800000，段界限值为0x5000，字节粒度。当该任务执行时，段寄存器DS 指向该段。又假设执行了下面一条指令：

```assembly
mov edx, [0x1050]
```

此时，段部件会输出线性地址0x00801050。在没有开启分页机制时，这就是要访问的物理内存地址，但现在开启了分页机制，所以，这是一个虚拟地址，要经过页部件的转换，才能得到物理地址。

如图16-8 所示，处理器的页部件专门负责线性地址到物理地址的转换工作。它首先将段部件送来的32 位线性地址截成3 段，分别是高10 位、中间的10 位和低12 位。高10 位是页目录的索引，中间10 位是页表的索引，低12 位则作为页内偏移来用。

![截图 2023-06-04 13-10-59](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 13-10-59.png)

当前任务页目录的物理地址在处理器的CR3 寄存器中，假设它的内容为0x00005000。段管理部件输出的线性地址是0x00801050，其二进制的形式为0000 0000 1000 0000 0001 0000 0101 0000。高10 位为0000000010，也就是十六进制的0x002，它是页目录表内的索引，处理器将它乘以4（因为每个目录项为4 字节），作为偏移量访问页目录。最终，处理器从物理地址00005008 处取得页表的物理地址0x08001000。

线性地址的中间10 位为二进制的0000000001，即0x001，处理器要用它作为页表内的索引来取得页的物理地址。处理器将该索引值乘以4，作为偏移量访问页表。最终，处理器又从物理地址08001004 处取得页的物理地址，这就是我们一直努力寻找的那个页。

页的物理地址是0x0000C000，而线性地址的低12 位是数据所在的页内偏移量。故处理器将它们相加，得到物理地址0x0000C050，这就是线性地址0x00801050 所对应的物理地址，要访问的数据就在这里。

注意，这种变换不是无缘无故的，而是事先安排好的。当任务加载时，操作系统先创建虚拟的段，并根据段地址的高20 位决定它要用到哪些页目录项和页表项。然后，寻找空闲的页，将原本应该写入段中的数据写到一个或者多个页中，并将页的物理地址填写到相应的页表项中。只有这样做了，当程序运行的时候，才能以相反的顺序进行地址变换，并找到正确的数据。

## 使内核在分页机制下工作

### 创建内核的页目录表和页表

必须说明的是，必须在保护模式下才能启动页功能。和往常一样，首先进入保护模式执行的是内核程序，而且，我们要先让内核在分页机制下工作。

本章依然没有提供新的主引导程序，这意味着，还要用以前的主引导程序，同时还意味着，内核程序的总体结构没有变化，否则主引导程序又怎么可能按往常的方式加载它呢。

内核的入口点是在代码清单16-1 的第884 行，即标号“start”处。执行到这里的时候，主引导程序已经创建了内核的大部分要素：全局描述符表（GDT）、公共例程段、内核数据段、内核代码段、内核栈，还包括一个用于访问全部4GB 内存空间的段。

内核的总体结构和它在内存中的布局，从第14 章以来就没什么变化，而且第14 章还曾经给出了一幅内核的内存布局图。为了方便，这里用另一种形式再次展示一下，如图16-9 所示。

![截图 2023-06-04 13-13-38](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 13-13-38.png)

其中，各个段在内存中的位置、段描述符和描述符的选择子，都没有变化，可以和前面的章节对照一下。强调这些，只是要表明，即使是在分页机制下工作，对以往的代码和内存分配都没有什么影响。

接着回到代码清单16-1 中来。

第885～889 行，令段寄存器DS 和ES 分别指向内核数据段与0～4GB 数据段，以方便后面的操作。

第891、892 行，在屏幕上显示第一个字符串，表明当前正在内核中执行，而且是在保护模式下工作。

第895～921 行，在屏幕上显示处理器的品牌信息，这段代码和往常一样，没有任何变化。

接下来的工作是准备开启页功能，首先必须创建页目录和页表。每个任务都有自己的页目录和页表，内核也不例外，尽管它是为所有任务所共有的，但也包括作为任务而独立存在的部分，以执行必要的系统管理工作。因此，要想内核正常运行，必须创建它自己的页目录和页表。

麻烦在于，内核已经加载完毕，它的所有部分都已经位于内存中。当然，你可能会问，这怎么会是个麻烦事呢？原因是，在一个理想的分页系统中，要加载程序，必须先搜索可用的页，并将它们与段对应起来。在这种情况下，段部件输出的线性地址和页部件输出的物理地址不同，是很自然的事，因为一切都发生在程序加载完毕、段和页已经有了确定的映射关系之后。在这种情况下，页功能开启之后，各方都能很好地适应。

然而，由于内核是在开启页功能之前加载的，段在内存中的位置已经固定。在这种情况下，即使开启了页功能，线性地址也必须和物理地址相同才行。比如， 在开启页功能之前，GDT 在内存中的基地址是0x00007E00，它就是全局描述符表的物理地址，段部件输出的线性地址就是物理地址。在开启页功能之后，它还在那个内存位置，这就要求页部件输出的物理地址和段部件输出的线性地址相同。一句话，要求线性地址等于物理地址才行。

注意，进入分页模式之后，所有东西的地址都成了线性地址，包括GDT、LDT 和TSS 的地址，等等。

其实这也好办。

不像流行的操作系统，我们的内核非常小，这是没有办法的事，我们的任务不是写一个操作系统，能说明问题即可。也正是因为我们的内核很小，所以低端1MB 的空间对它来说已经绰绰有余了。如此一来，我们只需要将低端1MB 内存特殊处理，使这一部分内存的线性地址和经过页部件转换之后的物理地址相同即可。这样做的好处是，内核不用做任何变动即可在分页机制下正常工作。

对页目录和页表在内存中的位置没有什么限制，在哪里都行，前提是属于有效的可用内存范围，如果只安装了1GB 的物理内存，而想把页目录放到2GB 的位置，是不行的。而且，页目录和页表必须各自占用一个自然页，也就是说，它们的物理地址的低12 位必须全是零。

在页目录中，一个目录项对应着一个页表，而一个页表可以容纳1024 个页，也就是4MB 内存。所以，对于内核来说，只需要一个页表就行了，还用不完。这就是说，一个页目录和一个页表就足够了。

![截图 2023-06-04 13-39-46](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 13-39-46.png)

再来看图16-9，在GDT 和内核加载的区域之间，是一片空白。因此，我们可以将内核的页目录表放在物理地址0x00020000 处；而把内核的第一个页表放在物理地址0x00021000 处。此时，新的低端1MB 内存布局就如图16-10所示了。

既然我们的目的清楚了，也知道该怎么干，那么，回到代码清单16-1，先来创建页目录表和页表。

第927～933 行，访问段寄存器ES 所指向的4GB 数据段，用0x00020000 作为偏移量，访问页目录，将所有目录项清零。

如图16-11 所示，这是页目录项和页表项的格式。可以看出，在页目录和页表中，只保存了页表或者页物理地址的高20 位。原因很简单，页表或者页的物理地址，都要求必须是4KB 对齐的，以便于放在一个页内，故其低12 位全是零。在这种情况下，可以只关心其高20 位，低12 位安排其他用途。

![截图 2023-06-04 13-40-07](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 13-40-07.png)

- P（Present）是存在位，为“1”时，表示页表或者页位于内存中。否则，表示页表或者页不在内存中，必须先予以创建，或者从磁盘调入内存后方可使用。
- RW（Read/Write）是读/写位。为“0”时表示这样的页只能读取，为“1”时，可读可写。
- US（User/Supervisor）是用户/管理位。为“1”时，允许所有特权级别的程序访问；为“0”时，只允许特权级别为0、1 和2 的程序访问，特权级别为3 的程序不能访问。
- PWT（Page-level Write-Through）是页级通写位，和高速缓存有关。“通写”是处理器高速缓存的一种工作方式，这一位用来间接决定是否采用此种方式来改善页面的访问效率。由于高速缓存的知识将在下册中介绍，所以在本章中该位直接清零。
- PCD（Page-level Cache Disable）是页级高速缓存禁止位，用来间接决定该表项所指向的那个页是否使用高速缓存策略。同样，在本章中，该位将被清零；
- A（Accessed）是访问位。该位由处理器固件设置，用来指示此表项所指向的页是否被访问过。这一位很有用，可以被操作系统用来监视页的使用频率，当内存空间紧张时，用以将较少使用的页换出到磁盘，同时将其P 位清零。然后，将释放的页分配给马上就要运行的程序，以实现虚拟内存管理功能。
- D（Dirty）是脏位。该位由处理器固件设置，用来指示此表项所指向的页是否写过数据。
- PAT（Page Attribute Table）页属性表支持位。此位涉及更复杂的分页系统，和页高速缓存有关，可以不予理会，在普通的4KB 分页机制中，处理器建议将其置“0”。
- G（Global）是全局位。用来指示该表项所指向的页是否为全局性质的。如果页是全局的，那么，它将在高速缓存中一直保存（也就意味着地址转换速度会很快）。因为页高速缓存容量有限，只能存放频繁使用的那些表项。而且，当因任务切换等原因改变CR3 寄存器的内容时，整个页高速缓存的内容都会刷新。
- AVL 位被处理器忽略，软件可以使用。

回到代码清单16-1 中来。

将页目录清零的原因，主要是使所有目录项的P 位为“0”。目录项用于定位对应的页表，如果其P 位是“0”，表明该页表并不在内存中，在地址变换时将引发处理器异常中断。

在建立了一个为空的页目录表之后，第936 行，将页目录表的物理地址登记在它自己的最后一个目录项内。页目录最大4KB，最后一个目录项的偏移量是0xFFC，即十进制数4092。页目录需要频繁地进行修改，为了方便用线性地址访问页目录表自身，需要使用这项技术，马上我们就要讲到。注意，填写的内容是0x00020003，该数值的前20 位是物理地址的高20 位；P＝1，页是位于内存中的；RW＝1，该目录项指向的页表可读可写。还要注意到，US 位是“0”，故此目录项指向的页表不允许特权级为3 的程序和任务访问。

注意，这将浪费一个页目录表项，同时使得最高端的4MB 内存无法访问（0xFFC00000～0xFFFFFFFF）。不过，即使不浪费，一般的软件也不会涉足这个区域。

如图16-12 所示，内核占用着内存的低端1MB，线性地址范围是0x00000000～0x000FFFFF，共256 个4KB 页，占用了页目录表的第1 个目录项，以及该目录项下属页表的前256 个页表项。第939 行，修改页目录内第1 个目录项的内容，使其指向页表，页表的物理地址是0x00021000，该页位于内存中，可读可写，但不允许特权级别为3 的程序和任务访问。

![截图 2023-06-04 14-00-49](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 14-00-49.png)

第942～952 行，将内存低端1MB 所包含的那些页的物理地址按顺序一个一个地填写到页表中，当然，仅填写256 个页表项。第1 个页表项对应的是线性地址0x00000000～0x00000FFF，填写的内容是第1 个页的物理地址0x00000000；第2 个页表项对应的是线性地址0x00001000～0x00001FFF，填写的是第2 个页的物理地址0x00001000；第3个页表项对应的是线性地址0x00002000～0x00002FFF，填写的是第3 个页的物理地址0x00002000，……。如此一来，这部分内存的线性地址就和物理地址一样了。

这部分代码还是很容易看懂的，第942～944 行，用EBX 寄存器指向页表基地址；用EAX 寄存器保存页的物理地址，初始为0x00000000，每次按0x1000 递增，以指向下一个页；ESI 寄存器用于定位每一个页表项。

参见图16-11，因为页的物理地址是4KB 对齐的，故其低12 位全为零，在写入页表项时，仅保存它的前20 位，低12 位是页属性。在实际写入每个页表项之前，先将页的物理地址转存到EDX 寄存器，并将属性值加到其低12 位上。属性值是3，故P＝1，RW＝1；US＝0，特权级别为3 的程序和任务不能访问这些页。

尤其注意第948 行的指令：

```assembly
mov [es:ebx+esi*4],edx
```

再重复一次，请务必注意，32 位处理器允许在寻址时使用一个倍率因子，在这里是乘以4，表达式的计算不在编译期间进行，而在指令执行的时候进行。

页表的前256 个表项填写之后，EBX 寄存器的当前值是256，它又被用于第955～958 行，接着处理其余的表项，使它们的内容为全零。即，将它们置为无效表项。

页目录和页表都已创建，它们的表项也都安排妥当，第961、962 行，将页目录表的物理基地址传送到控制寄存器CR3，也就是页目录表基地址寄存器PDBR，该寄存器的格式如图16-13所示。

![截图 2023-06-04 14-55-13](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 14-55-13.png)

由于页目录表必须位于一个自然页内，故其物理基地址的低12 位是全零，处理器的设计者认为既然如此，只登记它的高20 位即可。低12 位，除了PCD 和PWT 位外，都没有使用。这两位用于控制页目录的高速缓存特性，请参照前面的解释。在本章中，为了方便，这两位一律为“0”。

从表面上看，和控制寄存器有关的传送指令和普通的传送指令一样。实际上，这是两种不同类型的指令，操作码是不一样的。控制寄存器是在有了32 位处理器之后才开始出现的，故其长度至少是32 位。在32 位处理器上，和控制寄存器有关的传送指令，其格式为：

```assembly
mov CR0~CR7, r32	;从32位通用寄存器传送到控制寄存器
mov r32, CR0~CR7	;从各个 控制寄存器传送到32位通用寄存器
```

没错，最新的处理器内共有8 个控制寄存器，从CR0 到CR7，至于它们都有什么用，别好奇，等看完这本书后，你再慢慢学习吧。汇编语言的一个缺点是无法区分不同指令间的细微差别。在这里，尽管也使用了助记符号“mov”，但实际上，它和一般的传送指令有所区别。

看来全都准备停当了，现在就开启页功能。如图16-14 所示，控制寄存器CR0 的最高位，也就是位31，是PG（Page）位，用于开启或者关闭页功能。当该位清零时，页功能被关闭，从段部件来的线性地址就是物理地址；当它置位时，页功能开启。只能在保护模式下才能开启页功能，当PE 位清零时（实模式），设置PG 位将导致处理器产生一个异常中断。

![截图 2023-06-04 14-58-54](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 14-58-54.png)

第964～966 行，先读取控制寄存器CR0 的原始内容，然后，将其最高位置“1”，其他各位保持原来的数值不变。接着，将修改后的内容重新传回CR0 寄存器，这直接导致处理器工作在分页机制下。从这一瞬间开始，段部件产生的地址就不再被看成物理地址，而是要送往页部件进行变换，以得到真正的物理地址。

注意，现在内核工作在分页机制的一个特殊情况下，即，线性地址和经过页部件转换后的物理地址相同，这是精心安排后的结果。举个例子，如果要访问全局描述符表GDT 内的第2 个描述符。在开启页功能之前，GDT 的线性地址是0x00007E00，第2 个描述符的线性地址则是0x00007E08。在开启页功能之后，依然要保证转换后的物理地址和线性地址一样， 仍是0x00007E00 和0x00007E08。好，线性地址送到页部件，页部件用线性地址的高10 位在页目录中查找页表；再用线性地址的中间10 位在页表中查找页。经过转换，找到了包含该数据的页，页的物理地址是0x00007000。于是，将页地址和线性地址的低12 位（0xE08）拼凑在一起，形成最终的0x00007E00 和0x00007E08。

可以在Bochs 中用“creg”命令察看控制寄存器CR0 和CR3 的内容，具体方法请参见本章16.6.2 节；也可以输入一个线性地址，来察看它所对应的物理页，具体方法请参见本章16.6.3 节；要察看当前页表中的全部内容，可以用“info tab”命令，请参见本章16.6.4 节。

### 任务全局空间和局部空间的页面映射

和往常一样，接下来的工作是加载用户程序，并创建一个任务。

每个任务都有自己独立的4GB 虚拟地址空间。这话说来简单，大家也都能在理论的层面上理解，但从来没有实现过，今天我们就来实践一回。

但是细一琢磨，这里面有个问题。

每个任务都有自己的页目录表和页表，当任务创建时，它们一同被创建。当任务执行时，页部件使用它们访问任务自己的私有内存空间（页面）。但是，任务的页目录表和页表不能只包含任务的私有页面。如果不是这样，当任务调用内核服务时，或者换句话说，进入0 特权级的全局地址空间执行时，地址转换将无法进行，因为任务的页目录表和页表里没有登记内核所占用的那些物理页面。

还记得吗，我们一直在说，任务的4GB 地址空间包括两个部分：局部空间和全局空间，全局空间是所有任务共用的。很明显，内核就是所有任务共用的，它应当属于每个任务的全局空间。

一般来说，公平起见，全局地址空间占据着任务4GB 地址空间的高2GB，对应的线性地址范围是0x80000000～0xFFFFFFFF；而局部地址空间则使用低2GB，对应的线性地址范围是0x00000000～0x7FFFFFFF。如图16-15 所示，地址空间的分配必须在每个任务的页目录中体现，页目录的前半部分指向任务自己的页表；后半部分则指向内核的页表。否则的话，当转到内核中执行时，是无法完成地址转换的，因为找不到对应的目录项和页表项。

在任何任务内，在任何时候，如果段部件发出的线性地址高于等于0x80000000，指向和访问的就是全局地址空间，或者说内核。

为此，我们要修改内核自己的页目录表，甚至是内核各个段的描述符，将内核挪到虚拟地址空间的高端，也就是虚拟地址空间中，从0x80000000 开始的一段连续区域。也许你并未安装这么多物理内存，但是，没有关系，我都说了，这是线性地址空间，或者叫虚拟地址空间。

如图16-16 所示，这是映射到虚拟内存高端地址后的内核布局图。

![截图 2023-06-04 15-21-11](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 15-21-11.png)

![截图 2023-06-04 15-22-59](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 15-22-59.png)

第969～973 行，在内核的页目录表中，创建一个和线性地址0x80000000 对应的目录项，并使它指向同一个页表。毕竟，我们只改变了线性地址空间范围，内核的数据和代码仍然在原来的页内，没有改变。

为了修改页目录表PDT，需要访问它，知道它的物理地址。但是，当前已经开启了分页功能，在分页机制下，程序只能使用线性地址，访问内存必须先访问页目录和页表，通过它们转换之后的地址才是能够发送到内存芯片的物理地址，你自己知道页目录表的物理地址，这没有用。或者，说得更清楚一点，你访问的是页目录表，但却还要通过页目录表进行地址转换之后才能访问内存中的页目录表。这有点自相矛盾，除非页目录表中有一个目录项能指向页目录表自己。否则，访问一个并未在页目录表和页表内登记的页，会引发处理器异常中断。

这段代码，其实倒过来，先从结果着手可能更容易理解。经过分析可知，当第973 行的指令

```assembly
mov dword [es:ebx+esi],0x00021003
```

执行时，ES 是指向0～4GB 内存段的，EBX 寄存器的内容为0xFFFFF000，ESI 寄存器的内容为0x00000200，因此，段部件发出的线性地址是0xFFFFF200。

如图16-17 所示，当前程序或者任务的页目录表，其物理基地址是由控制寄存器CR3 指示的，仅高20 位有效，是多少并不重要，可以假定为0x?????000。段部件产生的线性地址是0xFFFFF200，其高10 位的值是0x3FF，这个值乘以4，结果为0xFFC。这个值同CR3 寄存器提供的页目录表物理地址相加，结果是0x?????FFC，它就是页目录表内最后一个目录项的物理地址。从此处取出一个双字，就是线性地址0xFFFFF200 所对应页表的物理地址。

![截图 2023-06-04 15-28-19](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 15-28-19.png)

有趣的是，在前面第936 行，我们已经在该目录项内填写了页目录表的物理基地址。因此，该目录项所指向的页表正是当前的页目录表自己，这实际上是把页目录表当成页表来用。

接下来，如图16-18 所示，处理器用线性地址0xFFFFF200 的中间10 位作为偏移量访问页表，这10 位的值是0x3FF。页表的物理地址就是页目录表的物理地址，即0x?????000；表内偏移量是0x3FF 乘以4，即0xFFC。故，这一次处理器发出的最终物理地址也同样是0x?????FFC，它就是页表内最后一个页表项的物理地址。从此处取出一个双字，就是线性地址0xFFFFF200 所在的那个页的物理地址。

![截图 2023-06-04 15-29-06](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 15-29-06.png)

因为访问的又是同一内存位置，故最终要访问的页仍是页目录表自己。不过，如图16-19 所示，这一次稍有不同，页的物理地址是0x?????000，页内偏移由线性地址的低12 位乘以4 给出，其值为0x800。所以，当指令

![截图 2023-06-04 15-30-26](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 15-30-26.png)

```assembly
mov dword [es:ebx+esi],0x00021003
```

执行时，处理器发出的物理地址是0x?????800，并将该双字单元的内容改写为0x00021003。

综合上面的分析，这就是说，如果页目录表的最后一个目录项指向当前页目录表自己，那么，无论任何时候，当线性地址的高20 位是0xFFFFF 时，访问的就是页目录表自己。

修改页目录表的原理就是这样。因此，当我们回过头去看时，第969 行，实际上给出了当前正在使用的页目录表的线性基地址0xFFFFF000；第970 行，给出了要修改的那个目录项所对应的线性基地址，其高10 位的值乘以4，决定了该线性地址所对应的页目录表内偏移量。因此，第971 行，将线性地址右移22 位，只保留高10 位；第972 行，再将它左移2 位，相当于乘以4。

最终，页目录表内有两个目录项都指向同一个页表，如图16-20 所示。不过，尽管指向的是同一个页表，这两个目录项所映射的线性地址是不一样的，旧表项依然对应着线性地址0x00000000～0x000FFFFF；新表项则对应着一个高端的地址范围0x80000000～0x800FFFFF。

这回，你应该很清楚了，为什么处理器会使用层次化的分页结构，而不是用4MB 内存组建单一的页映射表。如果采用后者，将不得不至少保留2MB 的内存空间。当然，这对于现在的计算机来说算不了什么，但是，在1978 年，80386 处理器刚刚问世的时候，拥有2MB 物理内存还是一种非常奢侈的想法。即使是在15 年之后的1993 年，在我使用的计算机上也才有2MB 物理内存，已经是相当不错的，那台计算机花了7000 多元人民币。

仅仅修改页目录表是没有用的，如果段部件给出的线性地址并不在0x80000000 以上，是没有用的。因此，必须修改与内核有关的段描述符，包括全局描述符表（GDT）自己的线性地址。一旦开启页功能，除页目录表和页表的地址外，其他所有地址都是线性地址，即使是在访问GDT 和LDT 的时候，内核就更不用说了，不可能因为它靠近硬件就能搞特殊。

修改段描述符很简单，只需要将其中的基地址部分加上0x80000000 即可。比如GDT，原先的地址是0x00007E00，现在则要改为0x80007E00。说起来容易做起来难，段描述符中的基地址不是连续的，处于高低两个双字中的不同位置，重新计算比较麻烦。

![截图 2023-06-04 15-37-33](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 15-37-33.png)

幸运的是，0x80000000 是一个有趣的数，仅最高位是“1”，其余31 比特都是“0”。因此，只需要访问全局描述符表（GDT），将所有描述符高字部分的最高位置“1”即可。

第977～979 行，先取得GDT 的线性基地址，并传送到EBX 寄存器，准备开始访问GDT 内的段描述符。

第981～986 行，依次找到内核栈段、文本模式下的视频缓冲区段、公共例程段、内核数据段和内核代码段的描述符，并将每个描述符的最高位改成“1”。在这里，EBX 寄存器提供了GDT 的基地址；0x10、0x18、0x20 等这些数提供了每个描述符在表内的偏移量；在偏移量的基础上加4，就是每个描述符的高32 位。唯一没有修改的是0～4GB 内存段的描述符，它本身就是为访问整个内存空间而存在的，不需要修改。

尽管全局描述符表（GDT）很重要，但处理器不会对它有任何照顾，开启分页功能后，访问GDT 也同样需要使用线性地址。因此，第988 行，将GDT 的基地址映射到内存的高端，即加上0x80000000。第990 行，将修改后的GDT 基地址和界限值加载到全局描述符表寄存器（GDTR），使修改生效。

我知道，很多人会有一个疑问：在修改段描述符的时候，以及重新设定了GDT 基地址的时候，会不会导致程序的执行出现问题，毕竟访问内存需要先访问GDT，然后访问GDT 内的描述符，而你已经改变了它们。

答案是不会。在你能够访问GDT，或者能够修改描述符的时候，段寄存器CS、SS、DS、ES、FS 和GS 已经指向了相应的段，对不对？

那么，我们知道，段寄存器实际上由段选择器和描述符高速缓存器组成。当取指令和执行指令时，或者访问内存中的数据时，处理器不会每次都重新加载段寄存器，而是使用CS、SS、DS、ES、FS 和GS 描述符高速缓存器中的内容。

所以，当你改变了GDT 的基地址，或者修改了段描述符之后，这些修改不会立即反映到段寄存器的描述符高速缓存器，对程序的运行没有任何影响。

但是，当执行一个段间转移指令，或者往段寄存器里加载一个新的段描述符选择子时，处理器将会访问GDT 或者LDT，并刷新段寄存器描述符高速缓存器的内容。因此，为了使处理器转移到内存的高端位置执行，需要显式地刷新段寄存器的内容。

代码段寄存器CS 的刷新一般使用转移指令完成。因此，第992 行，使用远转移指令jmp 跳转到下一条指令的位置接着执行。这将导致处理器用新的段描述符选择子core_code_seg_sel（0x38）访问GDT，从中取出修改后的内核代码段描述符，并加载到其描述符高速缓存器中。同时，这也直接导致处理器开始从内存的高端位置取指令执行。

第995～999 行，重新加载段寄存器SS 和DS 的描述符高速缓存器，使它们的内容变成修改后的数据段描述符。注意，这些段在内存中的物理位置并没有改变。特别是栈段，因为仅仅是线性地址变了，栈在内存中的物理位置并没有发生变化，所以栈指针寄存器ESP 仍指向正确的位置。段寄存器ES 没有修改，因为它指向整个0～4GB 内存段，内核需要有访问整个内存空间的能力。段寄存器FS 和GS 没有使用。

第1001、1002 行，显示一条消息，告诉屏幕前的人，已经开启了分页功能，而且内核已经被映射到线性地址0x80000000 以上。需要特别说明的是，即使是在分页机制下，相对于上一章，过程put_string 及其嵌套过程put_char 也没有做任何修改，但依然工作得很好。原因很简单，尽管文本模式的显示缓冲区基地址已经映射到一个较高的地址0x800B8000，但是，向该区域内的任何一个单元，比如线性地址0x800B8020 写字符时，页部件最终会在页表内找到显示缓冲区所在的那个页，页的物理地址是0x000B8000。用页的物理地址加上12 位的页内的偏移量0x020，就是最终的物理地址0x000B8020。

第1005～1023 行，安装供用户程序使用的调用门，并显示安装成功的消息。这一段代码和上一章相同，没有做任何修改。门描述符只涉及目标代码段的选择子和偏移量，但是你应该清楚，目标代码实际上已经被映射到内存的高端了。

## 创建内核任务

### 内核的虚拟内存分配

接下来的工作是使内核的一部分成为任务，并为创建用户任务和实施任务切换做准备。

首先是创建内核任务的任务状态段（TSS）。内核的主体部分占据着从线性地址0x80000000 开始的1MB 内存空间，即0x80000000 ～ 0x800FFFFF ， 在此之后的空间， 即0x80100000 ～ 0xFFFFFFFF，是可以自由分配的。

为了连续地、动态地分配内核的空间，内核需要记住下一个可用于分配的线性地址。为此，代码清单16-1 的第529 行，专门声明了标号core_next_laddr，并初始化了一个双字0x80100000，这就是初始的可分配线性地址。每当分配了新的内存空间后，该双字将修正为下一个可分配的地址。

在分页机制下，内存的分配既要在虚拟内存空间中进行，还要在页目录表和页表中进行。原因你是清楚的，线性地址最终要通过页目录表和页表转换成物理地址，如果没有分配一个物理页，对任何内存的访问都是无效的，会引发处理器异常中断。

第1026 行，先访问内核数据段，从标号处取得当前可用的线性地址，将来要作为内核TSS 的起始线性地址。然后，将EBX 寄存器中的线性地址作为参数，调用过程alloc_inst_a_page 去申请一个物理页。

该过程位于第358 行，是公共例程段内的过程，它的功能是在可用的物理内存中搜索空闲的页，并将它安装在当前的层次化分页结构中（页目录表和页表）。简单地说，就是寻找一个可用的页，然后，根据线性地址来创建页目录项和页表项，并将页的地址填写在页表项中。

该过程首先察看与该线性地址相对应的页目录项是否存在。线性地址的高10 位是页目录表的索引，将该值乘以4，就是当前页目录表中，与该线性地址对应的页目录项。第370 行，将EBX寄存器中的线性地址传送到ESI 寄存器作为副本；第371 行，用AND 指令保留线性地址的高10位，其他各位清零；第372 行，得到该线性地址在页目录表中对应的偏移量（目录项）。该指令等效于

```assembly
shr esi, 22		;得到线性地址高10位的值
shl esi, 2		;乘4
```

无关的位已经清零，在这种情况下，右移22 次，再左移2 次，干脆右移20 次好了。

我们说过，可以用线性地址来访问当前页目录表，我们也知道，当前页目录表的线性地址是0xFFFFF000。因此，第373 行，将刚才计算出的偏移量和页目录表的线性基地址相加，得到的结果就是要访问的那个目录项的线性地址。

第375、376 行，测试该目录项的P 位，看它是否为“1”。如果为“1”，则表明对应的页表已经存在，只要在那个页表中添加一项即可；否则，必须先创建页表，并填写页目录项。

注意，尽管我们给出的就是线性地址，但是，那不是处理器段部件产生的线性地址，第366、367 行，令段寄存器DS 指向0～4GB 的内存段（段的基地址是0x00000000），此后，当我们用给出的“线性地址”作为段内偏移量访问内存，段部件才会输出真正的线性地址，尽管两者是相同的。总之，处理器的段管理机制是始终存在的，没有任何一种方法可以关闭它。

如果对应的页目录项不存在，那么，将执行第379～381 行的指令，以分配一个物理页作为页表，并将页的物理地址填写到页目录项内。为此，需要调用另一个过程allocate_a_4k_page 以得到一个可用的4KB 页。

### 页面位映射串和空闲页的查找

尽管每个任务都拥有4GB 虚拟内存空间，也可以自由分配这些空间，但是，物理内存是有限的，或者用页的视角来说，物理页的数量是有限的。

写这本书的时候，拥有4GB 的物理内存并不是一件值得羡慕的事情。但是，所谓水涨船高，要知道，现在的程序也极其庞大，而且往往都在内存中同时运行着。为了分配页，需要跟踪哪些页已经分配，哪些页是空闲的，这对操作系统来说是必做的事情。

很容易想到，操作系统必须在刚刚获得计算机控制权的时候，就检测实际的物理内存数量，并建立一张表格，标明页的物理地址及其是否空闲。当有程序申请内存时，就寻找这样的空闲页，并将其标记为已分配。

内存空间来自于插在主板上的内存条，按照新的工业标准，每个内存条上焊有一个很小的只读存储器，用于标明该内存条的容量和工作参数。作为一个PCI(E)设备，软件可以读取它，以获得计算机上的物理内存容量。然后建立上述的页分配表。

如果你的计算机上真的有4GB 物理内存，那么，它可以划分为1048576（2的20次方）个页。如果每个表项占一字节，则需要1MB 内存来创建该表。显然，这有些不划算。为了简单，可以使用位串来指示页的分配情况。

如图16-21 所示，可以用一个长的比特串，叫做页映射位串，来指示每个页的位置及分配情况。取决于你所拥有的实际内存数量（页数），该串最多可以有1048576 比特，由于每字节包含8个比特，所以，共需要131072 字节，也就是128KB。

![截图 2023-06-04 17-02-57](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 17-02-57.png)

比特在位串中的位置，决定了它所映射的页在哪里。如图16-21 所示，位0 对应的是物理地址为0x00000000 的页，位1 对应的是物理地址为0x00001000 的页，位2 对应的是物理地址为0x00002000 的页，……，最后一个比特对应的是最后一个页，即物理地址为0xFFFFF000 的页。

除了用比特所在的位置决定页的位置外，比特的值决定了页的分配情况。当某比特为“0”时，表示它所对应的页未分配，是可以分配的空闲页；否则，就表明那个页已经被占用了，不能再分配给任何程序。

在本章中，没有检测实际可用内存的代码，仅仅假定我们只有2MB 的物理内存可用。2MB的内存，可分为512 个页，需要512 个比特的位串。在实际的程序中，没有声明位串的方法，只能声明字节、字、双字等。因此，只能用连续的字节或字数据来形成位串。

回到代码清单16-1 中，第465 行，声明了标号page_bit_map，并初始化了64 字节的数据。这64 字节首尾相连，形成一个512 比特的位串。对照图16-21，第1 字节的位0 对应着物理地址为0x00000000 的页，第1 字节的位1 对应着物理地址为0x00001000 的页，……，第2 字节的位0 对应着物理地址为0x00008000 的页，以此类推。

耐心一点，仔细观察这个页映射位串，你会发现前32 字节的值差不多都是0xFF。这并不奇怪，它们对应着最低端1MB 内存的那些页（256 个页），它们已经整体上划归内核使用了，没有被内核占用的部分多数也被外围硬件占用了，比如ROM -BIOS。

当然，如果你眼很尖的话，也会发现其中混杂了两字节的0x55。这又是怎么回事呢？

回到前面，看图16-10，尽管画得不明显，但是依然能看出，在物理地址0x00030000～0x00040000 之间，是一段较为连续的空闲区，共64KB，可划分为16 个页，页的物理地址为0x00030000～0x00040000，就对应着这两字节。本来，这两字节都应当是0x00，以表明是可以分配的空闲页。不过，为了表明大的、连续的线性地址空间不必对应着连续的页，我们有意将空闲的页在物理上分开，因为0x55 的二进制形式是01010101。同样的做法也出现在后面的64 个页中。

当然，这么做未必合法，因为低端1MB 内存已经完整地分配给了内核，在内核的页表中，已经有页表项指向这16 个页。如果我们再把它分配给其他任务，那么，该任务的页表项也势必指向这16 个页，等于重复分配。不过，请放心，这16 个页内核是不会用到的，因此，分配给其他任务也无妨。

回到代码清单16-1 中，来看过程allocate_a_4k_page 是怎么搜索页映射位串并分配页的。

页映射位串位于内核数据段中。第332、333 行，先令段寄存器DS 指向内核数据段。

接着，第335～341 行，从头开始搜索位串，查找空闲的页。具体地说，就是找到第一个为“0”的比特，并记下它在整个位串中的位置。搜索位串用到了指令bts。

bts（Bit Test and Set）指令测试位串中的某比特，用该比特的值设置EFLAGS 寄存器的CF 标志，然后将该比特置“1”。它最基本的两种格式为

```assembly
bts r/m16, r16
bts r/m32, r32
```

在这里，目的操作数可以是16/32 位的通用寄存器，或者指向一个包含了16/32 位实际操作数的内存单元，用于指定位串；源操作数可以是16/32 位的通用寄存器，用于指定待测试的比特在位串中的索引（位置）。

如果目的操作数是通用寄存器，那么，指定的位串就是该寄存器的内容（长度为16 比特或者32 比特）。在这种情况下，根据操作数的长度，处理器先求得源操作数除以16 或者32 的余数，并把它作为要测试的比特的索引。然后，从位串中取出该比特，传送到EFLAGS 寄存器的CF 位。最后，将该比特置位。

则如果目的操作数是一个内存地址，那么，它给出的是位串在内存中的起始地址，或者说该位串第1 个字或者双字的地址。同样地，源操作数用于指定待测试的比特在串中的位置。因为串在内存中，所以其长度可以最大程度地延伸，具体的长度取决于源操作数的尺寸，毕竟它用于指定测试的位置。如果源操作数是16 位通用寄存器，位串最长可以达到2的16次方比特；如果源操作数是32 位的通用寄存器，则位串最长可以达到2的32次方比特。无论如何，在这种情况下，指令执行时，处理器会用目的操作数和源操作数得到被测比特所在的那个内存单元的线性地址。然后，取出该比特，传送到EFLAGS 寄存器的CF 位。最后，将原处的该比特置位。

除此之外，这两种指令格式的区别还在于具体操作时，处理器读取的数据的长度。挑选比特的工作是在处理器内部进行的，要先从内存中读取含有指定比特的字或双字。第一种指令格式进行的是16 位的内存操作，处理器读的是一个字；第二种指令格式进行的是32 位的内存操作，处理器读的是一个双字。

bts 指令并不孤独，同类型的指令还有btr、btc 和bt 它们的区别如表16-1 所示。

![截图 2023-06-04 17-03-57](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 17-03-57.png)

回到代码清单16-1。

搜索空闲页是一个机械的工作，要先从位串的第1 个比特开始。第335 行，先将EAX 寄存器清零，这表明我们要从位串的第1 个比特开始搜索。

第337 行，执行bts 指令。这将使指定的比特被传送到标志寄存器的CF 位，同时那一位被置“1”。置“1”是必做的工作，如果它原本就是“1”，这也没什么影响；如果它原本是“0”，那么，它就是我们要找的比特，它对应的页将被分配，而将它置“1”是应该的。

第338 行，判断位串中指定的位是否原本为“0”。如果答案是肯定的，那么，太好了，于是转到第348 行执行，准备退出当前过程；如果不是，那么，第339～341 行，将EAX 的内容加一，准备测试位串中的下一比特。在此之前，要先判断是否已经测试了位串中的所有比特，以防止越界。page_map_len 是一个用伪指令equ 声明的常数，位于第473 行，它的值就是位串的字节数。将它乘以8，就是位串的比特数。在最坏的情况下，没有找到可以用于分配的空闲页，则显示一条错误消息，并停机。当然，对于一个流行的操作系统来说，这样做是不对的，正确的做法是看哪些已分配的页较少使用，然后将它换出到磁盘，腾出空间给当前需要的程序，到时候再换回来。不过，这已经超出了本书的主题范围。

情况乐观时，会找到一个可以分配的空闲页，也就是一个为“0”的比特。第348 行，将该比特在位串中的位置数值乘以页的大小0x1000（或者十进制数4096），就是该比特所对应的那个页的物理地址。

找到了可用的页，任务也就完成了。第355 行用于返回到当前过程的调用者。可以看出，这是公共例程段内的内部过程，仅供同一段内的其他过程使用。返回时，页的物理地址位于EAX 寄存器中。

### 创建页表并登记分配的页

返回点位于过程alloc_inst_a_page 内，本次调用allocate_a_4k_page 过程的目的是分配一个页作为页表。页表的地址要登记在页目录表内，仅高20 位有效，对应着页表物理地址的高20 位，页表地址的低12 位是页表属性。从第380 行可以看出，页的属性值是0x007，即，US＝1，特权级别为3 的程序也可以访问；RW＝1，页是可读可写的；P＝1，页已经位于内存中，可以使用。内核的页表为什么允许特权级别为3 的程序访问呢？当然了，原则上是不允许的，但是，这个例程既要用于为内核分配页面，也要用于为用户任务分配页面。对于前者，要求将所分配页面的U/S位清“0”；对于后者，要求将所分配页面的U/S 位置“1”，这两者难以兼顾。为了不把事情搞复杂而又能说明问题，用当前过程所分配的页面，US 位一概设置成“1”。

刚分配的页是作为页表使用的，它应当登记在页目录表内，作为目录项存在。现在，ESI 寄存器中的内容就是该目录项的线性地址。第381 行，将目录项的内容修改为页表的物理地址。

过程alloc_inst_a_page 的功能是根据给定的线性地址，设置页目录表和页表的内容。因此，只有当页表不存在的时候，才动态分配一个页表。无论如何，现在页表已经有了，剩下的工作就是为那个线性地址分配一个最终的页，并登记在页表内。为此，需要访问页表。这同样是一个两难的问题，在分页机制下，访问内存需要通过页目录表和页表，而我们访问的正是页表。

这可如何是好？

不管页表是原来就有，还是刚才创建的，程序的执行流程最终会到达第385 行。因为用于分配页的线性地址位于EBX 寄存器中，这一行用于在ESI 寄存器中制作它的一个副本。

因为是要修改页表内的页表项，所以，无论如何，必须要知道该页表项的线性地址才行，这可以分几步来完成：

首先，我们知道，ESI 寄存器中的线性地址，其高10 位决定了页表在页目录表中的登记位置；中间10 位，决定了页在页表中的登记位置。很显然，要访问页表，就得把页表当成普通页来访问。如此一来，那个页表项在页表中的位置，就相当于数据在页中的位置。为此，应当把ESI寄存器的中间10 位乘以4 之后，挪到该寄存器的低12 位，作为页内偏移量；

其次，既然把页表作为普通的页来对待，那么，页部件势必要先访问该“页”的“页表”。页表的物理地址是登记在页目录表中的，它在页目录表中的位置由ESI 寄存器的高10 位指定，因此，就得把页目录表当成该“页”的“页表”来用，并把ESI 寄存器的高10 位挪到中间10 位上，作为页表项的索引号。

最后，为了将页目录表作为页表来用，要将ESI 寄存器的高10 位置成0x3FF。这意味着，页目录表内最后一个目录项就是页表的物理地址。又因为该目录项又指向页目录表自身，故，等于是又把页目录表当成页表来用。至此，任务完成，ESI 寄存器中得到的新值，就是要修改的那个页表项的线性地址。下面结合代码清单来讲一讲具体的做法。

第386～388 行，将ESI 寄存器中的内容右移10 次，清除两边，只保留中间的10 位，同时，将高10 位的内容改成二进制的1111111111（0x3FF）。这样一来，当页部件进行地址转换时，它用高10 位的0x3FF 乘以4 去访问页目录表。由于此表项存放的是页目录表自己的物理地址，因此，此表项所指向的页表，正是当前页目录表自己，这实际上是把页目录表当成页表来用。

接着，页部件又用中间的10 位去访问页表，其实就是访问页目录表自己。于是，它就得到了页的物理地址，其实就是页表的物理地址。很好，现在只需要低12 位的偏移量就可以了。因为是把页表当成普通的页来访问，因此，需要把原线性地址的中间10 位当成页内偏移量来用。

这就是说，现在ESI 寄存器中的内容，就是页表的线性地址。

调用者传入的线性地址依然完好地保存在EBX 寄存器中，到了过程的最后，也不必制造它的副本了，直接用吧。第391 行，用and 指令只保留中间的10 位，两边清零；第392 行，将它右移12 次，再乘以4（左移2 次），作为表内偏移量。因为无关位都已清零，故可以直接写成

```assembly
shr ebx, 10
```

页表的线性地址位于ESI 寄存器中，现在，第393 行，将它和EBX 寄存器中的偏移量相加（合并），就是要修改的那个页表项的线性地址。

要修改的位置找到了，但页还没有分配呢。第394 行，调用过程allocate_a_4k_page 分配一个页，并在EAX 寄存器中返回页的物理地址。第395 行，为其添加属性值0x007。第396 行，将页表项的内容修改为页的物理地址。

至此，给出一个起始的线性地址，分配一个页，并登记在层次化的分页结构中，任务完成。第403 行，retf 指令将控制返回到调用者。

### 创建内核任务的TSS

从过程allocate_a_4k_page 返回后，返回点位于代码清单16-1 的第1028 行。

在为系统内核的任务状态段（TSS）分配了虚拟地址空间和页之后，这一行将标号core_ next_laddr 处的数据修改为下一个可分配的起始线性地址。下一次在内核的虚拟地址空间里分配内存时，将使用这个新值作为起始的线性地址。

第1031～1038 行，填写和初始化TSS 中的静态部分，有些内容，比如CR3 寄存器域，对任务的执行来说很关键，必须事先予以填写。

一旦分配了物理页，并填写了页目录项和页表项，就立即可以用那个线性地址来访问内存。此时，整个过程是相反的，页部件用那个线性地址访问页目录表和页表，生成物理地址。还有，尽管你在指令中给出的确实是线性地址，但并非是由段部件生成的线性地址。在Intel 处理器上，段机制是无法关闭的，因此，你必须使用0～4GB 的段，加上你的“线性地址”，才得使段部件生成真正的线性地址，尽管两个线性地址在数值上没有任何不同。

因此，要访问TSS，必须通过段寄存器ES 所指向的0～4GB 数据段。

第1041～1046 行，创建内核任务的TSS 描述符，并安装到GDT 中。TSS 描述符选择子保存在内核数据段中，位于第530 行，在那里，声明了标号program_man_tss 并初始化了1 个字。在任务切换时，需要使用它。

由于当前任务事实上正处于运行中，因此，只要后补手续即可使其完全合法。第1050 行，将当前任务的TSS 描述符传送到任务寄存器TR。

## 用户任务的创建和切换

### 多段模型和段页式内存管理

一直以来，我们都工作在分段的内存管理模型上。如图16-22 所示，在保护模式下，首先按程序的结构分段，创建各个段的描述符，用描述符指向物理内存中的各个段。描述符中的基地址给出了段的起始物理地址，界限值给出了段的长度（边界），属性值指示了段的类型和特权级别等性质。

![截图 2023-06-04 18-33-16](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 18-33-16.png)

传统的多段模型（Multi-Segment Model）适用于开启了页功能之后的系统环境。如图16-23 所示，首先依然是按程序的结构分段，创建各个段的描述符。但是，段是在任务自己的虚拟地址空间内分配的，而不是在物理内存中分配的。因此，段描述符中的基地址是段的线性地址，或者说是虚拟地址。

因为开启了页功能，虚拟地址空间上的段要映射到物理内存中的一个或多个页。段是连续的，但它所占用的页不要求是相邻的。在未开启页功能之前，段基地址和段偏移相加产生的线性地址就是物理地址，开启页功能之后，线性地址还要经页部件转换后，才能得到实际的物理地址。

![截图 2023-06-04 18-34-36](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 18-34-36.png)

为什么要分段？这是个问题。

分段的做法是随着8086 处理器的流行和广泛应用而兴起的。那个时候，处理器是16 位的，只能处理16 位的地址数据，因此，可访问的内存空间是64KB。为了访问1MB 的内存，只能分段。如此一来，可以将控制从一个段转移到另一个段，也可以通过将新段的基地址加载到数据段寄存器（DS 和ES），来访问另一个段中的数据。总之，通过这种笨拙的、变通的、迂回的方法，就能间接地获得访问1MB 内存的能力。

在8086 处理器上增加分段机制还有一个额外的好处，那就是可以用很简单的方法实现程序的重定位，让程序在内存中的位置自由浮动，而又不影响它的访问和执行。但是，这只是一个附加的礼物，因为即使不分段，也有办法实现程序的自由浮动和重定位，只是肯定会麻烦很多。

任何事情只要一流行，就会被认为是必然的，而不管它事实上有多不合理。到了32 位处理器时代，分段的方法依然被完整地保留下来了。也许是真的动了脑筋、花了心思，处理器的设计者居然找到了分段模型的好处，那就是可以防止一个程序访问不属于自己的段。

但是，由于分页功能的出现，弱化了人们关于分段机制是否合理的信心。内存的访问是通过页目录表和页表进行的，每个任务都有自己的页目录表和页表，操作系统控制着物理页的分配权，除非它把一个页分配给某个任务，并填写到那个任务的页目录表和页表里，否则，那个任务不可能拥有访问那个内存位置的能力。

尽管处理器的设计者一直在宣称，把分段和分页机制结合在一起，将获得最大强度的保护功能，但是，事实上，在现实的软件设计者那里，多段模型已经不那么吃香了。

典型地，32 位的处理器拥有32 根地址线和32/64 根数据线，这使得它不用将4GB 或多于4GB 的内存空间划分成多个段，就能完全控制它。如此一来，软件设计者就会倾向于不分段。当然，程序的浮动和重定位将不可能再依赖于分段机制，但并不是没有其他办法。

### 平坦模型和用户程序的结构

不分段的内存管理模型称为平坦模型（Flat Model）。尽管说是不分段，但你千万不要信以为真，分段是Intel 处理器的固有机制，处理器总是按“段地址＋偏移量”来形成线性地址，不可能绕开这种工作机制。

因此，如图16-24 所示，所谓的平坦模型，就是将全部4GB 内存整体上作为一个大段来处理，而不是分成小的区块。在这种模型下，所有段都是4GB，每个段的描述符都指向4GB 的段，段的基地址都是0x00000000，段界限都是0xFFFFF，粒度为4KB。

在这种基本的平坦模式下，程序在编写的时候不分段，即，只保留一个段，代码和数据都在这个段内，相互邻接，但一般并不交叉。很显然，在这种模式下，不能享受到段保护机制的好处，段界限和数据访问的检查仍然进行，但从不会产生违例的情况。原因很简单，每个段描述符的基地址都是0，实际使用的段界限都是0xFFFFFFFF，就任务内的地址空间而言，对任何内存位置的访问都是合法的。

一个使用基本平坦模式的实例是代码清单16-2，程序没有分段，或者说只有一个大的段。在程序中，指令和数据的偏移量只和它们出现的自然位置有关。

在这里，一个基本的特点是，所有内容都是按类型组织的。比如，一开始是和整个程序有关的统计数据，比如程序的大小、入口点、U-SALT 的大小和起始位置等，在往常，这就是用户程序头部段；然后，是程序中用到的数据，包括U-SALT。传统上，这就是数据段；最后，是可执行代码部分。

![截图 2023-06-04 18-39-37](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 18-39-37.png)

传统上，这几个部分是以段为自然分界的。但是现在，它们混合在一起，按类型划分，而不是段，类似于几种流行的可执行文件中的节。

程序本身不大，但编译之后却很大。这是因为，第23 行，保留了一个很大的空白区域。在那里，声明了标号reserved，并初始化了128000 字节。空白区的位置选择也很特别，位于U-SALT的中间，把U-SALT 表分为遥遥相望的两部分，就像牛郎和织女。这是有意的，不管是写程序，还是处理器执行程序，内存的访问都应该是线性的、连续的、连贯的，为程序分配内存时，每个页在物理上本就不相邻，现在，U-SALT 这么庞大，必定会被分散于各处。这么做，只是为了验证处理器和当前程序是否能在分页机制下正常工作。

需要注意的是，U-SALT 的大小是256 字节对齐的，因为每个表项占256 字节。因此，空白数据的大小也应当是256 的整倍数。否则，在程序的重定位阶段，内核将不能正确地处理USALT 表。

### 用户任务的虚拟地址空间分配

现在，回到代码清单16-1，开始加载用户程序并创建相应的任务。

首先要创建任务控制块（TCB）。这本来不是个问题，但由于现在每个任务都拥有了自己独立的4GB 虚拟地址空间，问题就来了。

一般来说，所有任务的TCB 都应当占用内核的地址空间，在内核的虚拟地址空间里分配。任务都是由内核负责管理和调度的，如果TCB 位于任务自己的地址空间里，而不是内核的地址空间里，那么，这同时也意味着，在内核的页目录表和页表中，没有指向TCB 所在页的表项，内核不可能访问到它。

第1055～1057 行，用于在内核的虚拟地址空间里分配4KB 的内存（页），这和上一次在内核中分配内存的做法是一样的。

第1059～1062 行，初始化TCB，为某些域赋初值。任务控制块（TCB）的结构如图16-25 所示，和上一章相比，已经大大简化了，只保留了少数项目。这也意味着，和以往相比，用户程序的加载过程会简单得多。

![截图 2023-06-04 18-58-07](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 18-58-07.png)

在TCB 中，有两个项目应该在创建用户任务前就予以填写和初始化，它们是LDT 当前界限值和下一个可用的线性地址。LDT 当前界限值应该被初始化为0xFFFF，这是计算机启动时，LDTR 寄存器中的默认界限值，LDTR 中的界限部分只有16 位。LDT 的界限是LDT 的长度减一，LDT 的初始长度为0，因此，其界限值是0xFFFF。

每个任务都有自己的4GB 虚拟内存空间，线性地址范围是0x00000000～0xFFFFFFFF，它是任务自己的空间，可以任意分配和使用。当然，实际可以使用的空间是前2GB，后2GB 被任务的全局部分占用， 映射并指向内核的页表。一般来说， 第一个可以分配的线性地址是0x00000000，要把这个数值填写到TCB 的“下一个可用线性地址”域中。

在填写了以上两个TCB 域后，第1062 行，将此TCB 挂到TCB 链上。该链的作用将在第17章中进行抢占式任务切换时才能体现出来。

第1064～1067 行，在当前栈中压入两个参数，分别是用户程序的TCB 基地址和起始逻辑扇区号，然后调用过程load_relocate_program 加载和重定位用户程序，并创建为一个任务。

### 用户程序的加载

要加载用户程序，并将其创建为一个任务，首先要做的事就是分配内存空间。

在分页机制下，每个任务都有自己的4GB 虚拟地址空间，内存分配是在任务自己的地址空间上进行的。当然，内核可以做这些事，它为用户任务创建页目录表和页表，然后看看用户程序有多大，需要多少内存空间，根据需要分配若干物理页，并将它们登记在页目录表和页表中，以便能够访问它们。最后，将用户程序的内容从硬盘读出后写进这些页中。

可是，我们忘了一件事。

在上面，内核可以为用户任务创建页目录表和页表，也能够根据用户程序的大小分配物理页，并修改页目录表和页表，这都没问题。但是，它修改的应当是用户任务的页目录表和页表，而不是它自己的。要知道，现在是在内核中执行，处理器使用的是内核的页目录表和页表，这是由控制寄存器CR3 所决定的。在内存的访问上，处理器是公平的，因为即使是操作系统，也不能访问未在当前页目录表和页表中登记的内存空间。

好吧，那我们可以让内核先创建用户任务的页目录表，然后，临时改变控制寄存器CR3 的内容，使其指向这个新的页目录表，并在这个新表上做那些事情。等用户程序加载完毕，新任务也创建成功，再切换到内核自己的页目录表。

然而这也会出问题。内核也要靠自己的页目录表和页表才能正常工作，一旦改变了页目录表，新页目录表还是空的，当内核访问自己的地址空间时，处理器的页部件突然发现自己熟悉的页目录项全不见了。于是，又一个处理器异常不可避免地发生了。

一个可行的方案是，创建用户任务的页目录表，并将内核页目录表中的内容复制过去。然后，切换到用户任务的页目录表上去工作。这样做是合理的，我们一直在说，每个任务都拥有4GB 的虚拟内存空间，但前2GB 是它私有的，后2GB 是全局部分，映射到内核的地址空间。也只有这样，才能使内核能够继续正常运行，同时还能在页目录表的前半部分创建任务自己私有的分页系统。

上面的方法已经足够好了，如果还要说些什么的话，那就是，还有更好的办法。即，依然在内核的地址空间上工作，或者说，依然使用内核自己的页目录表，但只修改它的前半部分，因为那里属于任务的局部地址空间。最后，再把内核的页目录表复制一份，作为用户任务的页目录表。

要做什么，现在已经清楚了。现在，回到代码清单16-1，来看看具体的实施步骤。

第585～590 行和上一章相同，做一些寄存器内容的保护工作，并为访问栈中的参数做准备。

第592～602 行，用于将当前页目录表的前半部分清空。在每次创建一个新任务时，都应当清空内核页目录表的前512 个目录项。当前页目录表的后半部分是由内核使用的，内核的虚拟地址空间被映射在每个任务的高地址端，即0x80000000 之后。我们已经知道，当前页目录表的线性地址是0xFFFFF000，这是它的起始地址，位于EBX 寄存器中。ESI 寄存器用于提供每个表项的索引号，将索引号乘以4，再和基地址相加，就能得到每个目录项的线性地址，一共要处理512 个表项。

接下来要计算用户程序的大小，为完全加载它做准备。

第605、606 行，使段寄存器DS 指向内核数据段，准备从硬盘上把用户程序的第一个扇区读入内核缓冲区。

第608～610 行，从栈中取得用户程序所在的逻辑扇区号，和内核缓冲区的首地址一起，作为参数调用过程read_hard_disk_0，读取用户程序的第一个扇区。

用户程序的第一个双字就是它的大小，这是约定好的，故，第613 行，直接将内核缓冲区的第一个双字传送到EAX 寄存器。

和以往不同，现在的内存分配是按页进行的，所以最好使程序的大小能被4096 整除。第615 行，强制使程序的大小为4096 的整倍数，如果一个数能被4096 整除，那么它的最低12 位必然全是零。如此处理之后，新数值可能比原数值小。因此，第616 行，为它增加4096 字节，多总比少好。

第617、618 行，看一下处理之前的程序大小，如果人家本来就是4096 的整倍数（低12 位全是零），那就不用新值，还用旧值；如果原先的低12 位不全是零，说明我们处理得对，应该用新值。

第620、621 行，将程序的大小右移12 次，相当于除以4096，这得到的是它占用的页数。为什么要先传送到ECX 寄存器呢？原因是，下面要用ECX 寄存器的内容来控制循环次数。

循环的目的是分配物理页，并以4KB 为单位读取用户程序来填充页。这里不是一个循环，而是两个，而且是嵌套的，即外循环和内循环。外循环负责分配4KB 页，框架如下：

```assembly
  .b2:
         mov ebx,[es:esi+0x06]              ;取得可用的线性地址
         add dword [es:esi+0x06],0x1000
         call sys_routine_seg_sel:alloc_inst_a_page

         push ecx
         
         ;内循环代码
         
         pop ecx
     	 loop .b2
```

在循环开始之前，已经在第627 行把ESI 寄存器的内容置为用户程序TCB 的基地址。所以，外循环先访问用户任务的TCB，在它的虚拟内存空间上分配4KB 内存，并返回该段内存的线性地址。接着，用该线性地址分配一个4KB 的页。

以上就是外循环的功能，很简单。内循环嵌套在外循环中，也要用到ECX 寄存器，所以，在开始内循环之前，先将ECX 的内容压栈保存，内循环结束之后，立即将它出栈恢复，并开始下一次外循环。

内循环的代码如下：

```assembly
         mov ecx,8
  .b3:
         call sys_routine_seg_sel:read_hard_disk_0
         inc eax
         loop .b3
```

外循环每执行一次，内循环要完整地执行8 次。故，一开始就将ECX 寄存器的内容设为8。然后，反复调用过程read_hard_disk_0 从硬盘上读取用户程序。EAX 寄存器的内容是在第626 行设置的，是用户程序的起始逻辑扇区号，每读一个扇区后，inc 指令将其加一，指向下一个要读取的逻辑扇区。

过程read_hard_disk_0 需要两个参数，除了EAX 寄存器中的逻辑扇区号外，段寄存器DS 必须指向缓冲区所在的段，EBX 寄存器必须指向缓冲区的线性地址。EBX 寄存器中的线性地址在外循环中依靠内存分配得到，而段寄存器DS 是在第623、624 行设置的，在那里，令它指向0～4GB 的数据段。这就是为什么在ES 已经指向0～4GB 数据段的情况下，不用ES，而非得用DS的原因。

这段代码虽然简单，但有很多可说的地方。首先，分页机制下，内存是先登记，后使用的。内存在用户任务自己的虚拟地址空间上分配，过程alloc_inst_a_page 分配一个空闲的页，并登记到当前页目录表和页表中。只有这样做了之后，才能访问这段内存，才能把用户程序写进去。

其次，程序在编写和编译之后，都是连续的，在加载后不能保证这一点。页是随机分配的，在一个真实的系统中，两个页相邻的几率很小。但是，这不会影响到程序的正确执行。尽管页不是连续的，但线性地址必须是连续的，这就够了。处理器访问数据、取指令，用的是线性地址，只要线性地址从头至尾是连续的，页部件自会生成正确的物理地址。

最后，程序的加载必须从线性地址0x00000000 开始，也就是说，必须从整个虚拟地址空间的起始处开始加载。这是不合理的，但在本书中，只能这么做。原因是，首先，处理器始终要按段地址加偏移量的方法访问内存，这是不变的，在多段模型下，段内元素的偏移量都是相对于段的开始处。在程序加载后，段描述符中的基地址，就是段实际加载的位置。也正是因为如此，多段模型下，不管段加载到哪里，都不会影响到段内元素的访问，这就是多段模型下程序可以浮动和重定位的根本原因。

相反地，在平坦模型下，名义上是不分段，但实际上是只分一个大段。在这种情况下，不管程序实际上加载到哪里，代码段、数据段和栈段，其描述符的基地址都固定为0x00000000。这样一来，利用段机制实现程序的浮动和重定位就不可能了。

举个例子，在我们的代码清单16-2 中，程序的入口点位于程序内偏移量为0x04 的地方。要取得它的数值，需要使用指令

```assembly
mov ebx, [0x04]
```

在多段模型下，数据段描述符中的基地址，就是数据段在内存中的起始地址。如果程序加载后，数据段的基地址是0x00200000，那么，这条指令执行时，处理器发出的地址就是0x00200004，这是没有问题的。

然而，在平坦模型下，代码段、数据段和栈段描述符的基地址固定为0x00000000，而不管程序实际上加载到哪里。因此，同样的指令执行时，处理器发出的地址是0x00000004，而不是正确的地址0x00200004。

在流行的操作系统上工作，编写的程序必须符合一定的规范才能实现浮动和重定位。比如，为了在平坦模型下实现数据和代码的重定位，很多系统要求用户程序提供一个标准的重定位表，列出所有需要动态重定位的元素。程序加载后，操作系统会找到此表，用实际的加载位置修正每一个表项。

这是非常复杂的，而且显然已经超出了本书的主题范围。因此，我们要求，程序必须加载到任务虚拟地址空间的起始处。

### 段描述符的创建（平坦模型）

第644～652 行，在内核的地址空间内分配内存，创建用户任务的TSS。任务是由内核管理的，为了能够访问得到它，必须将其创建在内核的虚拟地址空间里。为了后面的代码访问TSS，TSS 的线性基地址要登记到任务控制块（TCB）中。

第655～658 行，创建用户任务的局部描述符表（LDT）。LDT 是任务私有的，要在它自己的虚拟地址空间里分配所需要内存空间。为了后面的代码访问LDT，LDT 的线性基地址要登记到任务控制块（TCB）中。

第661～667 行，创建用户任务的代码段描述符，并登记到LDT 中。从程序中可见，代码段描述符中的基地址是0x00000000，段界限值是0x000FFFFF，粒度为4KB，因此，实际使用的界限值是0xFFFFFFFF。用户任务的特权级别是3，因此，代码段描述符的特权级别也是3，段选择子的特权级别也设置成3。

第669、670 行，将代码段描述符的选择子登记到任务状态段（TSS）中。TSS 的线性地址是从任务控制块（TCB）中取得的。

第673 ～ 679 行， 创建用户任务的数据段描述符。和代码段描述符一样， 基地址为0x00000000，段界限也是0x000FFFFF，粒度为4KB。描述符特权级和段选择子的特权级都是3。

在平坦模型下，段寄存器DS、ES、FS 和GS 都指向同一个4GB 数据段。因此，第681～685行，将刚才生成的数据段描述符选择子填写到TSS 的DS、ES、FS 和GS 寄存器域中。

在平坦模型下，段只是容器，很大的容器。之所以要将段定义成4GB 大小，是希望可以发出任何虚拟地址，而不会被段部件的检查机制阻挠。当然了，骗得过段部件，骗不了页部件。容器是很大，但是，能不能拿到东西，要看你手伸到的地方有没有东西。因此，访问一个虚拟内存位置之前，必须提前在那里分配页。

在平坦模型下，栈段也要和其他段共享4GB 的虚拟内存空间。用户任务的数据段是3 特权级别的，而该任务固有的栈也是3 特权级别的，可以把上面的数据段选择子赋给段寄存器SS，把数据段作为栈段来用。真的可以吗？答案是，完全可以。尽管一般来说数据段是向上扩展的，而栈段是向下扩展的，但是，向上和向下，并不是用来限制压栈和出栈操作，而是规定处理器段部件检查段界限的方法。如果把向上扩展的数据段作为栈来用，那么，每当执行隐式的栈操作指令时（push、pop、call、ret 和iret），处理器的段部件按向上扩展的段来检查段界限，指令的执行过程和栈的推进方向依然不变，是向低地址方向的。

我们说了，段是容器，有4GB 大小，但必须提前分配页给那些要访问到的地方才行。在我们的用户程序（代码清单16-2）中，仅有数据和代码，没有定义栈空间。所以，定义了4GB 的栈段后，还要分配实际的栈空间才行。第688～690 行，在用户任务自己的虚拟地址空间内分配内存，分配了4KB，所以用户任务的固有栈就是4KB。第692～695 行，将CX 寄存器中的数据段选择子填写到TSS 的SS 寄存器域中，同时，填写TSS 的ESP 寄存器域。由于栈从内存的高端向低端推进，所以，ESP 寄存器域的内容被指定为TCB 中的下一个可分配的线性地址。

接下来是创建0、1、2 特权级的栈。毫无疑问，这三个栈段的基地址也是0x00000000，也要创建为向上扩展的数据段，段界限为0x000FFFFF，粒度为4KB。当然，这三个栈段，其描述符的特权级别不同，段选择子也不一样。第698～749 行就是用来创建这三个栈段的代码的，很好懂，不再一一解释。

截至现在，用户程序已经加载，相关的段描述符已经创建，如图16-26 所示。

![截图 2023-06-04 19-24-09](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 19-24-09.png)

### 重定位U-SALT 并复制页目录表

又到了重定位SALT 表的时候了，第753～794 行是重定位SALT 的代码。这段程序不管是在哪一章，都只有两行不一样，其余都一模一样，没有变化。具体到本章中，这两行是

```assembly
         mov ecx,[es:0x0c]                  ;U-SALT条目数 
         mov edi,[es:0x08]                  ;U-SALT在4GB空间内的偏移 
```

由于使用了平坦模型，而且启动了分页功能，所以，可以直接访问用户程序的虚拟内存空间，从中取得SALT 表的条目数和线性地址（4GB 段内偏移量）。

第797～803 行，创建LDT 描述符，并登记在GDT 中。处理器要求LDT 描述符必须登记在GDT 中。

第805～820 行，填写任务状态段（TSS）的其余部分。包括LDT 选择子域、I/O 位映射区的偏移地址、前一任务的TSS 链接域、TSS 的界限、EIP 和EFLAGS 寄存器域。特别要提到的是，EIP 域填写的是用户程序的入口点，这很重要，从内核任务切换到用户任务时，是用TSS 中的内容恢复现场的，所以这关系到任务应该从哪里开始执行。EFLAGS 域的内容是当前内核任务EFLAGS 寄存器的副本。

第823～828 行，创建TSS 描述符，并登记到GDT 中。处理器要求TSS 描述符必须登记在GDT 中。TSS 描述符的特权级DPL 必须是0，只有当前特权级别为0 的程序才能转换到该任务。因为任务切换应当由内核发起，而特权级为1、2 或3 的程序一般不允许主动发起任务切换。

现在，几乎所有的工作都完成了，剩下的事情，就是创建属于用户任务自己的页目录表。毕竟，你只是临时借用了内核任务的页目录表，当用户任务真正开始执行时，它不可能还使用内核的页目录表，那太不像话了。

我们说过，创建用户任务时，使用内核的页目录表，然后，再复制它，作为用户任务的页目录表。页目录表的复制工作是调用过程create_copy_cur_pdir 完成的。该过程位于第406 行，属于公共例程段。

第416～418 行，先令段寄存器DS 和ES 都指向0～4GB 数据段。说实话，如果内核也工作在平坦模型下，就不用这么麻烦了。

要创建页目录表，那当然先得分配一个空闲页。第420 行，首先调用过程allocate_a_4k_page分配一个页，页的物理地址由EAX 寄存器返回。第422 行，将页物理地址的低12 位改成属性，属性值为0x007，即，US＝1，允许特权级别为3 的用户程序访问该页；RW＝1，页是可读可写的；P＝1，页位于物理内存中。

为了能够访问到该页，我们把它的物理地址登记到当前页目录表的倒数第2 个目录项。我们知道，当前页目录表的线性地址是0xFFFFF000，它的倒数第2 个目录项在表内的偏移量为0xFF8。因此，页目录表内倒数第2 个目录项的线性地址是0xFFFFFFF8，第423 行，将附加了属性的页地址登记到该目录项。

要访问这个新的页目录表，必须知道它的线性地址。事实上，它的线性地址是0xFFFFE000。事情是这样的，让我们倒过来分析一下。首先，线性地址0xFFFFE000 的页目录索引值是0x3FF，指向当前页目录表的最后一项；页表索引值为0x3FE，是页表内倒数第2 项，存放的是页地址。要知道，当前页目录的最后一个目录项，存放的是页目录表自己的物理地址，页表就是当前页目录表自己，而倒数第2 个目录项，又是新页目录表的物理地址。这就证明了，0xFFFFE000 的确是新页目录表的线性地址。

既然两个表的线性地址都有了，那么，使用带rep 前缀的movsd 指令做表间复制工作最为方便。第425～429 行，按处理器的要求，设置好ESI 和EDI 寄存器，分别令它们指向当前页目录表和新页目录表；设置ECX 寄存器的内容为传送的次数（目录项数）；cld 指令设置传送的方向为正向，即，ESI 和EDI 在每次传送后递增。最后，执行movsd 指令，自动进行复制工作。

复制工作完成后，控制返回到第833 行。在那里，将新页目录表的物理地址填写到用户任务TSS 的CR3 寄存器域中。

最后，ret 8 指令从栈中弹出参数，并返回到第1069 行。

在多任务环境下，可以创建多个用户任务，使它们同时运行。如图16-27 所示，每个任务都拥有自己独立的4GB 虚拟地址空间，而且互相隔离。其中，前2GB 属于任务的私有地址空间，高2GB 是所有任务共有的全局地址空间，映射到内核的地址空间内。

每个任务都有自己独立的页目录表和页表，页目录表的前半部分对应着任务虚拟地址空间的前2GB，后半部分则映射到内核的页表。这样，当任务在自己独立的局部空间工作时，使用它自己的页表；当任务请求系统服务时，用的则是内核的页表，访问的是内核的代码和数据。

我相信，用这幅图作为最后的总结，可以使读者更清楚地在脑海中勾勒出分页机制下的虚拟内存分配全景，进一步加深对多任务、分页和虚拟内存分配原理的理解。

### 切换到用户任务执行

第1069～1072 行，先显示一条消息，告诉屏幕前的人，正在执行任务切换。接着，使用call指令发起任务切换。call 指令的参数是TCB 中的TSS 选择子。任务切换时，内核任务的状态被保存到当前的TSS 中，接着，找到用户任务的TSS，从中取出各种参数，加载到处理器的各个寄存器中，包括CR3 寄存器、LDTR、段寄存器、指令指针和栈指针寄存器、通用寄存器等。于是，用户任务就开始执行了。

![截图 2023-06-04 20-21-40](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 20-21-40.png)

来看代码清单16-2。

第46、47 行，显示字符串，表示任务当前正工作在页功能开启的状态下。

接着，第49～59 行，以十六进制的形式，显示当前任务4GB 虚拟地址空间内的前88 个双字。每次先显示两个空格，然后再显示双字的值，这样形成的效果是每行8 个双字，共11 行。如图16-28 所示，这是当前任务的运行结果。

空格字符串在第38 行，用标号space 声明，并初始化为3 字节。空格的ASCII 码为0x20，因此，这一行等效于

```assembly
space db ' ', 0
```

结合代码清单16-2，再来看屏幕上显示的内容。0x0001F88E 是用户程序的总长度，即129166字节；第2 个双字是0x1F85B，是用户程序的入口点；第3 个双字是0x00000010，这是U-SALT表的起始线性地址；第4 个双字是0x000001F8，这是U-SALT 表的条目数。不要忘了，我们在SALT 表的中间插入了以下语句：

```assembly
reserved times 256*500 db 0		;保留一个空白区，以演示分页
```

这直接导致多出500 个表项。加上原有的4 个表项，共504（0x000001F8）个表项。

![截图 2023-06-04 20-23-25](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-04 20-23-25.png)

从源程序中可知，紧接着显示的是U-SALT 表的内容。不过，每个表项的前6 字节已经被内核改成调用门选择子和偏移量了。SALT 表的内容是按字节定义的，当按双字值显示在屏幕上时，会显得颠倒错乱，请读者在有时间的情况下自行分析。

第61 行，将控制返回到内核中。

回到代码清单16-1。

控制返回到代码清单16-1 的第445 行。在那里，先根据EFLAGS 寄存器的NT 位，判断用户任务（当前任务）当初是怎么发起的。如果是由call 指令发起的，那么，就用iretd 指令转换到前一个任务（内核）；如果是由jmp 指令发起的，则直接用jmp 指令转换回内核任务。

无论如何，当任务切换后，一定会转换回内核任务，因为当前就两个任务。一旦内核任务恢复执行，而且执行点在第1074 行，紧接着当初发起任务切换的那条指令之后。

第1074～1077 行，内核显示一条消息，表示处理器要停机了。于是，它说到做到，停机。

## 程序的编译、执行和调试

### 本章程序的编译和运行方法

分别编译代码清单16-1（c16_core.asm）和16-2（c16.asm），并将编译后的文件写入虚拟硬盘，前者从逻辑扇区1 开始写入，后者从逻辑扇区50 开始写入。完成以上两项工作后，启动VirtualBox，就可以观察到运行结果。

### 察看CR3 寄存器的内容

可以在向页目录基地址寄存器PDBR（即控制寄存器CR3）写入页目录物理地址后察看它的内容。方法我们前面讲过，就是使用Bochs 的调试命令“creg”。

如图16-29 所示，这是在执行了代码清单16-1 中以下指令后的控制寄存器状态：

```assembly
         mov eax,0x00020000                 ;PCD=PWT=0  
         mov cr3,eax ;高20位保存页目录基地址，低12位除了PCD和PWT位外都没有使用。3是PWT，4是PCD。这两位用于控制页目录的高速缓存特性
;控制寄存器CR0 的最高位，也就是位31，是PG（Page）位，用于开启或者关闭页功能。当该位清零时，页功能被关闭，从段部件来的线性地址就是物理地址；当它置位时，页功能开启。只能在保护模式下才能开启页功能，当PE 位清零时（实模式），设置PG 位将导致处理器产生一个异常中断。
         mov eax,cr0 ;先读取控制寄存器CR0 的原始内容
         or eax,0x80000000  ;将其最高位置“1”，其他各位保持原来的数值不变
         mov cr0,eax                        ;开启分页机制
```

从图中可以清楚地看到，由于已经处于分页模式下（必须要先处于保护模式），所以CR0 的PE 位和PG 位都已处于置位状态，控制寄存器CR3 中的内容是当前任务页目录的物理地址，即，0x20000，PCD=0，页级缓存被禁用；PWT=0，页级通写被禁用。

![截图 2023-06-05 16-13-26](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-05 16-13-26.png)

### 察看线性地址对应的物理页信息

一旦进入分页模式，可以用“page”命令察看线性地址到物理页的映射信息。比如，如图16-30 所示，这里显示了线性地址0x7e08 所对应的物理页信息。

![截图 2023-06-05 16-13-48](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-05 16-13-48.png)

如图中所示，与线性地址0x7e08 对应的页表，其物理地址登记在页目录表中，是作为页目录项PDE 存在的，该目录项PDE 的内容是0x21003。即，页表的物理地址是0x21000。与线性地址0x7e08 对应的物理页，其地址登记在页表中，是作为页表项PTE 存在的，该页表项PTE 的内容是0x7003。这就是说，与线性地址0x7e08 相对应的页是0x7000。

### 察看当前任务的页表信息

可以察看当前任务的页表，显示线性地址和物理地址（页）的全部映射关系。要做到这一点，可以使用Bochs 的调试命令“info tab”。如图16-31 所示，这是在本章中初次进入分页模式后，页表的信息。

如图中所示，虚拟内存空间的低端1MB，即线性地址0x00000000～0x000FFFFF，对应着物理地址0x00000000～0x000FFFFF。这是可以理解的，因为在初次进入分页模式时，我们需要建立这低端1MB 内存空间的一一映射，使线性地址和物理地址相同。

![截图 2023-06-05 16-14-15](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-05 16-14-15.png)

为了用线性地址来修改页表的内容，我们把页表当成普通的页，把页目录表当成页表来用。在这种情况下，页表的线性首地址是0xFFC00000。因此，0xFFC00000～0xFFC00FFF 这段4KB的线性地址区间对应的是页表的实际物理地址0x00021000～0x00021FFF。

为了用线性地址访问和修改页目录表自己，页目录表的最后一个目录项，登记的是页目录表自己的物理地址。因此，页目录表的线性地址是0xFFFFF000。即，0xFFFFF000～0xFFFFFFFF 这段4KB 线性地址区间对应着实际的物理地址区间0x00020000～0x00020FFF。

在本章中，一旦通过单步执行，进入用户程序执行后，就可以察看用户任务的页表信息。如图16-32 所示，用户程序的页表信息比较庞大，但非常清楚地显示了整个内存空间的映射关系，特别是全局空间（内核）和局部空间是如何映射的。

![截图 2023-06-05 16-14-35](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-05 16-14-35.png)

现在，请你根据本章中用户程序的结构，结合Bochs 所显示的页表信息，逐一解释这些对应关系的含义。

### 使用线性（虚拟）地址调试程序

开启了分页模式之后，程序开始使用线性地址工作。相应地，在调试程序时，有时候只能知道线性地址，而不知道物理地址。在这种情况下，Bochs 允许你使用线性地址工作。

举个例子，我们以前一直用“xp”命令来显示内存单元的内容。相应地，“x”命令则显示一个线性地址单元里的内容。如图16-33 所示，当本章的用户任务开始执行后，它拥有独立的4GB虚拟地址空间。因此，我们可以用“x 0x0”命令显示当前任务4GB 虚拟空间内的头一个双字。

![截图 2023-06-05 16-15-32](/home/cccmmf/操作系统/x86/chap16/截图 2023-06-05 16-15-32.png)

对照本章代码16-2，线性地址为0 的地方，是程序的总大小，在这里是0x0001f88e。即，本章用户程序的大小是129166 字节。

除了在显示内存数据的时候使用线性地址，也可以在知道指令线性地址的时候，用线性地址设置断点，其命令是“lb”或者“vb”。具体使用方法，请使用Bochs 的帮助命令“help”（help lb、help vb）。
