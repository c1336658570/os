# 任务和特权级保护

在保护模式下，通过将内存分成大小不等的段，并用描述符对每个段的用途、类型和长度进行指定，就可以在程序运行时由处理器硬件施加访问保护。

段保护是处理器提供的基本保护功能，但仍是不够的。

当一个程序访问只属于它自己的段时，基本的段保护机制是很有效的。但是，一个失控的程序，或者一个恶意的程序，依然可以通过追踪和修改描述符表来达到它们访问任何内存位置的目的。比如说，如果用户程序知道GDT 的位置，它可以通过向段寄存器加载操作系统的数据段描述符，或者在GDT 中增加一个指向操作系统数据区的描述符，来修改只属于操作系统的私有数据。

其次，32 位处理器是为多任务系统而设计的。所谓多任务系统，是指能够同时执行两个以上程序的系统在单处理器（核）的系统中，处理器可以在多个任务之间周期性地切换和轮转。这样，它们都处于走走停停的状态，快速的处理器加上高效的任务切换，在外界看来，多个任务都在同时运行中。

多任务系统，对任务之间的隔离和保护，以及任务和操作系统之间的隔离和保护都提出了要求，这可以看做对段保护机制的进一步强化。同时，在多任务系统中，操作系统居于核心软件的位置，为各个任务服务，负责任务的加载、创建和执行环境的管理，并执行任务之间的调度，对操作系统的保护显得尤为重要。事实上，对于这种要求，基本的段保护机制已经无能为力了。

## 任务的隔离和特权级保护

### 任务、任务的LDT 和TSS

程序（Program）是记录在载体上的指令和数据，总是为了完成某个特定的工作，其正在执行中的一个副本，叫做任务（Task）。

一直以来，我们把所有的段描述符都放在GDT 中，而不管它属于内核还是用户程序。如图14-1 所示，为了有效地在任务之间实施隔离，处理器建议每个任务都应当具有自己的描述符表，称为局部描述符表LDT（Local Descriptor Table），并且把专属于自己的那些段放到LDT 中。

和GDT 一样，LDT 也是用来存放描述符的。不同之处在于，LDT 只属于某个任务。每个任务私有的段，都应当在LDT 中进行描述。LDT 的第1 个描述符，也就是0 号槽位，也是有效的、可以使用的。

![截图 2023-05-18 21-52-33](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-18 21-52-33.png)

为了追踪全局描述符表（GDT），访问它内部的描述符，处理器使用了GDTR 寄存器。全局描述符表（GDT）是全局性的，为所有任务服务，是它们所共有的，我们只需要一个全局描述符表（GDT）就够了。

和GDT 不同，局部描述符表（LDT）的数量则不止一个，具体有多少，视任务的多少而定。为了追踪和访问这些LDT，处理器使用了局部描述符表寄存器（LDT Register：LDTR）。

在一个多任务的系统中，会有很多任务在轮流执行，正在执行中的那个任务，称为当前任务（Current Task）。因为LDTR 寄存器只有一个，所以，它只用于指向当前任务的LDT。每当发生任务切换时，LDTR 的内容被更新，以指向新任务的LDT。和GDTR 一样，LDTR 包含了32位线性基地址字段和16 位段界限字段，以指示当前LDT 的位置和大小。

在访问内存之前需要先指定一个段，方法是向段寄存器的选择器传送一个段选择子，这称为“引用一个段”，像这样：

```assembly
mov cx, 0x0008
mov ds, cx
```

段选择子的位2 是表指示器（Table Indicator：TI），若TI＝0，表示从GDT 中加载描述符；TI＝1，表示从当前任务的LDT 中加载描述符。

0x0008 的二进制形式为0000 0000 0000 1000，其TI 位是“0”，所以，处理器将访问GDT，从1 号槽位取得描述符，并传送到段寄存器DS 的描述符高速缓存器。

```assembly
mov cx, 0x005c
mov ds, cx
```

0x005C 的二进制形式为0000 0000 0101 1100，TI 位是“1”，索引号为11（十进制）。访问当前任务的LDT（该LDT 在内存中的位置由LDTR指定），从它的11 号槽位取出描述符，并传送到段寄存器DS 的描述符高速缓存器中去。

因为段选择子是16 位的，而且只有高13 位被用做索引号来访问GDT 或者LDT，所以，每个LDT 所能容纳的描述符个数为2的13次方，即8192 个。每个LDT 只能定义8192 个段。又因为每个描述符的长度是8 字节，LDT 的长度最大为64KB。

在一个多任务的环境中，当任务切换发生时，必须保护旧任务的运行状态，或者说是保护现场，保护的内容包括通用寄存器、段寄存器、栈指针寄存器ESP、指令指针寄存器EIP、状态寄存器EFLAGS，等等。

为了保存任务的状态，并在下次重新执行时恢复它们，每个任务都应当用一个额外的内存区域保存相关信息，这叫做任务状态段（Task State Segment：TSS）。如图14-2 所示，任务状态段TSS 具有固定的格式，最小尺寸是104 字节，图中所标注的偏移量是十进制的。处理器固件能够识别TSS 中的每个元素，并在任务切换的时候读取其中的信息。

和LDT 一样，处理器用TR 寄存器来指向当前任务的TSS。TR 寄存器在处理器中也只有一个。当任务切换发生的时候，TR 寄存器的内容也会跟着指向新任务的TSS。这个过程是这样的：首先，处理器将当前任务的现场信息保存到由TR 寄存器指向的TSS；然后，再使TR 寄存器指向新任务的TSS，并从新任务的TSS 中恢复现场。

比较奇怪的是，为什么这个寄存器叫TR，而不是TSSR。原因很简单，TSS 是一个任务存在的标志，用于区别一个任务和其他任务。所以，这个寄存器叫做任务寄存器（Task Register：TR）

![截图 2023-05-18 22-21-39](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-18 22-21-39.png)

### 全局空间和局部空间

在多任务系统中，操作系统肩负着任务的创建，以及在任务之间调度和切换的工作。

从程序编写者的角度看，操作系统是他们可以信赖的朋友。首先，他们不必关心自己的程序是如何加载到内存并开始运行的，操作系统自然会处理好这些事情；其次，对设备的访问涉及大量的硬件细节，而且极为烦琐，操作系统能够肩负起设备管理的职责，并提供大量的例程和数据供应用程序调用。使用操作系统提供的这些服务，可以极大地简化程序的编写，并能够在访问设备时消除潜在的竞争和冲突。

比如说，当中断发生时，不可能由某个任务来进行处理，而只能由操作系统来提供中断处理过程，并采取适当的操作，以进行一些和所有任务都有关系的全局性管理工作，如空闲内存的查找和分配、回收已终止任务的内存空间、设备访问的排队和调度，等等。

这就是说，如图14-3 所示，每个任务实际上包括两个部分：全局部分和私有部分。全局部分是所有任务共有的，含有操作系统的软件和库程序，以及可以调用的系统服务和数据；私有部分则是每个任务各自的数据和代码，与任务所要解决的具体问题有关，彼此并不相同。

![截图 2023-05-18 22-32-34](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-18 22-32-34.png)

任务实际上是在内存中运行的，所以，所谓的全局部分和私有部分，其实是地址空间的划分，即全局地址空间和局部地址空间，简称全局空间和局部空间。

地址空间的访问是依靠分段机制来进行的。具体地说，需要先在描述符表中定义各个段的描述符，然后再通过描述符来访问它们。全局地址空间是用全局描述符表（GDT）来指定的，而局部地址空间则是由每个任务私有的局部描述符表（LDT）来定义的。

从程序员的角度来看，任务的全局空间包含了操作系统的段，是由别人编写的，但是他可以调用这些段的代码，或者获取这些段中的数据；任务局部空间的内容是由程序员自己创建的。通常，任务会在自己的局部空间运行，当它需要操作系统提供的服务时，转入全局空间执行。

段寄存器（CS、SS、DS、ES、FS 和GS）由16 位的选择器和不可见的描述符高速缓存器组成。选择器的位2 是表指示器TI，若TI＝0，指向GDT，表示当前正在访问的段描述符位于GDT 中；否则指向LDT，表示当前正在访问的段描述符位于LDT 中。

每个段描述符都对应着一个内存段。很显然，在一个任务的全局地址空间上，可以划分出2的13次方个段，也就是8192 个段。因为GDT 的0号描述符不能使用，故实际上是8191个段。因为段内偏移是32 位的，段的长度最大的4GB，因此，一个任务的全局地址空间，其总大小为2的13次方×2的32次方＝2的45 字节，即32TB。

同样的道理，局部描述符表LDT 可以定义2的13次方 个，也就是8192 个描述符，每个段的最大长度也是4GB，故，一个任务的局部地址空间为2的13次方×2的32次方＝2的45 字节，同样是32TB。

这样一来，每个任务的总地址空间为2的45次方＋2的45次方＝2的45次方×2＝2的45次方×2的1次方＝2的46次方字节，即64TB。在一个只有32 根地址线的处理器上，无论如何也不可能提供这样巨大的存储空间，但是，不要紧张，这只是虚假的，或者说虚拟的地址空间。操作系统允许程序的编写者使用该地址空间来写程序，即，使用虚拟地址或者逻辑地址来访问内存，就像他真的拥有这么巨大的地址空间一样。

上面一段话可以这样理解：编译器不考虑处理器可寻址空间的大小，也不考虑物理内存的大小，它只是负责编译程序。当程序编译时，编译器允许生成非常巨大的程序。但是，当程序超出了物理内存的大小时，或者操作系统无法分配这么大的物理内存空间时，怎么办呢？

同一块物理内存，可以让多个任务，或者每个任务的不同段来使用。当执行或者访问一个新的段时，如果它不在物理内存中，而且也没有空闲的物理内存空间来加载它，那么，操作系统将挑出一个暂时用不到的段，把它换出到磁盘中，并把那个腾出来的空间分配给马上要访问的段，并修改段的描述符，使之指向这段内存空间。下一次，当被换出的那个段马上又要用到时，再按相同的办法换回到物理内存。所有这一切，任务（如果它有思维的话）和程序的编写者是不必关心的，这就是虚拟内存管理的一般方法。

### 特权级保护概述

在分段机制的基础上，处理器引入了特权级，并由固件负责实施特权级保护。

特权级（Privilege Level），也叫特权级别，是存在于描述符及其选择子中的一个数值，当这些描述符或者选择子所指向的对象要进行某种操作，或者被别的对象访问时，该数值用于控制它们所能进行的操作，或者限制它们的可访问性。

Intel 处理器可以识别4 个特权级别，分别是0到3，较大的数值意味着较低的特权级别。如图14-4 所示，这是Intel 处理器所提供的4 级环状保护结构。

因为操作系统是为所有程序服务的，可靠性最高，而且必须对软硬件有完全的控制权，所以它的主体部分必须拥有特权级0。

特权级1和2通常赋予那些可靠性不如内核的系统服务程序，比较典型的就是设备驱动程序。在很多比较流行的操作系统中，驱动程序与内核的特权级别相同，都是0。

应用程序的可靠性被视为是最低的，而且通常不需要直接访问硬件和一些敏感的系统资源，调用设备驱动程序或者操作系统例程就能完成绝大多数工作，故赋予它们最低的特权级别3。

实施特权级保护的第一步，是为所有可管理的对象赋予一个特权级，以决定谁能访问它们。

每个描述符都有一个两比特的DPL 字段，可以取值为00、01、10 和11，分别对应特权级0、1、2 和3。DPL 是每个描述符都有的字段，故又称描述符特权级（Descriptor Privilege Level）。描述符总是指向它所描述的目标对象，代表着该对象，因此，该字段实际上是目标对象的特权级。

![截图 2023-05-19 17-37-58](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-19 17-37-58.png)

比如，对于数据段来说，DPL 决定了访问它们所应当具备的最低特权级别。如果有一个数据段，其描述符的DPL 字段为2，那么，只有特权级为0、1 和2 的程序才能访问它。当一个特权级为3 的程序也试图去读写该段时，将会被处理器阻止，并引发异常中断。对任何段的访问都要先把它的描述符加载到段寄存器，所以这种保护手段很容易实现。

在实模式下，段寄存器存放的是段地址；而在保护模式下，段寄存器存放的是段选择子，段地址则位于描述符高速缓存器中。当处理器正在一个代码段中取指令和执行指令时，那个代码段的特权级叫做当前特权级（Current Privilege Level，CPL）。正在执行的这个代码段，其选择子位于段寄存器CS 中，其最低两位就是当前特权级的数值。

一般来说，操作系统是最先从BIOS 那里接收处理器控制权的，进入保护模式的工作也是由它做的，而且，最重要的是，它还肩负着整个计算机系统的管理工作，所以，它必须工作在0 特权级别上，当操作系统的代码正在执行时，当前特权级CPL 就是0。

普通的应用程序则工作在特权级别3 上。应用程序编写时，不需要考虑GDT、LDT、分段、描述符这些东西，它们是在程序加载时，由操作系统负责创建的，应用程序的编写者只负责具体的功能就可以了。应用程序的加载和开始执行，也是由操作系统所主导的，而操作系统一定会将它放在特权级3 上。当应用程序开始执行时，当前特权级CPL 自然就会是3。

这实际上就是把一个任务分成特权级截然不同的两个部分，全局部分是特权级0 的，而局部空间则是特权级3 的。这种划分是有好处的，全局空间是为所有任务服务的，其重要性不言而喻。为了保证它的安全性，并能够访问所有软硬件资源，应该使它拥有最高的特权级别。当任务在自己的局部空间内执行时，当前特权级CPL 是3；当它通过调用系统服务，进入操作系统内核，在全局空间执行时，当前特权级CPL 就变成了0。

那些只有在当前特权级CPL 为0 时才能执行的指令，称为特权指令（Privileged Instructions）。典型的特权指令包括加载全局描述符表的指令lgdt（它在实模式下也可执行）、加载局部描述符表的指令lldt、加载任务寄存器的指令ltr、读写控制寄存器的mov 指令、停机指令hlt 等十几条。

除了那些特权级敏感的指令外，处理器还允许对各个特权级别所能执行的I/O 操作进行控制。通常，这指的是端口访问的许可权，因为对设备的访问都是通过端口进行的。如图14-5 所示，在处理器的标志寄存器EFLAGS 中，位13、位12 是IOPL 位，也就是输入/输出特权级（I/O Privilege Level），它代表着当前任务的I/O 特权级别。

![截图 2023-05-19 17-45-37](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-19 17-45-37.png)

任务是由操作系统加载和创建的，与任务相关的信息都在它自己的任务状态段（TSS）中，其中就包括一个EFLAGS 寄存器的副本，用于指示与当前任务相关的机器状态，比如它自己的I/O特权级IOPL。在多任务系统中，随着任务的切换，前一个任务的所有状态被保存到它自己的TSS中，新任务的各种状态从其TSS 中恢复，包括EFLAGS 寄存器的值。

处理器不限制0 特权级程序的I/O 访问，它总是允许的。但是，可以限制低特权级程序的I/O访问权限。

一般来说，控制转移只允许发生在两个特权级相同的代码段之间。如果当前特权级为2，那么，它可以转移到另一个DPL 为2 的代码段接着执行，但不允许转移到DPL 为0、1 和3的代码段执行。让特权级低的应用程序可以调用特权级高的操作系统例程，处理器也提供了相应的解决办法。

第一种方法是将高特权级的代码段定义为依从的。代码段描述符的TYPE 字段有C 位，如果C＝0，这样的代码段只能供同特权级的程序使用；否则，如果C＝1，则这样的代码段称为依从的代码段，可以从特权级比它低的程序调用并进入。

但是，即使是将控制转移到依从的代码段，也是有条件的，要求当前特权级CPL 必须低于，或者和目标代码段描述符的DPL 相同。

```assembly
CPL >= 目标代码段描述符的DPL
```

如果一个依从的代码段，其描述符的DPL 为1，则只有特权级别为1、2、3 的程序可以调用，而特权级为0 的程序则不能。在任何时候，都不允许将控制从较高的特权级转移到较低的特权级。

依从的代码段不是在它的DPL 特权级上运行，而是在调用程序的特权级上运行。被调用过程的特权级依从于调用者的特权级，这就是为什么它被称为“依从的”代码段。

除了依从的代码段，另一种在特权级之间转移控制的方法是使用门。门（Gate）是另一种形式的描述符，称为门描述符，简称门。和段描述符不同，段描述符用于描述内存段，门描述符则用于描述可执行的代码，比如一段程序、一个过程（例程）或者一个任务。

根据不同的用途，门的类型有好几种。不同特权级之间的过程调用可以使用调用门；中断门/陷阱门是作为中断处理过程使用的；任务门对应着单个的任务，用来执行任务切换。在本章里，我们重点介绍的是调用门（Call Gate）。

调用门描述符是64位的。在调用门描述符中，定义了目标过程（例程）所在代码段的选择子，以及段内偏移。要想通过调用门进行控制转移，可以使用jmp far 或者call far 指令，并把调用门描述符的选择子作为操作数。

使用jmp far 指令，可以将控制通过门转移到比当前特权级高的代码段，但不改变当前特权级别。如果使用call far 指令，则当前特权级会提升到目标代码段的特权级别。但是，除了从高特权级别的例程（通常是操作系统例程）返回外，不允许从特权级高的代码段将控制转移到特权级低的代码段，因为操作系统不会引用可靠性比自己低的代码。

从第11 章我们写第一个保护模式程序开始，我们就在创建DPL为0的描述符。

参见代码清单13-1，也就是源程序c13_mbr.asm，第24～37 行，创建了初始的几个段描述符：

```assembly
 		 ;创建1#描述符，这是一个数据段，对应0~4GB的线性地址空间
         mov dword [ebx+0x08],0x0000ffff    ;基地址为0，段界限为0xFFFFF
         mov dword [ebx+0x0c],0x00cf9200    ;粒度为4KB，存储器段描述符 

         ;创建保护模式下初始代码段描述符
         mov dword [ebx+0x10],0x7c0001ff    ;基地址为0x00007c00，界限0x1FF 
         mov dword [ebx+0x14],0x00409800    ;粒度为1个字节，代码段描述符 

         ;建立保护模式下的堆栈段描述符      ;基地址为0x00007C00，界限0xFFFFE 
         mov dword [ebx+0x18],0x7c00fffe    ;粒度为4KB 
         mov dword [ebx+0x1c],0x00cf9600
         
         ;建立保护模式下的显示缓冲区描述符   
         mov dword [ebx+0x20],0x80007fff    ;基地址为0x000B8000，界限0x07FFF 
         mov dword [ebx+0x24],0x0040920b    ;粒度为字节
```

这些段描述符的DPL都是0。

特权级保护机制只在保护模式下才能启用，而进入保护模式的方法是设置CR0 寄存器的PE位。而且，处理器建议，在进入保护模式后，执行的第一条指令应当是跳转或者过程调用指令，以清空流水线和乱序执行的结果，并串行化处理器。

```assembly
jmp dword 0x0010:flush
```

要将控制转移到这样的代码段，当前特权级CPL 必须为0。进入保护模式之后，处理器自动将当前特权级CPL 设定为0，以0特权级的身份开始执行保护模式的初始指令。

段选择子实际上由三部分组成，分别是描述符的索引号、表指示器TI 和RPL 字段。在以上指令中，段选择子0x0010 的TI 位是0，意味着目标代码段的描述符在GDT 中。该选择子索引字段的值是2，指向（GDT 中的）2 号描述符。

GDT 中的1 号描述符是保护模式下的初始代码段描述符，特权级DPL 为0，而当前特权级CPL 也是0，从初始的0 特权级转移到另一个0 特权级的代码段，这是允许的。转移之后，jmp 指令中的选择子0x0010 被加载到段寄存器CS，其低两位采用目标代码段描述符DPL 的值。控制转移之后，当前特权级仍为0。

DPL是段描述符中的那个特权级，RPL是段选择子最低2位。

RPL 的意思是请求特权级（Requested Privilege Level）。要将控制从一个代码段转移到另一个代码段，通常是使用jmp 和call 指令，并在指令中提供目标代码段的选择子，以及段内偏移量（入口点）。而为了访问内存中的数据，也必须先将段选择子加载到段寄存器DS、ES、FS 或者GS 中。不管是实施控制转移，还是访问数据段，这都可以看成是一个请求，请求者提供一个段选择子，请求访问指定的段。从这个意义上来说，RPL 也就是指请求者的特权级别（Requestor’s Privilege Level）。

大多数时候，请求者都是当前程序自己，因此，CPL＝RPL。要判断请求者是谁，最简单的方法就是看谁提供了选择子。

```assembly
jmp dword 0x0010:flush
```

提供选择子0x0008 的是当前程序自己。

再比如：

```assembly
         mov eax,0x0008                     ;加载数据段(0..4GB)选择子
         mov ds,eax
```

这同样是当前程序自己拿着段选择子0x0008 来“请求”代入段寄存器DS，以便在随后的指令中访问该段中的数据。

在一些并不多见的情况下，RPL 和CPL 并不相同。如图14-6 所示，特权级为3 的应用程序希望从硬盘读一个扇区，并传送到自己的数据段，因此，数据段描述符的DPL 同样会是3。

![截图 2023-05-19 18-14-13](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-19 18-14-13.png)

由于I/O 特权级的限制，应用程序无法自己访问硬盘。必须通过调用门才能使用，因为特权级间的控制转移必须通过门。通过调用门使用操作系统例程时，必须传入3 个参数，分别是CX 寄存器中的数据段选择子、EBX 寄存器中的段内偏移，以及EAX 中的逻辑扇区号。

高特权级别的程序可以访问低特权级别的数据段。因此，操作系统例程会用传入的数据段选择子代入段寄存器，以便代替应用程序访问那个段：

```assembly
mov ds, cx
```

在执行这条指令时，CX 寄存器中的段选择子，其RPL 字段的值是3，当前特权级CPL 已经变成0，因为通过调用门实施控制转移可以改变当前特权级。

上面的例子只是表明RPL 有可能和CPL 并不相同，但并没有说明引入RPL 到底有什么必要性。

如图14-7 所示，想象一下，应用程序的编写者通过钻研，知道了操作系统数据段的选择子，而且希望用这个选择子访问操作系统的数据段。当然，他不可能在应用程序里访问操作系统数据段，因为那个数据段的DPL 为0，而应用程序工作时的当前特权级为3，处理器会很机警地把来访者拒之门外。

![截图 2023-05-19 18-20-20](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-19 18-20-20.png)

但是，他可以借助于调用门。调用门工作在目标代码段的特权级上，一旦处理器的执行流离开应用程序，通过调用门进入操作系统例程时，当前特权级从3 变为0。当那个不怀好意的程序将一个指向操作系统数据段的选择子通过CX 寄存器作为参数传入调用门时，因为当前特权级已经从3 变为0，可以从硬盘读出数据，并且允许向操作系统数据段写入扇区数据。

处理器的智商很低，它不可能知道谁是真正的请求者。因此，当指令

```assembly
mov ds, ax
```

或者

```assembly
mov ds, cx
```

执行时，AX 或者CX 寄存器中的选择子可能是操作系统自己提供的，也可能来自于恶意的用户程序。怎么办？

它可以在原来的基础上多增加一种检查机制，并把如何能够通过这种检查的自由裁量权交给软件（的编写者）。

引入请求特权级（RPL）的原因是处理器在遇到一条将选择子传送到段寄存器的指令时，无法区分真正的请求者是谁。但是，引入RPL 本身并不能完全解决这个问题，这只是处理器和操作系统之间的一种协议，处理器负责检查请求特权级RPL，判断它是否有权访问，但前提是提供了正确的RPL；内核或者操作系统负责鉴别请求者的身份，并有义务保证RPL 的值和它的请求者身份相符。

操作系统的编写者很清楚段选择子的来源，即，真正的请求者是谁。当它提供一个服务例程时，3 特权级别的用户程序给出的选择子在哪里，也是由它定的，它也知道。在这种情况下，它所要做的，就是将该选择子的RPL 字段设置为请求者的特权级（可以使用arpl 指令，将在本章的后面介绍）。剩下的工作就看处理器了。每当处理器执行一个将段选择子传送到段寄存器（DS、ES、FS、GS）的指令，比如：

```assembly
mov ds, cx
```

时，会检查以下两个条件是否都能满足。

-  当前特权级CPL 高于或者和数据段描述符的DPL 相同。即，在数值上，CPL≤数据段描述符的DPL；
- 请求特权级RPL 高于或者和数据段描述符的DPL 相同。即，在数值上，RPL≤数据段描述符的DPL。

如果以上两个条件不能同时成立，处理器就会阻止这种操作，并引发异常中断。

### 总结

总结一下基本的特权级检查规则。

首先，将控制直接转移到非依从的代码段，要求当前特权级CPL 和请求特权级RPL 都等于目标代码段描述符的DPL。即，在数值上，

```assembly
CPL=目标代码段描述符的DPL
RPL=目标代码段描述符的DPL
```

典型的例子就是使用jmp 指令进行控制转移：

```assembly
jmp 0x0012:0x00002000
```

因为两个代码段的特权级相同，故，转移后当前特权级不变。

其次，要将控制直接转移到依从的代码段，要求当前特权级CPL 和请求特权级RPL 都低于，或者和目标代码段描述符的DPL 相同。即，在数值上，

```assembly
CPL >= 目标代码段描述符的DPL
RPL >= 目标代码段描述符的DPL
```

控制转移后，当前特权级保持不变。

第三，高特权级别的程序可以访问低特权级别的数据段，但低特权级别的程序不能访问高特权级别的数据段。访问数据段之前，肯定要对段寄存器DS、ES、FS 和GS 进行修改。这个时候，要求当前特权级CPL 和请求特权级RPL 都必须高于，或者和目标数据段描述符的DPL 相同。即，在数值上，

```assembly
CPL <= 目标数据段描述符的DPL
RPL <= 目标数据段描述符的DPL
```

处理器要求，在任何时候，栈段的特权级别必须和当前特权级CPL 相同。对段寄存器SS 的内容进行修改时，必须进行特权级检查。以下就是一个修改段寄存器SS 的例子：

```assembly
mov ss, ax
```

在对段寄存器SS 进行修改时，要求当前特权级CPL 和请求特权级RPL 必须等于目标栈段描述符的DPL。即，在数值上，

```assembly
CPL = 目标栈段描述符的DPL
RPL = 目标栈段描述符的DPL
```

0 特权级是最高的特权级别，当一个系统的各个部分都位于0 特权级时，各种特权级检查总能够获得通过，就像这种检查和检验并不存在一样。处理器的设计者建议，如果不需要使用特权机制的话，可以将所有程序的特权级别都设置为0，就像我们一直所做的那样。

小结

1. 程序员在写程序时，不需要指定特权级别。当程序运行时，操作系统将程序创建为任务局部空间的内容，并赋予较低特权级别，比如3，操作系统对应着任务全局空间的内容。如果有多个任务，则操作系统属于所有任务的公共部分。
2. 当任务运行在局部空间时，可以在各个段之间转移控制，并访问私有数据，因为它们具有相同的特权级别，但不允许直接将控制转移到高特权级别的全局空间的段，除非通过调用门，或者目标段是依从的代码段。
3. 当通过调用门进入全局空间执行时，操作系统可以在全局空间内的各个段之间转移控制并访问数据，因为它们也具有相同的特权级别。同时，操作系统还可以访问任务局部空间的数据，即低特权级别的数据段。但除了调用门返回外，不允许将控制转移到低特权级别的局部空间内的代码段。
4. 任何时候，当前栈的特权级别必须和CPL 是一样的。进入不同特权级别的段执行时，要切换栈。

## 内核程序的初始化

本章代码是前一章内核程序的修改版本，使用了任务、LDT、TSS 和特权级等最新的处理器特性和工作机制。

文件起始部分的常数定义了内核所有段的选择子。这些选择子的RPL 字段都是0，内核请求访问自己的段，请求特权级应当为0。

内核的入口点在第775 行。在执行到这里的时候，主引导程序已经加载了内核，并对它进行了前期的初始化工作。

因为加载的是内核程序，而内核应当工作在0 特权级，所以主引导程序在初始化内核时，所创建的描述符，其目标特权级DPL 都为0，如图14-8 所示。这些描述符都是在GDT中创建的。

![截图 2023-05-19 19-12-09](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-19 19-12-09.png)

这些描述符所指向的段，如果是数据段，则只有内核自己才能访问，因为其描述符的DPL是0，低特权级别的程序访问这些段时，会被阻止以防出现安全问题；如果是代码段，则通常只有0 特权级的程序才能将控制转移到该段。

第779～809 行，用于在屏幕上显示初始的信息，包括一个欢迎信息和一个处理器品牌信息。

### 调用门

上一章里，内核的主要功能是加载和重定位用户程序，并将处理器的控制权移交过去。用户程序执行完毕，还要重新回收控制。在上一章里，内核赋予用户程序的特权级别是0，所以用户程序是在0 特权级上运行的。也正是因为如此，当用户程序通过U-SALT 表中的符号地址直接调用内核例程时，才会通过特权级检查。

在本章里，内核也做同样的工作。不同之处在于，它将用户程序的特权级定为3。

本章将继续沿用第13 章的用户程序，只不过要作为一个任务进行加载，加载的方法和上一章是不同的。而且，运行时的特权级别是3，不再是上一章中的0。

为了方便应用程序的编写，内核通常要提供大量的例程供它们调用。例如，在第13 章中，用户程序可以调用内核例程@PrintString 和@ReadDiskData。为此，用户程序需要定义SALT 表，并在表中填写例程的符号名。之后，再由内核将符号名转换成入口地址，也就是该例程所对应的段选择子和段内偏移量。

例程是由内核提供的，它们的特权级通常就是内核的特权级。在上一章里，内核程序和用户程序都运行在0 特权级，而且都是普通的段间控制转移，所以，在用户程序内直接调用内核例程，这不会有任何问题。

本章中，用户程序运行时的特权级别将会是3。由于处理器禁止将控制从特权级低的程序转移到特权级高的程序，因此，如果还像以前那样直接调用内核例程，百分之百不会成功，一定会引发处理器异常中断。但是，现实的需求也不能不予考虑，任何操作系统都应当提供大量的功能调用服务。为此，需要安装调用门。

调用门（Call-Gate）用于在不同特权级的程序之间进行控制转移。本质上，它只是一个描述符，一个不同于代码段和数据段的描述符，可以安装在GDT 或者LDT 中。该描述符的格式如图14-9 所示，下面是低32 位，上面是高32 位。

![截图 2023-05-19 19-27-39](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-19 19-27-39.png)

调用门描述符给出了例程所在代码段的选择子，而不是32 位线性地址。有了段选择子，就能访问描述符表得到代码段的基地址，这样做无非是间接了一点，但却可以在通过调用门进行控制转移时，实施代码段描述符有效性、段界限和特权级的检查。

例程在代码段中的偏移量也是在描述符中直接指定的，只是被分成了两个16 位的部分。在通过调用门调用例程时，不使用指令中给出的偏移量。

描述符中的TYPE 字段用于标识门的类型，共4比特，值“1100”表示调用门。

描述符中的P 位是有效位，通常应该是“1”。当它为“0”时，调用这样的门会导致处理器产生异常中断。这个机关可能会很有用。比如，为了统计调用门的使用频率，可以将它置“0”。然后，每当因调用该门而产生异常中断时，在中断处理程序中将该门的调用次数加一，同时把P 位置“1”。对于因P 位为“0”而引起的中断来说，它们属于故障中断，从中断处理过程返回时，处理器还会重新执行引起故障的指令。此时，因P 已经为“1”，所以可以执行。就当前的例子而言，因为在提供调用门服务的同时，还要统计门的调用次数，故，可以在该调用门所对应的例程中将P 位清零。这样，下一次该门被调用时，又会重复以上过程。

通过调用门实施特权级之间的控制转移时，可以使用jmp far 指令，也可以使用call far 指令。如果是后者，会改变当前特权级CPL。因为栈段的特权级必须同当前特权级保持一致，因此，还要切换栈，即，从低特权级的栈切换到高特权级的栈。这主要是为了防止因栈空间不足而产生不可预料的问题，同时也是为了防止栈数据的交叉引用。

为了切换栈，每个任务除了自己固有的栈之外，还必须额外定义几套栈，具体数量取决于任务的特权级别。0 特权级任务不需要额外的栈，它自己固有的栈就足够使用，因为除了调用返回外，不可能将控制转移到低特权级的段；1 特权级的任务需要额外定义一个描述符特权级DPL 为0 的栈，以便将控制转移到0 特权级时使用；2 特权级的任务则需要额外定义两个栈，描述符特权级DPL 分别是0 和1，在控制转移到0 特权级和1 特权级时使用；3 特权级的任务最多额外定义3 个栈，描述符特权级分别是0、1 和2，在控制转移到0、1 和2 特权级时使用。

这些额外的栈，也会由操作系统加载程序时自动创建。

这些额外创建的栈，其描述符位于任务自己的LDT 中。同时，还要在任务的TSS 中登记，原因是，栈切换是由处理器固件自动完成的，处理器需要根据TSS 中的信息来完成这一过程。如图14-2 所示，在TSS 内，从偏移4～24 处登记有特权级0 到2 的栈段选择子，以及相应的ESP 初始值。任务自己固有的栈信息则位于偏移量为56（ESP）和80（SS）的地方。

任务寄存器TR 总是指向当前任务的任务状态段TSS，其内容为该TSS 的基地址和界限。在切换栈时，处理器可以用TR 找到当前任务的TSS，并从TSS 中获取新栈的信息。

通过调用门使用高特权级的例程服务时，调用者会传递一些参数给例程。如果是通过寄存器传送，这没有什么可说的。不过，要传递的参数很多时，更经常的做法是通过栈进行。调用者把参数压入栈，例程从栈中取出参数。在高级语言里，这是一贯的做法。

例程需要什么参数，先压入哪个参数，后压入哪个参数，这是调用者和例程之间的约定。但是，这一切对于处理器来说是懵懂的。特别是，当栈切换时，参数还在旧栈中。为了使例程能获得参数，必须将参数从旧栈复制到新栈中。

参数的复制工作是由处理器固件完成的，但它必须事先知道参数的个数，并根据该数量决定复制多少内容。所以，调用门描述符中还有一个参数个数字段，共5 比特。就是说，至多允许传送31 个参数。

栈切换前，段寄存器SS 指向的是旧栈，ESP 指向旧栈的栈顶，即最后一个被压入的过程参数；栈切换后，处理器自动替换SS 和ESP 寄存器的内容，使它们分别为新栈的选择子和新栈的栈顶（最后一个被复制的参数）。这一切，对程序的编写者来说是透明的。程序员不用关心栈的切换和参数的复制，他即使不知道还有栈切换这回事，也不会影响程序编写工作。因为，在栈切换前，

```assembly
pop edx
```

可以得到最后一个被压入的参数，在栈切换后，这条指令同样可以得到那个参数，尽管栈段和栈顶指针已经改变。

调用门描述符中的DPL 和目标代码段描述符的DPL 用于决定哪些特权级的程序可以访问此门。具体的规则是必须同时符合以下两个条件才行：

- 当前特权级CPL 和请求特权级RPL 高于，或者和调用门描述符特权级DPL 相同。即，在数值上

```assembly
CPL <= 调用们描述符的DPL
RPL <= 调用门描述符的DPL
```

- 当前特权级CPL 低于，或者和目标代码段描述符特权级DPL 相同。即，在数值上

```assembly
CPL >= 目标代码段描述符的DPL
```

如果调用门描述符的DPL 为2，那么，只有特权级为0、1 和2 的程序才允许使用该调用门，特权级为3 的程序使用此门将引发处理器异常中断。

如图14-10 所示，调用门的DPL 是特权级检查的下限。除此之外，目标代码段的特权级也是需要考虑的因素。调用门描述符中有目标代码段的选择子，它指向目标代码段的描述符。当一个程序通过调用门转移控制时，处理器还要检查目标代码段描述符的DPL，该DPL 决定了调用门特权级检查的上限。也就是说，只有那些特权级低于或者等于目标代码段DPL 的程序才允许使用此门。

调用门描述符中有一些字段没有使用，固定为“0”。

![截图 2023-05-19 19-48-00](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-19 19-48-00.png)

### 调用门的安装和测试

第812～826 行用于安装调用门的描述符，其实也就等于是在安装调用门。

安装的调用门供其他特权级的程序使用，它们在本质上是一些例程。上一章里，所有对外公开的例程都以字符串的形式定义在SALT 表中，该表位于内核数据段。

内核数据段中的SALT 表简称C-SALT，位于代码清单14-1 的第364～383 行，属于内核数据段。该表由多个条目组成，每个条目262 字节，其中，前256 字节是例程的名字，后6 字节是例程的地址（前4 字节是例程在目标代码段内的偏移量，后2 字节是例程所在代码段的选择子）。

所有例程都位于公共例程段中，而公共例程段的DPL 是0。为了使其他特权级的程序也能使用这些例程，必须将C-SALT 表中的例程地址转换成调用门。

转换过程使用了循环。转换时需要定位每一个条目，故，第812行用于将C-SALT 表的起始偏移地址传送到EDI 寄存器，这是第一个条目的位置，以后每次加上262，就能对准下一个条目。

循环次数是由条目数量控制的，条目数是常数salt_items，位于第386 行，第813 行的指令用于将它作为立即数传送到ECX 寄存器。

循环的结构是这样的：

```assembly
  .b3:
         push ecx   
         
         ;具体执行转换的指令
         
         add edi,salt_item_len              ;指向下一个C-SALT条目 
         pop ecx
         loop .b3         
```

因为在转换过程中要用到ECX 寄存器，所以在每次循环的一开始，要先压栈保存ECX 寄存器的值，然后，在loop 指令执行前恢复。

在循环体内，第816 行，用于将每个条目（例程）的32 位段内偏移地址传送到EAX 寄存器。每个条目的长度是262 字节，而它的偏移地址则位于256 字节处。第817 行，用于获取条目（例程）所在代码段的选择子，它位于条目内第260 字节处。

创建调用门描述符的工作实际上是调用过程make_gate_descriptor 来完成的。该过程位于第331 行，属于公共例程段。调用该过程时，需要传入三个参数，分别是EAX 寄存器中的32位偏移地址、BX 寄存器中的代码段选择子，以及。调用门的属性字段是2 字节的长度，通过CX 寄存器传入门属性时，必须保证各属性位都在原始位置。在我们的代码中，每次通过CX 寄存器传入的值是

```assembly
         mov cx,1_11_0_1100_000_00000B
```

很显然，P＝1，DPL＝3，即，只有特权级高于等于3 的代码段才能调用此门，参数的数量为0，也就是不需要通过栈传递参数。

下面我们来看一看例程make_gate_descriptor 都做了些什么。

第340～342 行，先在EDX 寄存器中得到32 位偏移地址的复制品，然后将低16 位清除，只留下32 位偏移地址的高16 位部分，并同CX 寄存器中的属性值一起，形成调用门描述符的高32 位。

第344～346 行，将EAX 寄存器的高16 位清除，只留下32 位偏移地址的低16 位。接着，将EBX 寄存器逻辑左移16 次，使得段选择子位于它的高16 位。最后，用or 指令将这两个寄存器合并，就得到了调用门描述符的低32 位。

第351 行，retf 指令使得控制返回调用者。注意，从这条指令可以看出，该过程必须以远调用的方式使用。

回到内核代码段。

第821 、822 行， 在调用了例程make_gate_descriptor 后， 立即调用了另一个例程set_up_gdt_descriptor 来安装刚才创建的调用门描述符。在GDT 中安装描述符的过程和前一章相同，不再讲述。显然，调用门描述符是在GDT 中创建的，并用CX 寄存器返回该描述符的选择子，即调用门选择子。

第823 行，将返回的调用门选择子回填到条目内，用以覆盖原先的代码段选择子。

取决于C-SALT 表的大小，循环过程会进行多次。在本章中，C-SALT 表中共有4 个条目，这4 个调用门安装之后，GDT 的布局如图14-11 所示。

第829、830 行对刚安装好的调用门进行测试，看它好不好用。测试的结果是在屏幕上显示一行文字，意思为“系统范围内的调用门已经安装”。

标号salt_1 指向C-SALT 表中第一个条目的起始处，在此基础上增加256，就是它的地址部分。现在我们已经知道，该条目对应着公共例程段中的put_string 过程，用于显示零终止的字符串。

表面上，这是一条普通的间接绝对远调用指令call far，通过指令中给出的地址操作数，可以间接取得32 位的偏移地址和16 位的代码段选择子，这样的指令我们太熟悉了。但是，处理器在执行这条指令时，会用该选择子访问GDT/LDT，检查那个选择子，看它指向的是调用门描述符，还是普通的代码段描述符。如果是前者，就按调用门来处理；如果是后者，还按一般的段间控制转移处理。

在这里，因为salt_1 条目的选择子已经被替换成调用门选择子，所以处理器按调用门的方式来执行控制转移。通过调用门实施控制转移时，处理器只用选择子部分，salt_1 条目中给出的32位偏移量部分被丢弃。原因很简单，通过调用门进行控制转移不需要偏移量，偏移量已经在调用门描述符中给出了。不单单是间接绝对远调用，直接绝对远调用也是这样，如果选择子指向的是调用门，偏移量也会被忽略，例如：

```assembly
call 0x0040:0x0000c000
```

在这个例子中，因为是通过调用门实施控制转移，处理器将忽略偏移量0x0000c000。

![截图 2023-05-21 19-23-20](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-21 19-23-20.png)

借助调用门，当程序的执行流从低特权级的代码段转入高特权级的代码段时，如果那是个非依从的代码段，当前特权级也随之变为目标代码段的特权级。不过，如果调用者和被调用者的特权级相同，则特权级不会变化。在当前的例子中，是从内核代码段调用公共例程段的例程，尽管也是通过调用门，但它们的特权级都是0。所以，在控制转移的过程中不会发生栈切换，仅仅是把返回地址CS 和EIP 压入当前栈。当执行retf 指令后，处理器从栈中恢复CS 和EIP 的原始内容，于是又返回到原先的代码段接着执行。

事实上，能够通过调用门发起控制转移的指令还包括jmp，但只用在不需要从调用门返回的场合下，而且不改变当前特权级。也就是说，目标代码是在当前特权级上执行。

通过调用门进行控制转移的特权级检查，既要在转移前进行，而且，还要在控制返回时进行。完整的特权级检查过程将在本章的后面进一步说明。

## 加载用户程序并创建任务

### 任务控制块和TCB 链

第832、833 行是以传统的方式调用内核例程显示字符串。即使不通过调用门，特权检查也是照常进行的，而且更为严格。把控制从较低的特权级转移到较高的特权级，通过调用门尚有可能，但直接控制转移则在任何时候都是不允许的。当然，在这里，是从0 特权级的内核代码段进入同样是0 特权级的公共例程段，能够通过特权级检查。

在内核初始化完成后，和第13 章一样，接下来的工作就是加载和重定位用户程序（ 应用程序），并移交控制权。按处理器的要求标准，要使一个程序成为“任务”，并且能够参与任务切换和调度，那不是简简单单就能行的，必须要有LDT 和TSS。而为了创建这两样东西，又需要更多的东西。所以，加载和执行用户程序的活儿，比起从前是麻烦了不少。不信？一会儿就要做这件事，到时候你就知道了。

加载程序并创建一个任务，需要用到很多数据，比如程序的大小、加载的位置，等等。当任务执行结束，还要依据这些信息来回收它所占用的内存空间（在本书中没有体现，但一个合格的操作系统必须实现该功能）。还有，多任务系统是多个任务同时运行的，特别是在一个单处理器（核）的系统中，为了在任务之间切换和轮转，必须能追踪到所有正在运行的任务，记录它们的状态，或者根据它们的当前状态来采取适当的操作（在本书的第16 章，将学习任务的切换和轮转技术）。

为了满足以上的要求，内核应当为每一个任务创建一个内存区域，来记录任务的信息和状态，称为任务控制块（Task Control Block，TCB）。任务控制块不是处理器的要求，是我们自己为了方便而发明的。如图14-12 所示，这是任务控制块的结构，很明显，这里有两种大小的方格，较窄的格子代表16位的数据宽度，即1 个字；而较宽的格式代表32 位的数据宽度，即2 个字。注意，不要纠结于表中的内容和细节，有个大概印象即可。

![截图 2023-05-21 20-46-40](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-21 20-46-40.png)

为了能够追踪到所有任务，应当把每个任务控制块TCB 串起来，形成一个链表。

代码清单14-1 的第414 行，声明了标号tcb_chain 并初始化为一个双字，初始的数值为零。实际上，它是一个指针，用来指向第一个任务的TCB 线性基地址。当它为零时，表示任务的数量为0，也就是没有任务。在创建了第一个任务后，应当把该任务的TCB 线性基地址填写到这里。

每个TCB 的第一个双字，也是一个双字长度的指针，用于指向下一个任务的TCB。如果该位置是零，表示后面没有任务，这是链上的最后一个任务；否则，它的数值就是下一个任务的TCB线性基地址。如图14-13 所示，所有任务都按照被创建的先后顺序链接在一起，从tcb_chain 开始，可以依次找到每一个任务。

![截图 2023-05-21 20-50-08](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-21 20-50-08.png)

第836～838行，用于分配创建TCB 所需要的内存空间，并将其挂在TCB 链上。如图14-12所示，当前版本的TCB 结构需要0x46 字节的内存空间。

将新TCB 追加到链表上的工作是由过程append_to_tcb_link 来完成的，位于代码清单14-1 的第735～772 行，属于内核代码段的内部（近）过程，图14-14 是它的整个流程图。

过程append_to_tcb_link 的工作思路是遍历整个链表，找到最后一个TCB，在它的TCB 指针域里填写新TCB 的首地址。它需要用ECX 作为传入的参数，ECX 的内容应当为新TCB 的线性地址。

这里有一个小小的麻烦。链首指针tcb_chain 是在内核数据段声明并初始化的，只能知道它在段内的偏移，而不知道它的线性地址，因此，只能通过内核数据段访问，而无法通过线性地址来访问；相反地，链上的每个TCB，其空间都是动态分配的，只能通过线性地址来访问。

因此，在将两个段寄存器和两个通用寄存器压栈保护之后，第742～745 行，我们令段寄存器DS 指向内核数据段以读写链首指针tcb_chain，而ES 指向整个4GB 内存空间，用于遍历和访问每一个TCB。

第747 行，要追加的TCB 一定是链表上最后一个TCB，故其用于指向下一个TCB 的指针域必须清零，以表明自己是链上最后一个TCB。每个TCB 的空间都是动态分配的，其首地址都是线性地址，只能用由段寄存器ES 所指向的4GB 段来访问。

第750～752 行，观察链首指针tcb_chain 是否为零。若为零，则表明整个链表为空，直接转移到第763 行的标号.notcb 处，在那里，直接将链首指针指向新的TCB，恢复现场后直接返回调用者。

第754～758 行，若链首指针不为零，表明链表非空，需要顺着整个链找到最后一个TCB。和链首指针tcb_chain 不同，每个TCB 需要用4GB 的段来访问，即使用段寄存器ES。

![截图 2023-05-21 20-53-23](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-21 20-53-23.png)

首先，将链表中要访问的那个TCB 的线性地址传送到EDX 寄存器；然后，访问它的TCB 指针域，看它是否为零。如果不为零，表明它不是链中最后一个TCB，后面还有其他TCB，于是将控制转移到.searc，令EDX 寄存器指向下一个TCB，继续搜寻。

若为零，表明它就是链上最后一个TCB，第760 行，用ECX 的内容填写其TCB 指针域，让它指向新的TCB。完成后，第761 行，直接转移到标号.retpc 处，恢复现场并返回调用者。

### 使用栈传递过程参数

下面的工作是加载和重定位用户程序，依然是在过程load_relocate_program 中进行。该过程需要传入两个参数，分别是用户程序的起始逻辑扇区号，以及它的任务控制块TCB 线性地址。和上一章不同的是，参数不是用寄存器传入的，而是采用栈。事实上，这是更为流行和标准的做法。原因很简单，寄存器数量有限，况且还要在过程内部使用，当传入的参数很多时，栈是最好的选择。

第840～843 行，先以双字的长度将立即数50 压入当前栈，这是用户程序的起始逻辑扇区号。在第10 章里，我们已经知道push指令可以压入立即数。因此，在这里，压入到栈中的内容将是双字0x00000032（十进制数50）。接着，再压入当前任务控制块TCB 的32 位线性地址。最后，进入过程load_relocate_program 内部执行。该过程位于第464 行，是（当前）内核代码段的内部过程。

第468～473 行，先做一些保护现场的工作，然后将栈指针寄存器ESP的内容复制到EBP寄存器，以访问栈中的参数。栈的访问有两种，一种是隐式的，由处理器在执行诸如push、pop、call、ret 等指令时自动进行。隐式地访问栈需要使用指令指针寄存器ESP。另一种访问栈的方式不依赖于先进后出机制，而是把栈看成是一般的数据段，直接访问其中的任何内容。在这种方式下，需要使用栈基址寄存器EBP。这里有个例子，比如，从栈中读取一个双字，该数据在栈中的偏移量是由EBP 寄存器指向的：

```assembly
mov edx, [ebp]
```

在32 位模式下，处理器执行这条指令时，用段寄存器SS描述符高速缓存器中的32 位基地址，加上EBP 寄存器提供的32 位偏移量，形成32 位线性地址，访问内存取得一个双字，传送到EDX 寄存器。很显然，用EBP 寄存器来寻址时，不需要使用段超越前缀“SS:”，因为EBP 寄存器出现在指令中的地址部分时，默认使用段寄存器SS。

如图14-15 所示，这是用ESP 寄存器的内容初始化EBP 后，栈的状态。

![截图 2023-05-22 20-14-22](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-22 20-14-22.png)

当前的栈顶位置是SS:EBP，指向一个双字，是段寄存器ES 的内容，因为最近一次的压栈操作是

```bash
push es
```

在32 位模式下，访问栈用的是栈指针寄存器ESP，而且，每次栈操作的默认操作数大小是双字。处理器在执行压栈指令时，如果发现指令的操作数是段寄存器（CS、SS、DS、ES、FS、GS），那么，将先执行一个内部的零扩展操作，将段寄存器中的16 位值扩展成32 位，高16 位是全零，然后再执行压栈操作。当然，出栈指令pop 会执行相反的操作，将32 位的值截短为16位，并传送到相应的段寄存器。

相应地，SS∶EBP＋4 的位置是段寄存器DS 的压栈值。因为栈是向下推进的，故较早压入的内容反而位于高地址方向，回溯它们需要增加EBP 的值。

从SS∶EBP＋8 的位置开始，是pushad 指令压入的8 个双字，其中就包括EBP 在压栈时的原始内容。

再往上，是调用者的返回地址。因为load_relocate_program 是一个内部过程，是用32 位相对近调用（第843 行）进入的，故只压入了EIP 的内容，而没有压入段寄存器CS 的内容。

好了，现在终于到了我们感兴趣的地方。当初调用load_relocate_program 过程的时候，压入了两个参数，分别是任务控制块TCB 的线性地址，以及用户程序的起始扇区号。从图15-15 中可以看出，TCB 线性地址是栈中的第11 个双字（从0 开始算起）。也正是因为如此，TCB 线性地址在栈中的位置是SS∶EBP＋44。

同样的道理，用户程序起始逻辑扇区号在栈中的位置是SS∶EBP＋48。记好这两个数的位置，一会儿我们就要多次从栈中访问它们。

### 加载用户程序

当用户程序被读入内存，并处于运行或者等待运行的状态时，就视为一个任务。任务有自己的代码段和数据段（包括栈），这些段必须通过描述符来引用，而这些描述符可以放在GDT 中，也可以放在任务自己私有的LDT 中，但最好是放在LDT 中。GDT 用于存放各个任务公有的描述符，比如公共的数据段和公共例程。

每个任务都允许有自己的LDT，而且可以定义在任何内存位置。所以，我们现在要做三件事：

- 分配一块内存，作为LDT 来用，为创建用户程序各个段的描述符做准备；
- 将LDT 的大小和起始线性地址登记在任务控制块TCB 中；
- 分配内存并加载用户程序，并将它的大小和起始线性地址登记到TCB 中。

第475、476 行，令段寄存器ES 指向4GB 内存段。

第478 行，先从栈中取得TCB 的线性首地址。注意，因为源操作数部分使用的是基址寄存器EBP，故该指令默认使用段寄存器SS来访问内存（栈）。

接着，第481～484 行，申请分配160 字节的内存空间用于创建LDT，并登记LDT 的初始界限和起始线性地址到TCB 中。LDT 的界限也是16 位的，只允许8192 个描述符。和GDT 一样，界限值是表的总字节数减1，因为我们刚创建LDT，总字节数为0，所以，当前的界限值应当是0xFFFF（0 减去1）。

我们的用户程序很简单，不会划分为太多的段，160 字节的空间可以安装20 个描述符，应当足够了。如图14-12 所示，LDT 的线性起始地址是登记在TCB 内偏移0x0C 处，LDT 的界限是登记在TCB 内偏移0x0A 处。TCB 当初也是动态分配的，需要通过段寄存器ES 指向的4GB段来访问。

第487～500 行，先将用户程序头部读入内核缓冲区中，根据它的大小决定分配多少内存。具体的方法和策略在上一章已讲解过了，唯一需要说明的是，在调用过程sys_routine_seg_sel:read_ hard_disk_0 之前，用户程序的起始逻辑扇区号是从栈中取得的。

第502～504 行，根据用户程序的实际大小申请分配内存空间，并将线性基地址和用户程序的大小登记到TCB 中（参考图14-12）。

一旦知道了用户程序的总大小，接下来，第506～519 行的工作就是加载整个用户程序，这和上一章也是相同的。唯一不同的是，第515 行，从栈中重新取得用户程序的起始逻辑扇区号。

### 创建局部描述符表

用户程序已被加载到内存中，现在该是在LDT 中创建段描述符的时候了。

第521 行，从TCB 中取得用户程序在内存中的基地址。早在第478 行，我们就已经让ESI寄存器指向了TCB 的基地址。当然，TCB 的基地址位于栈中，也可以从栈中取得。

第524～528 行，因为用户程序头部的起始地址就是整个用户程序的起始地址，故将EDI 寄存器的内容传送到EAX 寄存器，作为过程sys_routine_seg_sel:make_seg_descriptor 的第一个参数，即段的起始地址。接着，从头部中取得用户程序头部段的长度，作为第二个参数传送到EBX 寄存器。因为段界限是段的长度减一，故还要将EBX 寄存器的内容减1。最后，作为第三个参数，在ECX 寄存器中置入段的属性。请参考段描述符的格式，可以知道，这是一个32 位的可读写数据段，字节粒度，尤其重要的是，其描述符特权级DPL 为3，即最低的特权级。这是可以理解的，谁也不愿意使自己的特权级为3，但这由不得你，谁让你落在操作系统的手上，由它来负责加载呢！

调用过程sys_routine_seg_sel:make_seg_descriptor 后，会在EDX:EAX 中返回64 位的段描述符。第531、532 行用于调用另一个过程fill_descriptor_in_ldt 把刚才创建的描述符安装到LDT 中。

fill_descriptor_in_ldt 是当前内核代码段的内部（近）过程，位于第421 行，用于在当前任务的LDT 中安装描述符。它需要传入两个参数，一个是要安装的描述符，由EDX:EAX 共同提供；另一个是当前任务控制块的基地址，由EBX 寄存器提供。它用这个地址来访问TCB 以获得LDT 的基地址和当前的大小（界限值），并在安装描述符后更新LDT 的界限值。

第425～428 行，执行例行的现场保护工作，将过程中用到的各个寄存器压栈保护。

第430～433 行，先使段寄存器DS 指向4GB 的内存段；然后，访问TCB，从中取出LDT 的基地址传送到EDI 寄存器。

新描述符的线性地址可以用LDT 的基地址加上LDT 的总字节数得到。第435～440 行，计算用于安装新描述符的线性地址，并把它安装到那里。在这里，ECX 寄存器有两个相关联的用途，一个是在第439 和440 行寻址内存，以安装描述符；另一个是在第436、437 行用于计算LDT 的大小，但只能使用其16 位的CX 部分。想想看，当第一次在LDT 中安装描述符时，LDT 的界限值是0xFFFF，加1 之后，总大小是0x0000，进位部分要丢弃。对CX 寄存器的操作不会影响到ECX 寄存器的高16 位。即使CX 寄存器产生了进位，进位也会丢弃，而决不会跑到ECX 寄存器的高16 位。注意以下指令执行结果的不同：

```assembly
xor ecx, ecx	;ecx <- 0x0
mov cx, 0xffff
inc cx			;ecx = 0x0

xor ecx, ecx	;ecx <- 0x0
mov cx, 0xffff
inc ecx			;ecx = 0x00010000
```

和GDT 不同，LDT 的0 号槽位也是可用的。原因在于，其选择子的TI 位是“1”，所以不可能会有一个全零的选择子指向LDT。这就是说，一个指向LDT 的选择子代入段寄存器时，它不可能是因程序员粗心大意而未初始化的。

第442、443 行，将LDT 的总大小（字节数）在原来的基础上增加8 字节，再减去1，就是新的界限值。第445 行，将这个新的界限值更新到TCB 中。

第447～450 行，将描述符的界限值除以8，余数丢弃不管，所得的商就是当前新描述符的索引号。

第452～454 行，将CX 寄存器中的索引号逻辑左移3 次，并将TI 位置1，表示指向LDT，这就得到了当前描述符的选择子。

接着回到过程load_relocate_program 中。

过程fill_descriptor_in_ldt 在LDT 中安装描述符后，用CX 寄存器返回一个选择子。第534～536 行，用于将选择子的请求特权级RPL 设置为3，登记到TCB，并回填到用户程序头部。在LDT 中安装的描述符，通常只由用户程序自己使用，即，在请求访问这些段时，请求者是用户程序自己。因此，其选择子的RPL 和用户程序的特权级始终一致。

### 重定位U-SALT表

从第539 行开始，一直到第576 行结束，分别是创建用户程序代码段、数据段和栈段描述符，并将它们安装在LDT 中。除了往LDT 中安装描述符，以及其他一些细节上的差别外，这部分代码和上一章相比，大体上是一致的，都很好理解，不需要一一详述。但是，必须要说明的是，在这个过程中所创建的段描述符，其特权级DPL 都是3，而且，这些段描述符的选择子，其请求特权级RPL 也都是3。

从第579 行开始，到第620 行结束，用于重定位用户程序的U-SALT 表。和第13 章相比，绝大多数代码都是相同的，具体的工作流程也几乎没有变化。当然，因为涉及特权级，个别的差异还是有的。

U-SALT 位于用户程序头部段。为了访问它，第14 章的做法是先用段寄存器ES 指向用户程序头部段，再访问该段内的U-SALT 表。当然，前提是用户程序头部段的描述符已经安装并开始生效。

在本章中，用户程序各个段的描述符位于LDT 中，尽管已经安装，但还没有生效（还没有加载局部描述符表寄存器LDTR）。在这种情况下，只能通过4GB 的段来访问U-SALT。所以，第579、580 行用于令段寄存器ES 指向4GB 的内存段。在前面的代码中，是令EDI 寄存器指向用户程序起始加载地址的，这也就是用户程序头部段的起始线性地址。因为U-SALT 的条目数位于头部段内偏移0x24 处。故，程序中用以下指令来取得该条目数（第587 行）：

```assembly
mov ecx, [es:edi+0x24]
```

同样的道理，因为U-SALT 表位于头部段内偏移0x28 处，要想得到U-SALT 表的线性基地址，使EDI 寄存器指向它，程序中使用的是以下指令（第588 行）：

```assembly
add edi, 0x28
```

具体的重定位过程在第13 章里已经讲得很清楚了，无非就是找到名字相同的C-SALT 条目，把它的地址部分复制到U-SALT 的对应条目中。在第13 章里，复制的是16 位的代码段选择子和32 位的段内偏移。在本章中，这些地址不再是普通的段选择子和段内偏移，而是调用门选择子和段内偏移。

当初，在创建这些调用门时，选择子的RPL 字段是0。也就是说，这些调用门选择子的请求特权级是0。当它们被复制到U-SALT 中时，应当改为用户程序的特权级（3）。

为此，第605、606 行，因为ESI 寄存器指向当前条目的地址部分，所以4 字节之后的地方是该地址的选择子部分，需要首先传送到AX 寄存器；紧接着，修改它的RPL 字段，使该选择子的请求特权级为3。

### 创建0、1 和2 特权级的栈

任务在运行时，需要调用内核或者操作系统的例程。这可以认为是从同一个任务的局部地址空间转移到全局地址空间工作。而且，在这个过程中涉及特权级的变化，需要通过调用门。

通过调用门的控制转移通常会改变当前特权级CPL，同时还要切换到与目标代码段特权级相同的栈。为此，必须为每个任务定义额外的栈。对于当前的3 特权级任务来说，应当创建特权级0、1 和2 的栈。而且，应当将它们定义在每个任务自己的LDT 中。

这些额外的栈是动态创建的，而且需要登记在任务状态段（TSS）中，以便处理器固件能够自动访问到它们。但是，现在的问题是还没有创建TSS，有必要先将这些栈信息登记在任务控制块（TCB）中暂时保存。

第622 行，从栈中取得当前任务的TCB 基地址，它是作为过程参数压在当前栈中的。

第625～628 行，申请创建0 特权级栈所需的4KB 内存，并在TCB 中登记该栈的尺寸。登记到TCB 中的尺寸值要求是以4KB 为单位的，所以，还要逻辑右移12 次，相当于除以4096，得到一个4KB 的倍数。

第629、630 行，先申请内存，然后用申请到的内存基地址加上栈的尺寸，得到栈的高端地址，并将此地址登记到TCB 中。一般来说，栈应当使用高端地址作为其线性基地址。

第631、634 行，用给定的段界限和段属性调用公共例程段内的过程make_seg_descriptor 创建描述符。段属性表明这是一个栈段，4KB 粒度。我们创建的是0 特权级栈，故要求描述符的DPL 为0。

第635、636 行，调用内核代码段内的近过程fill_descriptor_in_ldt 将刚创建的描述符安装到LDT 中。该过程要求使用EBX 作为参数提供TCB 的线性基地址，故在调用该过程前先将该地址传送到EBX 寄存器。

第637～639 行，将安装描述符后返回的段选择子登记在TCB 中。相应地，应当将该选择子的请求特权级RPL 设置为0。注意，过程返回的选择子本来就是RPL 为0 的，所以那条指令是作为注释存在的。同时登记的还有0 特权级栈指针的初始值。按老规矩，这个初始值应当为0。

第642～673 行是创建1、2 特权级的栈，并将它们的信息登记在TCB 中，并使用了和上面相同的方法，要注意，为它们分配的特权级别是各不相同的。

### 安装LDT 描述符到GDT 中

尽管局部描述符表（LDT）和全局描述符表（GDT）都用来存放各种描述符，比如段描述符，但这掩盖不了它们也是内存段的事实。简单地说，它们也是段。但是，因为它们用于系统管理，故称为系统的段或系统段。

全局描述符表（GDT）是唯一的，整个系统中只有一个，所以只需要用GDTR 寄存器存放其线性基地址和段界限即可；但LDT 不同，每个任务一个，所以，为了追踪它们，处理器要求在GDT 中安装每个LDT 的描述符。当要使用这些LDT 时，可以用它们的选择子来访问GDT，将LDT 描述符加载到LDTR 寄存器。在一些人看来，这个理由很牵强，这么做也很别扭。但是，如果不这样，处理器将没有机会来做存储器和特权级的保护工作。

第676～679 行，调用公共例程段的过程make_seg_descriptor 创建LDT 描述符。作为传入的参数，EAX 寄存器的内容是从TCB 中取出的LDT 基地址，EBX 寄存器的内容是从TCB 中取出的LDT 长度，ECX 寄存器的内容是描述符的属性，各属性位与它们在描述符高32 位中相同，无关的位要清零。如图14-16 所示，这是LDT 描述符的格式。

LDT 本身也是一种特殊的段，最大尺寸是64KB。段基地址指示LDT 在内存中的起始地址，段界限指示LDT 的范围；描述符的G 位是粒度位，适用于LDT 描述符，以表示LDT 的界限值是以字节为单位，还是以4KB 为单位。即使是以4KB 为单位，它也不能超过64KB 的大小。

D 位（或者叫B 位）和L 位对LDT 描述符来说没有意义，固定为0。

AVL 和P 位的含义和存储器的段描述符相同。

LDT 描述符中的S 位固定为0，表示系统的段描述符或者门描述符，以相对于存储器的段描述符（S＝1），因为LDT 描述符属于系统的段描述符。

![截图 2023-05-22 23-11-04](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-22 23-11-04.png)

在描述符为系统的段描述符时，即，在S＝0 的前提下，TYPE 字段为0010（二进制）表明这是一个LDT 描述符。

因此，传送到ECX 寄存器的属性值0x00408200 表示这是一个LDT 描述符，描述符特权级DPL 为0，其他无关的位都已清零。

过程返回后， 创建的描述符在EDX:EAX 中。第680 、681 行， 立即调用过程set_up_gdt_descriptor 安装此描述符到全局描述符表GDT 中。然后，将返回的描述符选择子写入任务控制块TCB 中的相应位置。

### 任务状态段TSS 的格式

到目前为止，任务的所有内存段都已创建完毕，除了任务状态段（TSS）。现在就来创建TSS。在此之前，先来全面了解一下TSS 的各个组成部分。

![截图 2023-05-18 22-21-39](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-18 22-21-39.png)

如图14-2 所示，TSS 内偏移0 处是前一个任务的TSS 描述符选择子。和LDT 一样，必须在全局描述符表（GDT）中创建每个TSS 的描述符。当系统中有多个任务同时存在时，可以从一个任务切换到另一个任务执行，此时称任务是嵌套的。被嵌套的任务用这个指针指向前一个任务，即嵌套它的那个任务，当控制返回前一个任务时，处理器需要这个指针来识别前一个任务。创建TSS 时，可以为0。

SS0、SS1 和SS2 分别是0、1 和2 特权级的栈段选择子，ESP0、ESP1 和ESP2 分别是0、1和2 特权级栈的栈顶指针。这些内容应当由任务的创建者填写，且属于填写后一般不变的静态部分，当通过门进行特权级之间的控制转移时，处理器用这些信息来切换栈。

CR3 和分页有关，有关分页的知识将在第16 章讲述。此处一般由任务的创建者填写，如果没有使用分页，可以为0。

偏移为32～92 的区域是处理器各个寄存器的快照部分，用于在进行任务切换时，保存处理器的状态以便将来恢复现场。在一个多任务环境中，每次创建一个任务时，操作系统或者内核至少要填写EIP、EFLAGS、ESP、CS、SS、DS、ES、FS 和GS，当该任务第一次获得执行时，处理器从这里加载初始执行环境，并从CS:EIP 处开始执行任务的第一条指令。在此之后的任务运行期间，该区域的内容由处理器固件进行更改。 在本章中，只有一个任务，而且自进入保护模式时就开始运行了，只不过一开始是在0 特权级的全局空间执行。所以，这部分内容不需要填写。

LDT 段选择子是当前任务的LDT 描述符选择子。由内核或者操作系统填写，以指向当前任务的LDT。该信息由处理器在任务切换时使用，在任务运行期间保持不变。

T 位用于软件调试。在多任务的环境中，如果T 位是“1”，每次切换到该任务时，将引发一个调试异常中断。这是有益的，调试程序可以接管该中断以显示任务的状态，并执行一些调试操作。现在只需要将这一位清零即可。

I/O 映射基地址用于决定当前任务是否可以访问特定的硬件端口，对它的解释说来话长。

是这样的，我们知道，特权指令是只有0 特权级的程序才可以执行的指令，执行这些指令会影响整个机器的状态。

现有的特权指令也许是处理器的设计者精心挑选的，因为即使较低特权级的程序不使用它们，这些程序也能运行得很好，简直是非常好。不过，另外一些候选的指令就没那么幸运了，尽管它们也适合作为特权指令，但其他特权级的程序同样需要它们。

一个典型的例子是硬件端口的输入输出指令in 和out，它们应该对特权级别为1 的程序开放，因为设备驱动程序就工作在这个特权级别。不过，这样做依然是不合理的，因为即使是特权级为3的程序，在需要快速反应的场合，也需要直接访问某些硬件端口。所以，如果需要，它们也可以向2、3 特权级的程序开放。

处理器可以访问65536 个硬件端口。如果只对应用程序开放那些它们需要的端口，而禁止它们访问另一些敏感的端口，操作系统肯定会对此持欢迎态度，因为这有利于设备的统一管理，同时也很安全。

每个任务都有EFLAGS 寄存器的副本，其内容在任务创建的时候由内核或者操作系统初始化，在多任务系统中，每次当任务恢复运行时，就由处理器固件自动从TSS 中恢复。

EFLAGS 寄存器的IOPL 位决定了当前任务的I/O 特权级别。如果当前特权级CPL 高于，或者和任务的I/O 特权级IOPL 相同时，即，在数值上，

```assembly
CPL <= IOPL
```

时，所有I/O 操作都是允许的，针对任何硬件端口的访问都可以通过。

相反，如果当前特权级CPL 低于任务的I/O 特权级IOPL，也并不意味着所有的硬件端口都对当前任务关上了大门。事实上，处理器的意思是总体上不允许，但个别端口除外。至于个别端口是哪些端口，要找到当前任务的TSS，并检索I/O 许可位串。

如图14-17 所示，I/O 许可位串（I/O Permission Bit String）是一个比特序列，或者说是一个比特串，最多允许65536 比特，即8KB。从第1 比特开始，各比特用它在串中的位置代表一个端口号。因此，第1 个比特代表0 号端口，第2 个比特代表1 号端口，第3 个比特代表2 号端口，……，第65536 比特代表第65535 号端口。

![截图 2023-05-23 20-23-31](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 20-23-31.png)

每个比特的取值决定了相应的端口是否允许访问。为1 时，禁止访问；为0 时，允许访问。

处理器检查I/O 许可位的方法是先计算它在I/O 许可位映射区的字节编号，并读取该字节，然后进行测试。比如，当执行指令

```assembly
out 0x09, a1
```

时，处理器通过计算就可以知道，该端口对应着I/O 许可位映射区第2 个字节的第2 个比特（位1）。于是，它读取该字节，并测试那一位。

同其他和任务相关的信息一样，I/O 许可位串位于任务的TSS 中。如图14-18 所示，任务状态段TSS 的最小长度是104 字节，保存着最基本的任务信息，但这并不是它的最大长度。

事实上，整个TSS 还可以包括一个I/O 许可位串，它所占用的区域称为I/O 许可位映射区。如图14-18 所示，在TSS 内偏移为102 的那个字单元，保存着I/O 许可位串（I/O 许可位映射区）的起始位置，从TSS 的起始处（0）算起。因此，如果该字单元的内容大于或者等于TSS 的段界限（在TSS 描述符中），则表明没有I/O 许可位串。在这种情况下，如果当前特权级CPL 低于当前的I/O 特权级IOPL，执行任何硬件I/O 指令都会引发处理器异常中断。说明一下，和LDT 一样，必须在GDT 中创建TSS 的描述符，TSS 描述符中包括了TSS 的基地址和界限，该界限值包括I/O 许可位映射区在内。

![截图 2023-05-23 20-24-36](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 20-24-36.png)

非常重要的一点是，I/O 端口是按字节编址的。这句话的意思是，每个端口仅被设计用来读写一个字节的数据，当以字或者双字访问时，实际上是访问连续的2 个或者4 个端口。比如，当从端口n 读取一个字时，相当于同时从端口n 和端口n＋1 各读取一个字节。即，

```assembly
in ax, 0x3f8
```

相当于同时执行

```assembly
in al, 0x3f8
in ah, 0x3f9		;仅为实例，x86处理器不允许使用AH寄存器
```

由于这个原因，当处理器执行一个字或者双字I/O 指令时，会检查许可位串中的2 个，或者4个连续位，而且要求它们必须都是“0”，否则引发异常中断。麻烦在于，这些连续的位可能是跨字节的。即，一些位于前一字节，另一些位于后一字节。为此，处理器每次都要从I/O 许可位映射区读两个连续的字节。

这种操作方式直接导致了另一个问题。即，如果要检查的比特在最后一字节中，那么，这个两字节的读操作将会越界。为防止这种情况，处理器要求I/O 许可位映射区的最后必须附加一个额外的字节，并要求它的所有比特都是“1”，即0xFF。当然，它必须位于TSS 的界限之内。

处理器不要求为每一个I/O 端口都提供位映射。对于那些没有在该区域内映射的位，处理器假定它对应的比特是“1”。例如，要是I/O 许可位映射区的长度是11 字节，那么，除去最后一个所有比特都是“1”的字节，前10 字节映射了80 个端口，分别是端口0 到端口79，访问更高地址的端口将引发异常中断。

显然，EFLAGS 寄存器中的IOPL 位对于控制任务的I/O 特权来说是很重要的。通常，IOPL位由内核或者操作系统根据任务的实际需要进行初始化。尽管不存在对EFLAGS 寄存器整体写入或者读出的指令，但存在将标志寄存器入栈和出栈的指令：

```assembly
pushf/pushfd
popf/popfd
```

pushf 并不是一条新指令。事实上，早在8086 处理器的时代就已经有了，用于将16 位的标志寄存器FLAGS 压栈，机器指令码为9C。在8086 处理器上执行时，SP 寄存器的内容减去2，然后将FLAGS 的内容保存到栈段，操作数的大小是1 个字。同样地，popf 指令把当前栈中的栈顶内容弹出到FLAGS 寄存器。

到了32 位处理器时代，pushf 指令既可以工作在16 位模式下，也可以工作在32 位模式下。在16 位模式下，pushf 压入的是EFLAGS 的低16 位。如果要压入整个32 位的EFLAGS，需要指令前缀66，即

```assembly
66 9C
```

在32 位模式下，pushf 压入的是整个32 位的EFLAGS，即使有指令前缀，也不会只压入低16位，多总比少好，只压入低16 位没有太大意义，徒增处理器的负担。

为了区分EFLAGS 寄存器在16 位模式下的两种压栈方式，编译器引入了符号pushfd。本质上，它们对应着同一条指令，当你使用pushf 时，编译器就知道，应当编译成无前缀的机器码9C；当使用pushfd 时，编译器会编译成66 9C。下面的例子很好地展示了它们之间的区别：

```assembly
[bits 16]
pushf		;编译后是9c，16位操作
pushfd		;编译后是66 9c，32位操作

[bits 32]
pushf		;编译后是9c，32位操作
pushfd		;编译后是9c，32位操作
```

可见，在32 位模式下，pushf 和pushfd 是相同的。上面的讨论同样适用于popf 和popfd 指令。

通过将EFLAGS 寄存器的内容压入栈，局部修改后，再弹出到EFLAGS，可以间接地改变它的各种标志位。对多数标志位的修改不会威胁到整个系统的安全，比如，你修改了ZF 标志，这有什么用呢？唯一的后果可能是搬石头砸自己程序的脚。

但是，如果修改了IOPL 位和IF 位，就不同了。能够修改这两个标志的指令是

```assembly
popf iret cli sti
```

注意，没有包括pushf 指令，原因来自一个阴险的想法：你可以执行pushf 指令，但我不允许你执行popf 和iret 指令，你就生气吧！另外，中断是由操作系统或者内核统一管理的，cli 和sti指令不能由低特权级的程序随便执行。遗憾的是，这些指令并不是特权指令，原因很简单，其他特权级的程序也离不开它们。

最好的办法是用IOPL 本身来控制它们。如果当前特权级CPL 高于，或者和当前I/O 特权级IOPL 相同，即，在数值上

```assembly
CPL <= IOPL
```

则允许执行以上4 条指令，也允许访问所有的硬件端口。否则，如果当前特权级CPL 低于当前的I/O 特权级IOPL，则执行popf 和iret 指令时，会引发处理器异常中断；执行cli 和sti 时，不会引发异常中断，但不改变标志寄存器的IF 位。同时，是否能访问特定的I/O 端口，要参考TSS中的I/O 许可位映射串。

### 创建任务状态段TSS

回到代码清单14-1，我们来创建任务状态段TSS。

第684～688 行，申请104 字节的内存用于创建TSS。很显然，我们是要创建一个标准大小的TSS。照例，要把TSS 的基地址和界限登记到任务控制块（TCB）中，将来创建TSS 描述符时用得着。TSS 的界限值是16 位的，是它的大小（总字节数）减1，这就是第686 行的目的。

注意，界限值必须至少是103，任何小于该值的TSS，在执行任务切换时，都会引发处理器异常中断。

第691 行，将指向前一个任务的指针（任务链接域）填写为0，表明这是唯一的任务。

第693～709 行，登记0、1 和2 特权级栈的段选择子，以及它们的初始栈指针。所有的栈信息都在TCB 中，先从TCB 中取出，然后填写到TSS 中的相应位置。

第711、712 行，登记当前任务的LDT 描述符选择子。在任务切换时，处理器需要用这里的信息找到当前任务的LDT。LDT 对任务来说并不是必需的，如果高兴，也可以把属于某个任务的段定义在GDT 中。如果没有LDT，这里应该填写0。

第714、715 行，填写I/O 许可位映射区的地址。在这里，填写的是TSS 段界限（103），这意味着不存在该区域。

### 安装TSS 描述符到GDT 中

和局部描述符表（LDT）一样，也必须在GDT 中安装TSS 的描述符。这样做，一方面是为了对TSS 进行段和特权级的检查；另一方面，也是执行任务切换的需要。当call far 和jmp far 指令的操作数是TSS 描述符选择子时，处理器执行任务切换操作。

如图14-19 所示，这是TSS 描述符的格式，和LDT 描述符差不多，除了TYPE 位。

TSS 描述符中的B 位是“忙”位（Busy）。在任务刚刚创建的时候，它应该为二进制的1001，即，B 位是0，表明任务不忙。当任务开始执行时，或者处于挂起状态（临时被中断执行）时，由处理器固件把B 位置1。

任务是不可重入的。就是说，在多任务环境中，如果一个任务是当前任务，它可以切换到其他任务，但不能从自己切换到自己。在TSS 描述符中设置B 位，并由处理器固件进行管理，可以防止这种情况的发生。.

![截图 2023-05-23 20-27-42](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 20-27-42.png)

第720～725 行，先调用公共例程段内的过程make_seg_descriptor 创建TSS 描述符，它需要传入三个参数。先从TCB 中取出TSS 的基地址，传送到EAX 寄存器；EBX 寄存器的内容是TSS 的界限；ECX 寄存器的内容是描述符属性值，0x00408900 表明这是一个DPL 为0 的TSS 描述符，字节粒度。接着，调用公共例程段内的另一个过程set_up_gdt_descriptor 安装此描述符到GDT中，并将返回的描述符选择子登记在TCB 中。TSS 描述符选择子的RPL 字段为0。

### 带参数的过程返回指令

至此，任务创建完毕，可以从过程load_relocate_program 返回了。

在过程返回之前，即，在执行ret 指令之前，需要恢复现场，也就是按相反的顺序将刚进入过程时压入栈的内容出栈。这是第727～730 行的工作。

如图14-20 所示，当执行ret 指令时，栈恢复到刚进入过程时的状态，即，只有返回地址和调用者传递给过程的参数。因为当初是采用32 位相对近调用进入过程load_relocate_program 的，故仅将EIP 压栈，没有压入段寄存器CS 的内容。

![截图 2023-05-23 20-28-07](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 20-28-07.png)

再来看，一旦ret 指令执行完毕，控制将返回到调用者，且栈中只剩下两个参数。按道理，这两个参数是由调用者压入的，应该再由调用者弹出即可：

```assembly
push dword 50					;用户程序位于逻辑50扇区
push ecx						;压入人物控制块起始线性地址
call load_relocate_program		;调用过程
```

```assembly
add esp, 8						;过程返回后，调整栈指针使之越过参数
```

不过，最好的解决办法是在过程返回时，顺便弹出参数。这样做是可行的，过程的编写者最清楚栈中有几个参数。如果希望过程在返回时弹出参数，使ESP 寄存器指向调用过程前的栈位置（使栈平衡），可以使用带操作数的过程返回指令：

```assembly
ret imm16
retf imm16
```

这两条指令都允许16 位的立即数作为操作数，不同之处仅仅在于，前者是近返回，后者是远返回。立即数是16 位的，而且一般总是偶数，原因是栈操作总是以字或者双字进行，它指示在将控制返回到调用者之前，应当从栈中弹出多少字节的数据。

因此，第732 行，当该指令执行时，除了将控制返回到过程的调用者之外，还要调整栈的指针，即

```assembly
ESP <- ESP+8
```

之所以指令的操作数是8，是因为要弹出2 个双字。

这条指令给高级语言带来的好处是增加了它们的复杂性。比如这样一个C 语言函数：

```c
void func(int i, char *c) {
/*函数体*/
}
```

因为一般是通过栈传递参数，所以，哪个参数先入栈，哪个后入栈，栈平衡的事情由调用者来做，还是由过程来做，就需要一个标准，即所谓的调用转换规则。特别是在开发一些大软件时，需要用不同的高级语言来开发各个独立的、但能够协同工作的模块，尤其需要注意这个问题。

一个典型的调用转换标准是stdcall，它规定，参数从右往左进栈，且由过程在返回前出栈。

## 用户程序的执行

### 通过调用门转移控制的完整过程

现在我们转到代码清单14-1 的第845、846 行，在调用过程load_relocate_program 创建任务之后，显示一条成功的消息。

接下来的工作是将控制转到用户程序那里。我们创建的是一个3 特权级的任务，所以这是一个从0 特权级到3 特权级的控制转移。或者，换一种更体面的说法，是从任务自己的0 特权级全局空间转移到3 特权级局部空间执行。通常情况下，这既不允许，也不太可能。

办法总还是有的，只不过稍微有一点曲折，那就是假装从调用门返回。先来看看完整的调用门控制转移和返回过程是怎样的。

首先，通过调用门实施控制转移，可以使用jmp far 和call far 指令。指令执行时，描述符选择子必须指向调用门，32 位偏移量被忽略。但，无论采用哪种控制转移指令，都会使用表14-1 的特权检查规则。注意，表中的比较关系都是数值上的。

![截图 2023-05-23 21-35-17](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 21-35-17.png)

从表15-1 中可以看出，当使用jmp far 指令通过调用门转移控制时，要求当前特权级和目标代码段的特权级相同。原因是用jmp far 指令通过调用门转移控制时，不改变当前特权级CPL。

相反，使用call far 指令可以通过调用门将控制转移到较高特权级别的代码段。之所以说“可以”，是因为，如果目标代码段是依从的，则和jmp far 指令一样，不改变当前特权级别；否则，如果目标代码段是非依从的，则在目标代码段的特权级别上执行。

其次，当使用call far 指令通过调用门转移控制时，如果改变了当前的特权级别，则必须切换栈。即，从当前任务的固有栈切换到与目标代码段特权级相同的栈上。栈的切换是由处理器固件自动进行的。

当前栈是由段寄存器SS 和栈指针寄存器ESP 的当前内容指示的；要切换到的新栈位于当前任务的TSS 中，处理器知道如何找到它。在栈切换前，处理器要检查新栈是否有足够的空间完成本次控制转移。栈切换过程如下：

① 使用目标代码段的DPL（也就是新的CPL）到当前任务的TSS 中选择一个栈，包括栈段选择子和栈指针。

② 从TSS 中读取所选择的段选择子和栈指针，并用该选择子读取栈段描述符。在此期间，任何违反段界限检查的行为都将引发处理器异常中断（无效TSS）。

③ 检查栈段描述符的特权级和类型，并可能引发处理器异常中断（无效TSS）。

④ 临时保存当前栈段寄存器SS 和栈指针ESP 的内容。

⑤ 把新的栈段选择子和栈指针代入SS 和ESP 寄存器，切换到新栈。

⑥ 将刚才临时保存的SS 和ESP 的内容压入当前栈，如图14-21 所示。

![截图 2023-05-23 21-35-53](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 21-35-53.png)

⑦ 依据调用门描述符“参数个数”字段的指示，从旧栈中将所有参数都复制到新栈中。如果参数个数为0，不复制参数，如图14-21 所示。

⑧ 将当前段寄存器CS 和指令指针寄存器EIP 的内容压入新栈，如图14-21 所示。通过调用门实施的控制转移一定是远转移，所以要压入CS 和EIP。

⑨ 从调用门描述符中依次将目标代码段选择子和段内偏移传送到CS 和EIP 寄存器，开始执行被调用过程。

相反，如果没有改变特权级别，则不切换栈，继续使用调用者的当前栈，只在原来的基础上压入当前段寄存器CS 和指令指针寄存器EIP 的内容，如图14-22 所示。

再次，如果通过调用门的控制转移是使用jmp far 指令发起的，结果就是肉包子打狗，有去无回。而且，没有特权级的变化，也不需要切换栈。相反，如果通过调用门的控制转移是使用call far指令发起的，那么，可以使用远返回指令retf 把控制返回到调用者。

从同一特权级返回时，处理器将从栈中弹出调用者的代码段选择子和指令指针。尽管它们通常是有效的，但是，为了安全起见，处理器依然会进行特权级检查。

![截图 2023-05-23 21-36-19](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 21-36-19.png)

要求特权级变化的远返回，只能返回到较低的特权级别上。控制返回的全部过程如下：

① 检查栈中保存的CS 寄存器的内容，根据其RPL 字段决定返回时是否需要改变特权级别。

② 从当前栈中读取CS 和EIP 寄存器的内容，并针对代码段描述符和代码段选择子的RPL 字段实施特权级检查。

③ 如果远返回指令是带参数的，则将参数和ESP 寄存器的当前值相加，以跳过栈中的参数部分。最后的结果是ESP 寄存器指向调用者SS 和ESP 的压栈值。注意，retf 指令的字节计数值必须等于调用门中的参数个数乘以参数长度。

④ 如果返回时需要改变特权级，从栈中将SS 和ESP 的压栈值代入段寄存器SS 和指令指针寄存器ESP，切换到调用者的栈。在此期间，一旦检测到有任何界限违例的情况都将引发处理器异常中断。

⑤ 如果远返回指令是带参数的，则将参数和ESP 寄存器的当前值相加，以跳过调用者栈中的参数部分。最后的结果是调用者的栈恢复到平衡位置。

⑥ 如果返回时需要改变特权级，检查DS、ES、FS 和GS 寄存器的内容，根据它们找到相应的段描述符。要是有任何一个段描述符的DPL 高于调用者的特权级（返回后的新CPL），即，在数值上，那么，处理器将把数值0 传送到该段寄存器。

```assembly
段描述符DPL < 返回后的新的CPL
```

那么，这是为什么呢？

特权级检查不是在实际访问内存时进行的，而是在将选择子代入段寄存器时进行的。下面这两条指令可以非常清楚地说明这一点：

```assembly
mov ds, ax			;进行特权级检查
mov edx, [0x2000]	;不进行特权级检查
```

要想访问内存中的数据，必须先指定一个段。即，将选择子代入某个段寄存器。正是因为如此，处理器只在将选择子代入段寄存器时进行一次特权级检查，而在此之后的普通内存访问时，不进行特权级检查。处理器的意思是，只要你能进入大门，就证明你的确是这里的主人，随后你干什么它都不会干涉。

现在做一个假设，假设一个3 特权级的应用程序通过调用门请求0 特权级的操作系统服务。在进入操作系统例程后，当前特权级CPL 变成0。在该例程内，操作系统可能会访问自己的0 特权级数据段以进行某些内部操作。当然，它也必须先执行将选择子代入段寄存器的操作：

```assembly
mov ds, ax			;操作系统自己的选择子
```

按道理，安全的做法是先将旧的DS 值压栈，用完后再出栈。像这样：

```assembly
push ds
mov ds, ax
...
pop ds
retf
```

但是，如果操作系统例程没有这么做，一定有它的道理，而处理器也无权干涉。唯一可以预料的是，当控制返回到应用程序时，段寄存器DS 依然指向操作系统数据段。因此，应用程序就可以直接在3 特权级下访问操作系统的数据段：

```assembly
mov edx, [0x000c]
```

这是因为，特权级检查只在引用一个段的时候进行。即，只在将选择子传送到段寄存器的时候进行。只要通过了这一关，后面那些使用这个段寄存器的内存访问就都是合法的。

为了解决这个问题，在执行retf 指令时，要检查数据段寄存器，根据它们找到相应的段描述符。要是有任何一个段描述符的DPL 高于调用者的特权级（返回后的新CPL），那么，处理器将把数值0 传送到该段寄存器。使用这样的段寄存器访问内存，会引发处理器异常中断。

特别需要注意的是，任务状态段（TSS）中的SS0、ESP0、SS1、ESP1、SS2、ESP2 域是静态的，除非软件进行修改，否则处理器从来不会改变它们。举个例子，当处理器通过调用门进入0特权级的代码段时，会切换到0 特权级栈。返回时，并不把0 特权级栈指针的内容更新到TSS 中的ESP0 域。下次再次通过调用门进入0 特权级代码段时，使用的依然是ESP0 的静态值，从来不会改变。这就是说，如果你希望通过0 特权级栈返回数据，就必须自己来做这件事，比如，在返回到低特权级别的代码段之前，手工改写TSS 中的ESP0 域。

### 进入3 特权级的用户程序的执行

接着回到代码清单14-1 中。

任务寄存器TR 总是指向当前任务的任务状态段（TSS），而LDTR 寄存器也总是指向当前任务的LDT。TSS 是任务的主要标志，因此要使TR 寄存器指向任务；而使用LDTR 的原因是可以在任务执行期间加速段的访问。

在多任务环境中，随着任务的切换，每当一个任务开始运行时（成为前台活动任务），TR 和LDT 寄存器的内容都会更新，以指向新的当前任务。

现在的问题是，我们只有一个任务，而且是个3 特权级的任务，不能用任务切换的方法使它开始运行。这个问题可以表述为：如何从任务的0 特权级全局空间转移到它自己的3 特权级空间正常执行？

答案是先确立身份，即，使TR 和LDTR 寄存器指向这个任务，然后假装从调用门返回。和当前任务有关的信息都在它的任务控制块（TCB）中。因此，第832、833 行，先令段寄存器DS指向4GB 的内存段。

第851、852 行，加载任务寄存器TR 和局部描述符表寄存器（LDTR）。

如图14-23 所示，TR 和LDTR 寄存器都包括16 位的选择器部分，以及的描述符高速缓存器部分。选择器部分的内容是TR 和LDT 描述符的选择子；描述符高速缓存器部分的内容则指向当前任务的TSS 和LDT，以加速这两个段（表）的访问。

![截图 2023-05-23 21-44-40](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 21-44-40.png)

加载任务寄存器TR 需要使用ltr 指令。这条指令的格式为

```assembly
ltr r/m16
```

这条指令的操作数可以是16 位通用寄存器，也可以是指向一个16 位单元的内存地址。但不管是寄存器还是内存单元，其内容都是16 位的TSS 选择子。

在将TSS 选择子加载到TR 寄存器之后，处理器用该选择子访问GDT 中对应的TSS 描述符，将段界限和段基地址加载到任务寄存器TR 的描述符高速缓存器部分。同时，处理器将该TSS 描述符中的B 位置“1”，也就是标志为“忙”，但并不执行任务切换。

该指令不影响EFLAGS 寄存器的任何标志位，但属于只能在0 特权级下执行的特权指令。

加载局部描述符表寄存器（LDTR）使用的是lldt 指令，其格式和ltr 是一样的：

```assembly
lldt r/m16
```

其操作数也和ltr 指令一样，但是，指向的是16 位LDT 选择子。ltr 和lldt 指令执行时，处理器首先要检查描述符的有效性，包括审查它是不是TSS 或者LDT 描述符。在将LDT 选择子加载到LDTR 寄存器之后，处理器用该选择子访问GDT 中对应的LDT 描述符，将段界限和段基地址加载到LDTR 的描述符高速缓存器部分。CS、SS、DS、ES、FS 和GS 寄存器的当前内容不受该指令的影响，包括TSS 中的LDT 选择子字段。

如果执行这条指令时，代入LTR 选择器的选择子，其高14 位是全零，LDTR 寄存器的内容被标记为无效，而该指令的执行也将不声不响地结束（即不会引发异常中断）。当然，后续那些引用LDT 的指令都将引发处理器异常中断（对描述符进行校验的指令除外），例如，将一个指向LDT的段选择子代入段寄存器。

最后，如图14-24 所示，这是一个任务的全景图，给出了与一个任务相关的各个组成部分。

![截图 2023-05-23 21-45-28](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 21-45-28.png)

注意了，现在，局部描述符表（LDT）已经生效，可以通过它访问用户程序的私有内存段了。

第854、855 行，访问任务的TCB，从中取出用户程序头部段选择子，并传送到段寄存器DS。该选择子RPL 字段的值为3，即，请求特权级为3；TI 位是“1”，指向任务自己的LDT。这两条指令执行后，段寄存器DS 就指向用户程序头部段。

第858～862 行，从用户程序头部内取出栈段选择子和栈指针，以及代码段选择子和入口点，并将它们顺序压入当前的0 特权级栈中。这部分内容要结合第13 章的用户程序头部来分析（代码清单13-3）。

第864 行，执行一个远返回指令retf，假装从调用门返回。于是控制转移到用户程序的3 特权级代码开始执行。注意，这里所用的0 特权级栈并非是来自于TSS。不过，处理器不会在意这个。下次，从3 特权级的段再次来到0 特权级执行时，就会用到TSS 中的0 特权级栈了。

现在回到上一章，看代码清单13-3。

用户程序现在是工作在它的局部空间里。它可以通过调用门请求系统服务来显示字符串，或者读取硬盘数据，这都没有问题。这些指令可以再次加深我们对调用门的理解，请读者自行分析。

唯一的问题是，当它最后用jmp far 指令将控制权返回到内核时，可能行不通了。这条指令是

```assembly
jmp far [fs:TerminateProgram]			;将控制权返回到系统
```

这确实是一个调用门。而且，通过jmp far 指令使用调用门也没有任何问题。问题在于，当控制转移到内核时，当前特权级没有变化，还是3，因为使用jmp far 指令通过调用门转移控制是不会改变当前特权级别的。

再回到本章，看代码清单14-1。

返回点是在第866 行。因为当前特权级是3，以这样低的特权级别来执行第867、868 行的指令，一定会引发处理器异常中断:

```assembly
mov eax, core_data_seg_sel
mov ds, eax
```

在这里，当前特权级CPL 为3，选择子core_data_seg_sel 的请求特权级RPL 为0，目标代码段的特权级DPL 为0，因为当前特权级CPL 低于目标代码段的DPL，就算请求特权级RPL 和目标代码段的DPL 相同，也不可能通过特权级检查。

异常和异常中断的处理将在第17 章讲述，我们现在还没有任何接管和处理异常中断的机制，所以，这个异常可能不会明显地被你观察到。

还需要特别提醒的是，进入3 特权级的用户程序局部空间时，任务的I/O 特权级IOPL 是0，任务没有I/O 操作的特权。

最后，将本章的源代码编译，并从第1 个逻辑扇区开始，将编译后的文件写入虚拟硬盘。如果你用的虚拟硬盘文件还是第13 章用过的那个，这就是唯一要做的工作；否则，还要写入第13章的主引导程序、用户程序和数据文件。具体方法参见上一章。最后，启动虚拟机，应该能观察到如图14-25 所示的画面。

![截图 2023-05-23 22-28-59](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 22-28-59.png)

### 检查调用者的请求特权级RPL

在本章的最后，我们回过头来聊一聊与请求特权级RPL 有关的问题。通过这个话题的深入，你会更进一步了解处理器引入RPL 的原因和意义。

为了访问一个段，首先需要将段选择子代入段寄存器，这也是处理器进行特权级检查的大好机会：

```assembly
mov fs, cx
```

在绝大多数情况下，请求访问一个段的程序也是段选择子的提供者。就是说，当前特权级和请求特权级是相同的，即，RPL＝CPL。

一般来说，用户程序的特权级别很低，而且不能执行I/O 操作。假设操作系统提供了一个例程，可以从用户程序那里接受三个参数：逻辑扇区号、数据段选择子和段内偏移量，然后读硬盘，并把数据传送到用户程序的缓冲区内。为了使用户程序可以调用此例程，操作系统把它定义成调用门。

一般来说，用户程序会提供一个RPL 为3 的段选择子给操作系统例程。通过调用门实施控制转移后，当前特权级CPL 变成0，实际的请求者是用户程序，选择子的请求特权级RPL 为3，要访问的段属于用户程序，其描述符的DPL 为3，在数值上符合CPL≤DPL，并且RPL≤DPL 的条件，可以正常执行。

人类的可恶之处无孔不入，总爱钻空子。想象一下，用户程序的编写者通过钻研，知道了内核数据段的选择子，而且希望用这个选择子访问内核数据段。当然，他不可能在用户程序里访问内核数据段，因为那个数据段的DPL 为0，而用户程序工作时的当前特权级为3，处理器会很机警地把来访者拒之门外。

但是，他可以借助于刚才那个调用门。特别是，他提供的是一个RPL 为0 的选择子，而且该选择子指向操作系统的段描述符。此时，当前特权级CPL 为0，请求特权级RPL 为0，目标数据段描述符的DPL 为0，同样符合在数值上符合CPL≤DPL，并且RPL≤DPL 的条件，并且允许向内核数据段写入扇区数据，他得逞了！

我知道，有人会说，通过调用门进入内核例程时，用户程序的代码段选择子就作为返回地址压在栈中，代码段选择子的低2 位就是用户程序的特权级。因此，可以改造处理器固件，使它能够访问栈，用这个特权级来进行特权级检查。

但是，有这种认识的朋友们忘了，处理器的智商很低，它不可能知道谁是真正的请求者。你当然可以通过分析程序的行为来区分它们，但处理器不能。因此，当指令

```assembly
mov ds, ax
```

或者

```assembly
mov ds, cx
```

执行时，AX 或者CX 寄存器中的选择子可能是内核自己提供的，也可能来自于恶意的用户程序，是不是合法，这两种情况要区别对待，不能一棍子打死。所以，这已经超出了处理器的能力和职权范围。

怎么办？

还记得在本章的前面，在讨论RPL 时，我是怎么说的？我说的是，RPL 只是在原来的基础上多增加了一种检查机制，并把如何能够通过这种检查的自由裁量权交给软件（的编写者）。

引入请求特权级RPL 的原因是处理器在遇到一条将选择子传送到段寄存器的指令时，无法区分真正的请求者是谁。但是，引入RPL 本身并不能完全解决这个问题，这只是处理器和操作系统之间的一种协议，处理器负责检查请求特权级RPL，判断它是否有权访问，但前提是提供了正确的RPL；内核或者操作系统负责鉴别请求者的身份，并有义务保证RPL 的值和它的请求者身份相符，因为这是处理器无能为力的。

因此，在引入RPL 这件事上，处理器的潜台词是，仅依靠现有的CPL 和DPL，无法解决由请求者不同而带来的安全隐患。那么，好吧，再增加一道门卫，但前提是，操作系统只将通行证发放给正确的人。

为了帮助内核或者操作系统核查请求者的身份，并提供正确的RPL 值，处理器提供了arpl 指令。arpl 指令的作用是调整段选择子RPL 字段的值（Adjust RPL Field of Segment Selector），其格式为

```assembly
arpl r/m16, r16
```

该指令比较两个段选择子的RPL 字段，目的操作数可以是包含了16 位段选择子的通用寄存器，或者指向一个16 位单元的内存地址，该字单元里存放的是段选择子；源操作数只能是包含了段选择子的16 位通用寄存器。

该指令执行时，处理器检查目的操作数的RPL 字段，如果它在数值上小于源操作数的RPL 字段，则设置ZF 标志，并增加目的操作数RPL 字段的值，使之和源操作数RPL 字段的值相同。否则，ZF 标志清零，而且除此之外什么也不会发生。

arpl 是典型的操作系统指令，它通常用于调整应用程序传递给操作系统的段选择子，使其RPL 字段的值和应用程序的特权级相匹配。在这种情况下，传递给操作系统的段选择子是作为目的操作数出现的；而应用程序的段选择子是作为源操作数出现的（可以从栈中取得）。arpl 也可以在应用程序中使用。

这样，为了防止恶意的数据访问，操作系统应该从当前栈中取得用户程序的代码段选择子（调用者代码段寄存器CS 的内容）作为源操作数，并把作为参数传递进来的数据段选择子作为目的操作数，来执行arpl 指令，把数据段选择子的请求特权级RPL 调整（恢复）到调用者的特权级别上。

一旦调整了请求特权级，那么，当前特权级CPL 为0，请求特权级RPL 为3，数据段描述符特权级DPL 为0，数值上并不符合CPL≤DPL，并且RPL≤DPL 的条件，禁止访问，并引发处理器异常中断。

引入RPL 检查机制和arpl 指令，主要是防止对段的不安全访问，不管是恶意的，还是因为编程疏漏而引起的。不管怎么说，一旦引入了RPL 检查机制，它就会处处起作用，同时也就成了编写程序时不得不考虑和妥善处理的问题。

### 在Bochs 中调试程序的新方法

随着本书内容的深入，程序会越来越复杂，但一般不会出什么问题，因为我都调试好了。当然，你可能想在此基础上做一些改动，实现其他一些功能。在这种情况下，每一次运行时能得到预期结果的可能性微乎其微。不过不用担心，使用本书前面讲过的调试技术，你一定能够找到问题所在。比如，你可以使用“info gdt”指令察看GDT 中的段描述符和门描述符。

本章中涉及到两个新的系统寄存器LDTR 和TR，要察看它们的内容，可以使用以前讲过的Bochs 调试指令“sreg”；为了察看局部描述符表LDT 的所有内容，可以使用“info ldt”；要察看任务状态段TSS 的内容，可以使用“info tss”。注意，显示LDT 和TSS 的内容时，Bochs 要先从处理器的TR 和LDTR 寄存器获取基地址和界限信息。因此，显示的是当前任务的LDT 和TSS。如图14-26 所示，这里显示了在执行代码清单14-1 的第851 行“ltr [ecx+0x18]”之后，用“info tss”命令显示的TSS 状态。

![截图 2023-05-23 22-36-03](/home/cccmmf/操作系统/x86/chap14/截图 2023-05-23 22-36-03.png)































