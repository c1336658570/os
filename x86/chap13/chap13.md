# chap 13程序的动态加载和执行

所有的段在使用之前，都必须以描述符的形式在描述符表中进行定义，那么，像操作系统这样的软件，又怎么能够加载和执行其他各种用户程序呢？毕竟，你并不知道这些程序都定义了哪些段，每个段是什么类型，有多长。

软件分两个层次，一是操作系统，二是应用（用户）程序。通常，用户程序只关心问题的解，就是采用各种算法来解决实际问题。至于软件是怎么加载到内存的，怎么定位的，不是它所操心的事。但是，它有义务提供一些必要的信息，来帮助操作系统将自己加载到内存中。

相反，操作系统则必须考虑采用什么方法来加载用户程序，并在适当的时候将处理器的执行流转移到用户代码中去。同时，为了减轻用户程序的工作量，操作系统还应当管理硬件，并提供大量的例程供用户程序使用。比如，显示一个字符串，就不要让用户自己来写代码了，直接调用操作系统的代码即可。但操作系统和用户程序应当协商一种机制，让用户程序能够在使用这些例程时，不必考虑和关心它们的位置。

本章提供了一个小小的“操作系统”，因为当不起这么大的名称，所以叫“内核”或者“核心”。即使是这样，它依然当不起，因为它实在是太简单了。不过，也没有办法，就这么凑合着叫吧。

内核不能放到主引导扇区里，毕竟它都很大。所以，计算机首先从主引导程序开始执行，主引导程序负责加载内核，并转交控制权。然后，内核负责加载用户程序，并提供各种例程给用户程序调用。提供给用户程序调用的例程也叫应用程序接口（Application Programming Interface，API），本章用简单的方法来允许用户程序使用API 工作。

## 内核的结构、功能和加载

### 内核的结构

内核分为四个部分，分别是初始化代码、内核代码段、内核数据段和公共例程段，主引导程序也是初始化代码的组成部分。

初始化代码用于从BIOS 那里接管处理器和计算机硬件的控制权，安装最基本的段描述符，初始化最初的执行环境。然后，从硬盘上读取和加载内核的剩余部分，创建组成内核的各个内存段。

![Screenshot-1](/home/cccmmf/操作系统/x86/chap13/Screenshot-1.png)

内核数据段是在第330 行定义的，提供了一段可读写的内存空间。

公共例程段是在第34 行定义的，用于提供各种用途和功能的子过程以简化代码的编写。这些例程既可以用于内核，也供用户程序调用。

内核文件还包括一个头部，记录了各个段的汇编位置，这些统计数据用于告诉初始化代码如何加载内核。

回到代码清单13-2 的开头。

从第7 行开始，一直到第12 行，用于声明常数。这是一些内存段的选择子。我们知道，伪指令equ 仅仅是允许我们用符号代替具体的数值，但声明的数值并不占用空间。

内核文件的真正开始部分是头部，偏移量为0x00 的地方是一个双字，可以通过标号core_length 引用，记录了整个内核文件的大小，以字节为单位；偏移量为0x04 的地方是公用例程段的起始汇编地址；偏移量为0x08 的地方是核心数据段的起始汇编地址；偏移量为0x0C 的地方是核心代码段的起始汇编地址；从偏移量为0x10 开始的地方用于指示内核入口点，可以通过标号core_entry 引用，在主引导程序加载了内核之后，从这里把处理器的控制权交给内核代码。注意，不要忘了这个表达式，我们以前学过的，它用来得到段的起始汇编地址：

```assembly
section.<段名称>.start
```

<img src="/home/cccmmf/操作系统/x86/chap13/截图 2023-05-10 08-50-13.png" alt="截图 2023-05-10 08-50-13" style="zoom:80%;" />

入口点共有6 字节，低地址部分是一个双字，指示段内偏移，将来会传送到指令指针寄存器EIP，它来自一个标号start，位于第531 行；高地址部分是一个字，指定一个内存代码段的选择子。在这里，填充的是刚刚在第7 行声明过的常数core_code_seg_sel，在数值上等于0x38。

### 内核的加载

现在来看主引导程序。

第6 行和第7 行声明了两个常数，分别是内核程序在硬盘上的位置，以及它将要被加载的物理内存地址。

从第9 行开始，一直到第55 行，是为进入保护模式做准备。如图13-2 所示，因为主引导程序的加载位置是物理地址0x00007C00，所以，从这个位置往上是512 字节的初始化代码段，从这个位置往下是4KB 的内核栈。

全局描述符表（GDT）是不可或缺的，和从前一样，我们将它定义在从物理地址0x00007E00开始的地方，紧挨着初始化代码段。GDT 可大可小，最大能达到64KB，所以，它的空间一定要留够。

和GDT 一样，内核程序的大小也是不定的，但可以规定它的起始位置。在这里，我们决定将它加载到从物理内存地址0x00040000 开始的地方。从这个地方往上，一直到0x0009FFFF，都是它的地盘，取决于它到底有多大，想用多少就用多少。从0x000A0000 往上，是ROM BIOS，硬件专有的。

显示器是窥视程序工作的窗口，显示功能自然少不了。因此，从0x000B8000 往上的32KB，是文本模式的显示缓冲区。

最后，从1MB 开始的大量空间是留给用户程序用的，具体数量取决于你到底安装了多少物理内存。对于本章来说，程序都很小，功能都很简单，用不了多少内存空间，都才几KB、几十KB；但是，你平时所用的Windows、Linux 和MacOS，以及运行于其上的程序，都是VIP、大客户，动辄几MB、几百MB。

在进入保护模式之前，初始化程序（主引导程序）已经在全局描述符表（GDT）中安装了几个必要的描述符。如图13-3 所示，第一个是用于访问0~4GB 内存的数据段，它很重要，内核只有在具备了访问全部4GB 内存空间的能力时，才能随心所欲地做任何事情。

第二个是初始化代码段，也就是主引导程序所在的段。进入保护模式后，要继续执行主引导程序的后半部分代码，必须按处理器的要求，为它创建描述符。

最后两个分别是初始的栈段和显示缓冲区的描述符。这里定义的栈在初始化过程中就要使用，而在进入内核之后，它又是内核的栈。

![截图 2023-05-10 09-06-23](/home/cccmmf/操作系统/x86/chap13/截图 2023-05-10 09-06-23.png)

第59、60 行，使DS 指向全部4GB 的内存空间；第62～64 行，使SS 指向初始的栈空间，并初始化栈指针寄存器ESP 的内容为0。第一个数据压入时，因为栈的操作是先减ESP 的值，再保存数据，所以，如果是压入一个字，ESP 的内容为0xFFFFFFFE；如果压入的是双字，ESP 的内容为0xFFFFFFFC。

接下来是从硬盘把内核程序读入内存，第67～69 行，它在硬盘上的起始逻辑扇区号和物理内存地址已经由两个常数给出，现分别将它们传送到EAX 和EDI 寄存器。

初始化代码并不知道内核有多大，所以也就不知道应该读多少个扇区。不过，它可以先读一个扇区，因为那里包含着内核的头部数据，根据这些数据，就可以知道内核的总扇区数。

和以前一样， 我们把读硬盘扇区的指令归拢到一起， 做成可以反复调用的过程read_hard_disk_0，它位于第138～192 行。基本上，它的工作过程和具体的代码都和从前一样，但略有不同。首先，该过程要求使用EAX 寄存器来传入28 位的逻辑扇区号。我们现在已经可以使用32 位的寄存器了，再也不会因为16 位寄存器太小，无法容纳28 位的逻辑扇区号而发愁。

其次，这里使用EBX 寄存器来传入偏移地址。因为在32 位模式下，可以访问全部4GB 内存，允许使用32 位的偏移地址。这是好事，我们再也不需要为64KB 的段而受折磨了。

最后一个不同之处在于，每次过程返回时，会使EBX 寄存器的值比原来多512。这是有意的，因为在32 位模式下，内存的访问不再受64KB 限制，所以就能够连续访问。这里，每次将EBX 寄存器的内容加上512，目的是指向下一个内存块，我相信这种工作方式会给调用它的主程序带来方便。

接下来是取得内核的长度，并计算它所占用的扇区数。

因为段寄存器DS 是指向4GB 内存段的，其描述符高速缓存中的基地址是0x00000000，故，第75 行，可以直接用EDI 寄存器中的数值作为偏移量来访问内存，最终生成的线性地址在数值上和EDI 寄存器的内容相同。当前指令的功能是取得内核的总长度，因为它就位于内核的偏移0 处。

第75～77 行，将取得的总字节数除以512，就能在EAX 寄存器中得到内核所占用的扇区数。不过，在没能整除的情况下，实际的扇区总数要比EAX 寄存器中的值多一。

但是，我们要的是剩余扇区数，毕竟已经读了一个。为此，第79～81 行，先判断EDX 寄存器中的余数是否为零。取决于EDX 的实际内容，or 指令会影响ZF 标志位。如果EDX 不为零，则EAX 寄存器里实际上就是剩余的扇区数，因为它比实际的扇区数少一。相反，如果EDX 的内容为零，则EAX 中的内容就是总扇区数，还要用dec 指令减一才行。

无论是哪种情况，指令的执行流程都会到达第83 行。这个地方指令是

```assembly
or eax, eax
```

这条指令的工作是检查EAX 寄存器，看它的内容是否为零。第84 行，如果为零，说明内核就占用了一个扇区（确实够小的，但一般不太可能），于是不再读硬盘，直接转到标号setup 处执行。

第87～93 行，用于从硬盘读取剩余的扇区，用的是loop 指令循环读取，循环的次数在ECX寄存器中。再重复一遍，32 位模式下的循环指令需要使用ECX 寄存器，而不是CX。如果没有第83、84 行的条件判断，而且剩余扇区数为0，那么，这里的循环将执行0xFFFFFFFF＋1 次，显然不是我们希望的。

### 安装内核的段描述符

要使内核工作起来，首要的任务是为它的各个段创建描述符。换句话说，还要为GDT 续添新的描述符。进入保护模式前，我们在代码清单13-1 的第42 行使用指令

```assembly
lgdt [cs: pgdt+0x7c00]
```

来加载全局描述符表寄存器（GDTR），标号pgdt 所指向的内存位置包含了GDT 的基地址和大小。现在，我们的任务是重新从标号pgdt 处取得GDT 的基地址，为其添加描述符，并修改它的大小，然后用lgdt 指令重新加载一遍GDTR 寄存器，使修改生效。

但是，如果忽略了一件事，你可能不会得逞。标号pgdt 所指向的内存区域位于主引导程序内，而我们当前正在保护模式下执行主引导程序。保护模式下的代码段只是用来执行的，是否能读出，取决于其描述符的类别字段，但无论如何它都不能写入。

对代码段实施保护的意思是通过代码段描述符不能修改段中的内容，但不意味着通过其他描述符做不到。想想看，我们拥有一个指向全部4GB 内存空间的描述符，标号pgdt 所指向的内存位置不单单是在主引导程序内，同时也是4GB 内存空间的一部分。

如图13-4 所示，标号pgdt 在数值上等于它距离段首的偏移量，也就是编译阶段的汇编地址。主引导程序的物理起始地址是0x00007C00，故pgdt 在4GB 段内的偏移量是0x00007C00＋pgdt。

这样，为了得到GDT 的基地址，代码清单13-1 第96 行，使用了指令

```assembly
mov esi, [0x7c00+pgdt+0x02]
```

注意，指令中的表达式是在编译阶段计算的。默认的段寄存器是DS，当这条指令执行时，处理器用DS 描述符高速缓存器中的32 位线性基地址0x00000000 加上用该表达式计算出的偏移量来访问内存。

现在可以创建与内核相关的其他段描述符。首先是公共例程段。如图13-5 所示，内核头部偏移0x04 处的一个双字，就是公共例程段的起始汇编地址。由于内核被加载的物理地址是由EDI 寄存器指向的，所以，第99 行，直接访问4GB 内存段，从该偏移位置取出公共例程段的起始汇编地址。

![截图 2023-05-10 10-11-50](/home/cccmmf/操作系统/x86/chap13/截图 2023-05-10 10-11-50.png)

创建描述符还需要知道段界限。在内核中，各个段有着确定的先后次序，而且是紧挨着的。公共例程段的后面是内核数据段，用内核数据段的起始汇编地址，减去公共例程段的起始汇编地址，再减去一，就是公共例程段的段界限，这就是第100～102 行所做的工作。对于向上扩展的段来说，段界限在数值上等于段的长度减去一，这个必须要清楚。

第103 行，用公共例程段的起始汇编地址，加上内核的加载地址，就是公共例程段的基地址。

在已经知道某个内存段的细节时，写出它的描述符是很容易的。比如，如果已经知道栈的基地址是0x00007C00，粒度是4KB，大小是8KB，那么，它的描述符就可以直接给出：

```assembly
0x00CF96007C00FFFD
```

问题是，这种清楚明白的情形不常见。在百分之九十以上的场合，段的信息只有在程序运行的时候才能确定，它们都是在程序运行时，根据实际情况得到的随机值。为此，就需要利用指令来以不变应万变，“拼凑”出描述符来。

既然是灵活的方法，还能以不变应万变，就应该定义成过程，以方便在需要的时候随时调用。在这里，我们的方法是使用过程make_gdt_descriptor。

过程make_gdt_descriptor 位于代码清单13-1 的195～217 行，调用该过程需要三个参数，分别是段的线性基地址、段界限和段的属性值。段的基地址用EAX 寄存器传入；段界限用EBX 寄存器传入，但只用其低20 位；段属性用ECX 寄存器传入，各属性位在ECX 寄存器中的分布和它们在描述符高32 位中的时候一样，其他和段属性无关的位都清零。

因此，第104 行，将段属性值0x00409800 传送到ECX 寄存器。结合第11 章的图11-4，可以知道，这是一个P＝1、D＝1、G＝0、DPL＝0、S＝1，TYPE＝1000 的（代码）段描述符。第105 行，调用过程创建描述符，下面来看看具体的创建过程。

代码清单13-1 的第201～203 行用于构造描述符的低32 位。首先是将32 位段基地址从EAX 寄存器复制一份给EDX 寄存器，过一会儿构造描述符的高32 位时，还要用到基地址。

描述符的低32 位中，高16 位是基地址；低16 位是段界限，所以，第202～203 行，将EAX寄存器中的32 位基地址左移16 次，使基地址部分就位。然后，把BX 寄存器中的段界限用or 指令安排就位。这样，描述符的低32 位就构造完毕了。

相比之下，描述符的高32 位构造起来比较麻烦。如图13-6 所示，描述符高32 位的标准形态是有两个基地字段和一个段界限字段。基地址在EDX 寄存器中有备份，执行第205～207 行的指令后，会使基地址部分在两边就位。

![截图 2023-05-10 10-19-47](/home/cccmmf/操作系统/x86/chap13/截图 2023-05-10 10-19-47.png)

bswap 是字节交换指令（Byte Swap），在标准的32 位处理器上只允许32 位的寄存器操作数，其格式为

```assembly
bswap r32
```

处理器执行该指令时，按如下过程操作（DEST 是指令中的操作数，TEMP 是处理器内的临时寄存器）：

```assembly
TEMP <- DEST
DEST[7:0] <- TEMP[31:24];
DEST[15:8] <- TEMP[23:16];
DEST[23:16] <- TEMP[15:8];
DEST[31:24] <- TEMP[7:0];
```

接下来，要在描述符的高32 位中装配段界限字段。第209、210 行，先清除EBX 寄存器的低16 位，然后同EDX 寄存器合并。这里是假设EBX 寄存器的高12 位为全零，所以用了xor bx，bx指令。实际上，安全的做法是使用指令

and ebx,0x000f0000 最后，第212 行，将ECX 寄存器中的段属性与EDX 寄存器中的描述符高32 位合并。至此，我们就在EDX:EAX 中得到了完整的64 位描述符。第214 行，ret 指令将控制返回到调用者。

现在，回到主程序，来看第106、107 行，ESI 寄存器的内容是GDT 的基地址，这两条指令访问4GB 的段，定位到GDT，在原先的基础上，再添加一个描述符，就是我们刚刚创建的描述符。

第110～129 行，用于安装内核数据段和内核代码段的描述符，也采用了相同的过程，不再一一讲解。

第131 行，通过4GB 的数据段访问pgdt，修改它的界限值。现在，GDT 中已经有8 个描述符，故其总长度为64 字节。相应地，界限值为63。

第133 行，通过4GB 的数据段访问pgdt，重新加载GDTR，使上面那些对GDT 的修改生效。

至此，内核已经全部加载完毕，图13-7 是内核加载完成之后的GDT 布局。

第136 行，通过4GB 的数据段访问内核的头部，用间接远转移指令从给定的入口进入内核执行。观察图13-5，再参考代码清单13-2 就可以明白，在内核头部偏移0x10 处，是6 字节的内核入口点。前面是32 位的段内偏移地址，后面是16 位的段选择子，指向内核代码段。在这里，段选择子直接使用固定的数值不是一个好主意，怕的是往后内核有重大调整时，会改变描述符的次序。在这种情况下，如果别处改了，这里忘了修改，就一定会出现问题。

![截图 2023-05-10 10-26-58](/home/cccmmf/操作系统/x86/chap13/截图 2023-05-10 10-26-58.png)

## 在内核中执行

从主引导程序转移到内核之后，处理器会从第532 行开始执行，因为这里是内核的入口。

第532、533 行，初始化段寄存器DS，使它指向内核数据段。然后，第535、536 行，调用公共例程段内的一个过程来显示字符串。该call 指令属于直接远转移，指令中给出了公共例程段的选择子和段内偏移量。字符串是在第362 行，用标号message_1 声明，并初始化了一段文字，意思是“如果你看到这段信息，那么这意味着我们正在保护模式下运行，内核已经加载，而且显示例程工作得也很完美。”

显示例程put_string 位于公共例程段内，是在第37 行定义的。基本上，它的代码组成和工作原理都和从前一样，但也有不同之处。首先，这里的代码是32 位模式的，字符串的地址由DS:EBX 传入，过程返回时用retf 指令，而不是ret。这意味着，必须以远过程调用的方式使用它。

和往常一样，put_string 在内部调用了另一个过程put_char。注意，第110～113 行，movsd 用于在两个内存区域间传送双字数据（一次传送4 字节）。不管是movsb，还是movsw，抑或是movsd，在16 位模式下，是把由DS:SI 指定的源操作数传送到由ES:DI 指定的目的地。但是，在32 位模式下，源和目的则分别是DS:ESI 和ES:EDI。

再回到539 行，下面的工作是显示处理器品牌信息。

处理器的功能是强劲的，这个没有人怀疑。同时，在处理器内部也隐藏着太多的秘密，除了处理器的型号，还有大量的特性信息，比如高速缓存的数量、是否具备温度和电源管理功能、逻辑处理器的数量、高级可编程中断控制器的类型、线性（物理）地址的宽度、是否具有多媒体扩展和单指令多数据指令等特性。

处理器功能强了是好事，大家都很欢喜。麻烦在于，很多新功能是处理器更新换代的产物，只存在于最新的版本中，旧的处理器没有。比如多媒体扩展指令可以加速多媒体的处理速度，但用了新指令的软件不能运行在旧的处理器上，因为它们不支持。

因此，你的软件应当准备两套方案，而且，在决定使用哪套方案之前，必须探测和挖掘处理器内部的秘密，好知道该怎么办。Intel 公司显然洞悉了市场上发生的一切，它们给出的方案是使用cpuid 指令。

cpuid 指令（CPU Identification）用于返回处理器的标识和特性信息。EAX 用于指定要返回什么样的信息，也就是功能。cpuid 指令执行后，处理器将返回的信息放在EAX、EBX、ECX 或者EDX 中。

cpuid 指令是从80486 处理器的后期版本开始引入的，从此以后，每款处理器都会对可以返回的信息有所扩充。原则上，在使用cpuid 指令前，先要检测处理器是否支持该指令；接着再用cpuid 指令检测是否支持所需要的功能。

如图13-8 所示，在32 位处理器上，原先的标志寄存器FLAGS 也相应地扩充到了32 位，以支持更多的标志。扩充之后的标志寄存器称为EFLAGS 寄存器，它的ID 标志位（位21）如果为“0”，则不支持cpuid 指令；反之，该处理器支持cpuid 指令。80486 处理器已经很久远了，我想没有谁还在使用这样的计算机，况且它已经停产。一般情况下，不需要检测处理器是否支持cpuid 指令。

![截图 2023-05-10 12-42-42](/home/cccmmf/操作系统/x86/chap13/截图 2023-05-10 12-42-42.png)

图13-8 中，灰色的部分是保留位，通常设置为固定的值。EFLAGS 还包括更多的标志位，图中未予显示，仅在以后用到的时候一一介绍。

为了探测处理器最大能够支持的功能号，应该先用0 号功能来执行cpuid 指令：

```assembly
mov eax, 0
cpuid
```

处理器执行后，将在EAX 寄存器返回最大可以支持的功能号。同时，还在EBX、ECX 和EDX 中返回处理器供应商的信息。对于Intel 处理器来说，返回的信息如下：

```assembly
EBX <- 0X756E6547	(对应字符串"Genu"，"G"在BL中，其他类推)
EDX <- 0X49656E69	(		  "ineI"，"i"在DL中...)
ECX <- 0X6C65746E	(		  "ntel", "n"在CL中...)
```

组合起来就是“GenuineIntel”。

要返回处理器的品牌信息，需要使用0x80000002～0x80000004 号功能，分三次进行。注意，该功能仅被奔腾4（Pentium 4）之后的处理器支持，所以，正确的做法是先用0 号功能执行cpuid指令，以判断自己的处理器是否支持。代码清单13-2 并没有这样做，因此可视为一个反面典型。

第539～558 行，分别用三种功能号执行cpuid 指令，返回三组字符串，共48 个字符，依次保存在核心数据段中，起始位置是由标号cpu_brand 指定的。第381 行，声明了标号cpu_brand，并初始化了52 字节，足以容纳这些数据。

从处理器返回的数据都是现成的ASCII 码。第560～565 行，先在屏幕上留出空行，再显示处理器品牌信息，然后再留空，以突出要显示的内容。

## 用户程序的加载和重定位

用户程序加载之前，要先显示一段信息，意思是要加载用户程序了。这是第567、568 行的工作。字符串位于内核数据段中，第367 行声明了标号message_5 并初始化了字符串。

第569 行用于指定用户程序的起始逻辑扇区号。在指令中直接指定数值不是一个好习惯，正确的做法是用伪指令equ 声明成常数，并放到整个程序的起始部分以便修改。

内核的主要任务就是加载和执行用户程序。通常情况下，这样的工作会反复进行。为了方便， 一般要定义成可反复调用的过程。在这里， 我们也是这样做的， 过程的名字叫load_relocate_program。该过程位于第387 行，作用是加载和重定位用户程序。从代码清单中可以看出，它是内核代码段的一个内部过程。

### 用户程序的结构

现在转到代码清单13-3，来看看用户程序的结构。

在文件头内的偏移0 处，是一个双字，指示了用户程序的大小，以字节为单位。

偏移量为0x04 处的双字是头部的长度，以字节为单位。

偏移量为0x08 处的双字是为栈保留的，和早先的做法不同，内核不要求用户程序提供栈空间，而改由内核动态分配，以减轻用户程序编写的负担。当内核分配了栈空间后，会把栈段的选择子填写到这里，用户程序开始执行时，可以从这里取得该选择子以初始化自己的栈；

偏移量为0x0c 处的双字是要求分配的栈大小，即，用户程序编写者建议的栈大小，以4KB为单位。如果是1，就是希望分配4KB 的栈空间；如果是2，就是希望分配8KB 的栈空间，依此类推。

偏移量为0x10 处的双字，是用户程序入口点的32 位偏移地址。

偏移量为0x14 处的双字，是用户程序代码段的起始汇编地址。当内核完成对用户程序的加载和重定位后，将把该段的选择子回填到这里（仅占用低字部分）。这样一来，它和0x10 处的双字一起，共同组成一个6 字节的入口点，内核从这里转移控制到用户程序。

偏移量为0x18 处的双字，是用户程序代码段的长度，以字节为单位。

偏移量为0x1c 处的双字，是用户程序数据段的起始汇编地址，当内核完成用户程序的加载和重定位后，将把该段的选择子回填到这里（仅占用低字部分）。

偏移量为0x20 处的双字，是用户程序数据段的长度，以字节为单位。

除了加载和重定位用户程序外，内核还应当提供一些例程供用户程序调用。

操作系统提供的编程接口就是API，这是一大堆例程（过程），需要的时候直接调用即可。问题在于，它们在操作系统内部，对任何人来说都是不可见的，更别想知道它们的入口地址。但是，call 指令是需要直接或间接提供一个地址的。另一方面，即使你知道它们的地址，调用的时候也有风险，因为操作系统也需要升级换代，这些地址可能改变。当你的程序在新操作系统上工作时，就要出问题。

为了使开发人员能够利用它所提供的API，操作系统至少要公开它们。在早期的系统中，这些API 以中断号的方式公布，因为它们是通过软中断进入的。不过，另一种常见的办法是使用符号名。比如，操作系统提供了一个例程，用于显示光标跟随的字符串，那么，它可以公布一个符号名：

```assembly
PrintString
```

在操作系统的开发手册中，会列出所有符号名。符号名在高级语言里就是库函数名。

回到代码清单13-3 中来。

内核要求，用户程序必须在头部偏移量为0x28 的地方构造一个表格，并在表格中列出所有要用到的符号名。每个符号名的长度是256 字节，不足部分用0x00 填充。在用户程序加载后，内核会分析这个表格，并将每一个符号名替换成相应的内存地址，这就是过程的重定位。为了方便起见，我们把该表格叫做“符号-地址检索表”（Symbol-Address Lookup Table，SALT）。不要上网搜索这个词，也不要查别的资料，这不是一个标准，是我自己随心所欲、特立独行的产物。

第29～36 行声明了三个标号，并分别初始化了三个符号名，每一个256 字节，不足部分是用0 填充的。每个符号名都以“@”开始，这并没有任何特殊意义，仅仅在概念上用于表示“接口”的意思。为了计算需要填充多少个0，它们都使用了相似的表达式，比如：

```assembly
times 256-($-PrintString) db 0
```

先计算出符号名的实际字符数，即$-PrintString，再用256 减去实际字符数，就得到了伪指令db 的重复次数。

SALT 表可大可小，内核需要知道它在哪里结束。第26 行，用于初始化SALT 表的项数，也就是符号名的数量，它是用表格的总长度除以每个符号名的长度（256）得到的。

事实上，即使是大多数汇编语言，也不需要亲自构造文件头，那是链接器（Linker）的工作。但是，链接器是为流行的操作系统服务的，用于构造他们可以识别的可执行文件格式。

### 计算用户程序占用的扇区数

再次回到代码清单13-2。

用户程序的加载是在例程load_relocate_program 内进行的，该过程需要用ESI 寄存器传入用户程序的起始逻辑扇区号。当过程返回时，在AX 寄存器内包含了指向用户头部段的选择子。

第396、397 行，因为在过程中要用到DS 和ES，故将其原先的内容压栈保存。

为了得到用户程序的大小，需要先预读它的第一个扇区，第399～404 行就在做这件事。首先，使段寄存器DS 指向内核数据段；然后，调用读硬盘的过程read_hard_disk_0 来预读用户程序。进入过程前，EAX 寄存器的内容是用户程序的起始逻辑扇区号；数据的存放地点是内核缓冲区core_buf，它位于内核数据段中，是在第376 行声明和初始化的。在内核中开辟出一段固定的空间，对于分析、加工和中转数据都比较方便。

接下来的工作是计算用户程序到底占用了多少个扇区。用户程序的总大小就在头部内偏移量为0x00 的地方，因此，第407 行直接访问内核缓冲区取得这个双字。

用户程序的大小（总字节数）不一定恰好是512 的整数倍。也就是说，最后一个扇区未必是满的。因此，如果直接除以512，可能会使结果（除法的商）比实际的扇区数少一。通常情况下，需要判断除法的余数，根据余数是否为零，来决定实际的扇区总数，这不可避免地要使用判断和条件转移指令。

在早先的处理器中，转移指令是影响处理器速度的重大因素之一，因为它会使流水线中那些已经预取和译码的指令失效。在较晚的处理器中，普遍采用了分支预测技术，但并不总能保证预测是准的。因此，最好的办法就是尽量不使用转移指令。为了帮助程序员部分地戒掉使用转移指令的欲望，处理器引入了条件传送指令cmovcc。

cmovcc 指令是从P6 处理器族开始引入的，因此并非所有处理器都支持它。如果你想知道确切的结果，可以先以1 号功能执行cpuid 指令：

```assembly
mov eax, 1
cpuid
```

当处理器执行这两条指令后，会在EBX、ECX 和EDX 寄存器返回丰富的信息，以指示各种详尽的处理器特性。此时，检查EDX 寄存器的第16 位（bit 15），当它是“1”时，表明处理器支持cmovcc 指令。

条件转移指令和传送指令相结合的产物，既有条件转移指令的多样性，又执行的是传送操作。但是，和mov 指令不同的是，它的目的操作数只允许是16 位或者32 位通用寄存器，源操作数只能是相同宽度的通用寄存器和内存单元，以下是几个常用的例子：

```assembly
cmovz ax, cx	;为0则传送
cmovnz eax, [0x2000]	;不为0则传送
cmove ebx, ecx	;相等则传送
cmovng cx, [0x1000]	;不大于则传送
cmovl edx, ecx	;小于则传送
```

条件传送指令是很多的。在第6 章的表6-1 中，列举了所有的条件转移指令。完整的cmovcc指令列表，可以在表6-1 的基础上，将那些指令的首字母“j”换成“cmov”即可。

cmovcc 指令不影响EFLAGS 寄存器中的任何标志位。相反地，它的执行过程要依赖于这些标志，就像条件转移指令一样。

言归正传，为了不使用条件转移指令而又能算出用户程序实际占用的扇区数，需要一点技巧。考察一下，你发会现，所有能被512 整除的数，其最低端的9 个比特都是“0”。

很好，第408 行，将用户程序的总大小从EAX 寄存器传送到EBX 寄存器，等于是做个备份，因为后面还要用到；第409、410 行，先用and 指令将其最低的9 个比特清零，等于是去掉那些不足512 的零头，然后，再将其加上512，等于是将那些零头凑整。

但是，若人家原本就是512 的整数倍，你这么做无疑是多加了一个扇区。因此，第411、412 行，先测试EAX 寄存器的最低9 个比特，如果测试的结果是它们不全为零，则采用凑整的结果；如果为全零，则cmovcc 指令什么也不做，依然采用用户程序原本的长度值。

### 简单的动态内存分配

下面的工作是把用户程序从硬盘上读到内存中。我们以前的做法是指定一个区域，比如物理地址0x100000，然后把程序加载到那里。如果要加载的程序很多，这就会成为一种需要仔细规划的工作，每个程序加载到哪里，都需要一一指定。

在流行的操作系统里，内存管理是一项重要而又严肃的工作，不用说也相当复杂。它要记住所有可以分配的内存，将它们分成块。这样，当要求分配内存时，内存管理程序将查找并分配那些大小相符的空闲块；当占用这些块的用户终止执行后，还要负责回收它们，以便再用于分配；当内存空间紧张，找不到空闲块，或者空闲块的大小不能满足需求时，内存管理程序还要负责查找那些很少被访问的块，将其中的数据移到硬盘上，腾出空间来满足当前的需求。下次当这些块再次被用到时，再用同样的办法从硬盘调回内存。

讲了这么多，你可能以为我们现在就要写一个内存管理程序。不，不会的，这不太现实。就我们目前的需求来说，只需要一个简单的内存分配程序就可以了，这就是allocate_memory 例程。

allocate_memory 例程位于代码清单13-2 的公共例程段中，它仅仅需要通过ECX 寄存器传入希望分配的字节数。当过程返回时，ECX 寄存器包含了所分配内存的起始物理地址。

allocate_memory 的内存分配策略非常简单。请看代码清单13-2 的第335 行，在内核数据段中声明了标号ram_alloc，并初始化为一个双字0x00100000，这就是可用于分配的初始内存地址。很显然，这个位置正好在1MB 之外。每次请求分配内存时，allocate_memory 过程仅简单地返回该内存单元的值，作为所分配内存的起始地址。同时，将这个值加上所分配的长度，作为下次分配的起始地址写回该内存单元。

因此，在进行了必要的现场压栈保护之后，第239～247 行，先使段寄存器DS 指向内核数据段以访问标号ram_alloc 所指向的内存单元；然后，计算下次可用于分配的起始内存地址并存放到EAX 寄存器中；最后，在ECX 中得到本次分配到的起始内存地址，这个值将返回给调用者。当然，在这个过程中没有检测是否超越了实际拥有的物理内存。我们的程序都非常小，现在哪台计算机没有几十兆、几百兆甚至几个吉的内存呢？

原则上，将EAX 寄存器中的值写回ram_alloc 所指向的双字单元即可。不过，32 位的计算机系统建议内存地址最好是4 字节对齐的，这样做的好处是访问速度最快。为此，在将EAX 寄存器的值写回内存之前，最好使之成为可被4 整除的值，这种数值的特点是最低两个比特为“0”。

第249～254 行，先将EAX 寄存器的内容传送到EBX 进行备份；接着，强制EBX 中的地址对齐在下一个4 字节边界，对齐之后的值肯定会比原先大；然后，看一看原始分配的起始地址（在EAX 寄存器中）是否是4 字节对齐的，如果不是，就采用对齐之后的值；如果原本就是4 字节对齐的，那么，依然采用原值；最后，将这个值写回到原内存单元中，作为下次内存分配的起始地址。

过程allocate_memory 是用retf 指令返回的。因此，它只能通过远过程调用来进入。

### 段的重定位和描述符的创建

接着回到load_relocate_program 过程。

我们已经算出了用户程序的总长度，而且已经被调整为可以被512 整除的数。第414、415 行，用这个数值去调用allocate_memory 过程分配内存。分配到手的内存块，起始地址在ECX 寄存器中。

第416 行，将ECX 寄存器的内容传送到EBX，其动机是作为起始地址从硬盘上加载整个用户程序。

第417 行，将该首地址压栈保存，其目的是用于在后面访问用户程序头部。

第418～420 行，用户程序的总长度除以512，得到它所占用的扇区总数。

第421 行，将扇区数传送到ECX 寄存器，用于控制后面的循环次数。该循环是用来加载整个用户程序的。

第423、424 行，使段寄存器DS 指向4GB 的内存段，这样就可以加载用户程序了。

第428～430 行，循环读取硬盘以加载用户程序。读取的次数由ECX 控制；加载之前，其首地址已经位于EBX 寄存器。起始逻辑扇区号原本是通过ESI 寄存器传入的，循环开始之前已经传送到EAX 寄存器（第426 行）。

既然用户程序已经全部读入内存，现在的任务就是根据它的头部信息来创建段描述符。

第433 行，从栈中弹出用户程序首地址到EDI 寄存器，它是在前面第417 行压入的，该地址也是用户程序头部的起始地址。

第434～438 行，读用户程序头部信息，根据这些信息创建头部段描述符。在主引导程序里，有一个创建描述符的例程，在内核中，也编写了一个同样的例程make_seg_descriptor，甚至它们所用的指令都一模一样。它属于公共例程段，是在第308 行定义的。

该过程要求用EAX 寄存器传入段的基地址，这是第434 行的工作。段界限由EBX 寄存器传入，第435、436 行访问4GB 内存段，从用户程序头部偏移0x04 处取出段长度，减一后形成段界限。第437 行用于给出头部段的属性值。

从过程返回时，EDX：EAX 中包含了64 位的段描述符。紧接着，第439 行调用公共例程段内的另一个过程set_up_gdt_descriptor，把该描述符安装到GDT 中。

set_up_gdt_descriptor 也属于公共例程段，是在第263 行定义的，它需要通过EDX:EAX 传入描述符作为唯一的参数。该过程返回时，CX 寄存器中包含了那个描述符的选择子。

要在GDT 内安装描述符，必须知道它的物理地址和大小。而要知道这些信息，可以使用指令sgdt（Store Global Descriptor Table Register），它用于将GDTR 寄存器的基地址和边界信息保存到指定的内存位置。sgdt 指令的格式为

```assembly
sgdt m
```

其中，m 是一个6 字节内存区域的首地址。该指令不影响任何标志位。

第332、333 行，在内核数据段中，声明了标号pgdt，并初始化了6 字节，供sgdt 指令使用。低2 字节用于保存GDT 的界限（大小）；高4 字节用于保存GDT 的32 位物理地址。

第332、333 行，在内核数据段中，声明了标号pgdt，并初始化了6 字节，供sgdt 指令使用。低2 字节用于保存GDT 的界限（大小）；高4 字节用于保存GDT 的32 位物理地址。

回到例程set_up_gdt_descriptor 中。第270～276 行，在压栈保存了DS 和ES 的原始内容后，使DS 指向内核数据段。紧接着，使用sgdt 指令取得GDT 的基地址和大小。

第278、279 行，使段寄存器ES 指向4GB 内存段以操作全局描述符表（GDT）。

下面的工作是计算描述符的安装地址。这个地址可以这样计算：先得到描述符表的界限值，将它加一，得到描述符表的总字节数，这实际上也是新描述符在GDT 内的偏移量。然后，用GDT 的线性地址加上这个偏移量，就是用于安装新描述符的线性地址。

第281 行，先访问内核数据段，取得GDT 的界限值。注意，这里出现了一个新指令movzx，其作用是带零扩展的传送（Move with Zero-Extend），指令格式为

```assembly
movzx r16, r/m8
movzx r32, r/m8
movzx r32, r/m16
```

也就是说，movzx 指令的目的操作数只能是16 位或者32 位的通用寄存器，源操作数只能是8位或者16 位的通用寄存器，或者指向一个8 位或16 位内存单元的地址。而且，很有意思的是，目的操作数和源操作数的大小是不同的。这里有几个例子：

```assembly
movzx cx, al	;如果指令执行前，AL寄存器的内容是0xC0，那么，指令执行后，CX寄存器的内容为0x00C0
movzx eax, byte [0x2000]	;处理器访问段寄存器DS所指向的段，从偏移地址0x2000处取得一字节，左边添加24个“0”，使之扩展到32位，然后传送到EAX寄存器
movzx ecx, bx	;如果指令执行前，BX寄存器的内容为0x55AA，那么，指令执行后，ECX寄存器的内容为0x000055AA。
```

另一个非常有用的指令是movsx，意思是带符号扩展的传送（Move with Sign-Extension），指令格式为

```assembly
movsx r16, r/m8
movsx r32, r/m8
movsx r32, r/m16
```

和movzx 不同，movsx 在执行扩展时，用于扩展的比特取自源操作数的符号位。

GDT 的界限是16 位的，允许64KB 的大小，即8192 个描述符，似乎不需要使用32 位的寄存器EBX。事实上，还是需要的，因为后面要用它来计算新描述符的32 位线性地址，加法指令add要求的是两个32 位操作数。

第282 行，将GDT 的界限值加1，就是GDT 的总字节数，也是新描述符在GDT 内的偏移量。不过，很奇怪的是，我们用的是指令

```assembly
inc bx
```

而不是

```assembly
inc ebx
```

这是有道理的。就一般的情况来说，在这里用这两条指令的哪一条，都没有问题。但是，如果这是启动计算机以来，第一次在GDT 中安装描述符，可能就会产生问题。在初始状态下，也就是计算机启动之后，这时还没有使用GDT，GDTR 寄存器中的基地址为0x00000000，界限为0xFFFF。

当GDTR 寄存器的界限部分是0xFFFF 时，表明GDT 中还没有描述符。因此，将此值加1，结果是0x10000，由于该寄存器的界限部分只有16 位，所以只能容纳16 位的结果，即0x0000，这就是第一个描述符在表内的偏移量。

同样的道理，因为EBX 寄存器中的内容是GDT 的界限值0x0000FFFF，如果执行的是指令

```assembly
inc ebx
```

那么，EBX 寄存器中的内容将是0x00010000，以它作为第一个描述符的偏移量显然是不对的。相反，如果执行的是指令是

```assembly
inc bx
```

那么，因为BX 寄存器只有16 位，故，结果为0x0000，进位被丢弃（决不会影响EBX 寄存器的高16 位）。此指令执行后，EBX 寄存器的内容是0x00000000。

第283 行，用计算出来的偏移量加上GDT 的基地址，结果就是新描述符的线性地址。事实上，这三行或许可以按以下方法来简单处理，就没那么啰嗦了：

```assembly
xor ebx, ebx
mov bx, [pgdt]	;GDT界限
inc bx			;GDT总字节数，也是下一个描述符偏移
add ebx, [pgdt+2]	;下一个描述符的线性地址
```

第285、286 行，访问段寄存器ES 所指向的4GB 内存段，将EDX:EAX 中的64 位描述符写入由EDI 寄存器所指向的偏移处。

第288～290 行，访问内核数据段，将GDT 的界限值加上8，然后用lgdt 指令重新加载GDTR，使新的描述符生效。GDTR 寄存器中的界限值总是单数（8 的整数倍减1），包括它的初始值0xFFFF。所以，每次只要加上新描述符的实际大小就能得到正确的界限值。

最后，第292～297 行，根据GDT 的新界限值，来生成相应的段选择子。具体的算法是，取得GDT 的当前界限值，除以8，余数丢弃。描述符的索引是从0 开始编号的，界限值总是比GDT的总字节数小1。因此，界限值除以8，一定会有余数（余7，丢弃不用），商就是我们所要得到的描述符索引号。最后，将索引号左移3 次，留出TI 位和RPL 位（TI＝0，指向GDT，RPL＝00），这就是要生成的选择子。

第299～306 行，恢复调用之前的现场，返回调用者。返回时用了retf 指令，因此，本过程只能通过远过程调用的方式进入。

继续回到过程load_relocate_program。

安装了用户程序头部段的描述符后，第440 行，将该段的选择子写回到用户程序头部，供用户程序在接管处理器控制权之后使用。实际上，在内核向用户程序转交控制权时，也要用到。

第443～460 行，用于重定位用户程序代码段和数据段，并创建和安装相应的描述符，整个过程都是一样的，也很容易理解。

唯一不同的是栈段，栈所用的空间不需要用户程序提供，而是由内核动态分配。内核分配栈空间时，是以4KB 为单位的，也就是说，每次分配至少是4KB 的倍数。至于到底分配多少，用户程序应该根据自己的实际需求提出建议。

第463 行，从用户程序头部偏移为0x0C 的地方获得一个建议的栈大小。这是一个倍率，至少应当为1，说明用户程序希望分配4KB 栈。如果为2，说明希望分配8KB；为3 则表明希望分配12KB，依此类推。

第464、465 行，计算栈段的界限。如果栈段的粒度是4KB，那么，用0xFFFFF 减去倍率，就是用来创建描述符的段界限。举例来说，如果用户程序建议的倍率是2，那么，这意味着他想创建的栈空间为8KB。因此，段的界限值为

```assembly
0xFFFFF-2=0xFFFFD
```

那么，当处理器访问该栈段时，实际使用的段界限为

```assembly
0xFFFFD*0x1000+0xFFF=xFFFFDEFF
```

栈是向下扩展的，访问32 位的栈，要使用栈指针寄存器ESP，其最大值是0xFFFFFFFF。因此，ESP 的值只允许在0xFFFFDFFF 和0xFFFFFFFF 之间变化，共8KB。

第466～469 行，用4096（4KB）乘以倍率，得到所需要的栈大小，然后，用这个值去申请内存。这是一个32 位的无符号数乘法，指令格式为

```assembly
mul r/m32
```

这里，用EAX 寄存器的值，乘以另一个32 位的数（可以在通用寄存器或者内存单元里），在EDX:EAX 中得到64 位的乘法结果。

注意，allocate_memory 过程返回所分配内存的低端地址。和一般的数据段不同，栈描述符中的基地址，应当是栈空间的高端地址。所以，第470 行，用allocate_memory 返回的低端地址，加上栈的大小，得到栈空间的高端地址。

第471～473 行，依次调用两个例程，来生成和安装栈段的描述符。注意栈的属性值，它指明了这是一个32 位的栈段，粒度为4KB。

第474 行，将栈段的选择子写回到用户程序头部，供用户程序在接管处理器控制权之后使用。

### 重定位用户程序内的符号地址

为了使用内核提供的例程，用户程序需要建立一个符号-地址对照表（SALT）。这样，当用户程序加载后，内核应该根据这些符号名来回填它们对应的入口地址，这称为符号地址的重定位。显然，重定位的过程就是字符串匹配和比较的过程。

为了对用户程序内的符号名进行匹配，内核也必须建立一张符号-地址对照表（SALT）。

内核的SALT 表位于代码清单13-2 的内核数据段中，从第338 行开始，一直到第357 行结束。实际上，这个表是可以根据需要扩展的。

如图13-9 所示，用户程序内的SALT 表，每个条目是256 字节，用于容纳符号名，不足256字节的，用零填充。内核中的SALT 表，每个条目则包括两部分，第一部分也是256 字节的符号名；第二部分有6 字节，用于容纳4 字节的偏移地址和2 字节的段选择子，因为符号名是用来描述例程的，这6 字节就是例程的入口地址。

![截图 2023-05-10 19-30-01](/home/cccmmf/操作系统/x86/chap13/截图 2023-05-10 19-30-01.png)

举个内核中的例子：

```assembly
		 salt_1           db  '@PrintString'
                     times 256-($-salt_1) db 0
                          dd  put_string
                          dw  sys_routine_seg_sel
```

这是内核SALT 表的第一个条目。它初始化了一个256 字节的符号名，该名称的前12 个字符是“@PrintString”，因为不足256 字节，后面填充244 个0x00。

在该条目的后面，先是一个双字，初始化为put_string 例程的偏移地址。这就是说，PrintString 其实就是put_string 的别名，调用PrintString，其实是调用put_string 例程。在用户程序内，只能通过远过程调用来进入该例程，所以，该条目的最后是一个字，用公共例程段的选择子来初始化，因为put_string 例程位于公共例程段。

在内核SALT 表中，比较有意思的是最后一个条目：

```assembly
         salt_4           db  '@TerminateProgram'
                     times 256-($-salt_4) db 0
                          dd  return_point
                          dw  core_code_seg_sel
```

在这里，从名字可以看出，“TerminateProgram”的意思是终止程序。当用户程序调用该过程时，意味着结束用户程序，将控制返回到内核。

当用户程序终止并返回时，返回点位于标号return_point 所在的位置。该标号位于第582 行，属于内核代码段。在这一行之前，是内核将控制权交给用户程序的指令。

内核的SALT 表是静态的，适用于所有要加载的用户程序，理所当然地要比用户程序的SALT表大，因为它要提供所有可被用户程序调用的过程列表。至于用户程序，根据需要，它只会列出自己用到的那些。

在用户程序加载时，内核的任务是比对这两张SALT 表，并将用户程序SALT 表中的符号名替换成相应的入口地址。为了便于说明，用户程序的SALT 表简称U-SALT，内核的SALT 表简称C-SALT。

基本的算法是使用内外层循环，外循环依次从U-SALT 表中取出条目，每取出一个条目，就进入内循环进行比对；内循环遍历C-SALT 中的每一个条目，同外循环输入的条目进行比对。

比对的过程就是两个字符串的比较过程，可以使用cmps 指令（Compare String Operands）。该指令有3 种基本的形式，分别用于字节、字和双字的比较：

```assembly
cmpsb	;字节比较
cmpsw	;字比较
cmpsd	;双字比较
```

在16 位模式中，源字符串的首地址由DS:SI 指定，目的字符串的首地址由ES:DI 指定；在32位模式下，则分别是DS:ESI 和ES:EDI。在处理器内部，cmps 指令的操作是把两个操作数相减，然后根据结果设置标志寄存器中相应的标志位。

取决于标志寄存器EFLAGS 中的DF 位，如果DF＝0，表明是正向比较，也就是按地址递增的方向比较，这些指令执行后，SI（ESI）和DI（EDI）的内容分别加1、加2 和加4；否则，如果DF ＝1，表明是反向比较，这些指令执行后，SI（ESI）和DI（EDI）的内容分别减1、减2 和减4。

单纯的cmps 指令只比较一次，它属于推一下才动一动的那种类型。所以，需要加指令前缀rep 使比较连续进行。连续比较的次数由CX（ECX）寄存器控制，在16 位模式下，使用CX 寄存器；在32 位模式下，使用ECX 寄存器，举个例子：

```assembly
[bits 32]
rep cmpsd
```

该指令执行时，每次比较4 字节，连续比较直至ECX 寄存器的内容为零。

问题是，用rep 前缀比不出个所以然来，你就是重复比较100000 次，也看不出两个字符串哪里不同。所以，针对cmps 指令，应当使用repe（repz）和repne（repnz）前缀，前者的意思是“若相等（为零）则重复”，后者的意思是“若不等（非零）则重复”。但无论是哪种情况，总的比较次数由CX（ECX）控制，表13-1 显示了这几种控制手段的区别。

![截图 2023-05-10 19-41-06](/home/cccmmf/操作系统/x86/chap13/截图 2023-05-10 19-41-06.png)

可见，repe/repz 用于搜索第一个不匹配的字节、字或者双字，repne/repnz 用于搜索第一个匹配的字节、字或者双字。无论如何，匹配和不匹配的位置分别由(E)SI 和(E)DI 寄存器指示。

我们继续回到代码清单13-2 中来。

如图13-10 所示，为了重定位U-SALT，我们打算用DS:ESI 指向C-SALT，用ES:EDI 指向U-SALT。第477、478 行，访问4GB 内存段，从用户程序头部偏移为0x04 的地方取出刚刚安装好的头部段选择子，并使段寄存器ES 指向用户程序头部段，因为U-SALT 位于用户程序头部段内。

第479、480 行，使段寄存器DS 指向内核数据段。因为C-SALT 位于内核数据段中。

第482 行，清标志寄存器EFLAGS 中的方向标志，使cmps 指令按正向进行比较。

实施比较的算法我们已经介绍过了。外循环的作用是依次从U-SALT 中取出各个条目，因此，第484 行，将取的次数（条目的个数）从用户程序头部取出，传送到ECX 寄存器。

![截图 2023-05-10 19-45-50](/home/cccmmf/操作系统/x86/chap13/截图 2023-05-10 19-45-50.png)

接着，第485 行，用于将U-SALT 在头部段内的偏移量传送到EDI 寄存器。刚才我们已经使段寄存器ES 指向了头部段。

外循环的结构如下所示，这是从代码清单中抽出来的，行号也保持不变。

```assembly
  .b2: 
         push ecx
         push edi
      
      	;此处放置内循环代码，用于实际的比较
      
         pop edi
         add edi,256
         pop ecx
         loop .b2
```

由于内循环也要使用ECX 和EDI 寄存器，并有可能破坏它们的内容，因此，在进入内循环之前，要对它们压栈保护，以便退出内循环后继续使用。外循环的任务是从U-SALT 中依次取出表项，因此，当内循环完成比对后，第512、513 行，从栈中弹出EDI 寄存器的原始内容，并加上256，以指向下一个条目。第514、515 行，从栈中弹出ECX 寄存器的原值。loop 指令将ECX 的内容减一，根据结果判断是否继续循环。

对于外循环所指向的每一个条目，内循环要用它和C-SALT 中的所有条目进行比对，内循环的代码如下：

```assembly
   		 mov ecx,salt_items
         mov esi,salt
  .b3:
         push edi
         push esi
         push ecx

         mov ecx,64                         ;检索表中，每条目的比较次数 
         repe cmpsd                         ;每次比较4字节 
         jnz .b4
         mov eax,[esi]                      ;若匹配，esi恰好指向其后的地址数据
         mov [es:edi-256],eax               ;将字符串改写成偏移地址 
         mov ax,[esi+4]
         mov [es:edi-252],ax                ;以及段选择子 
  .b4:
      
         pop ecx
         pop esi
         add esi,salt_item_len
         pop edi                            ;从头比较 
         loop .b3
```

每次从外循环进入内循环时，都要重新设置比对次数，并重新使ESI 寄存器指向C-SALT 的开始处，这是第490、491 行的工作。标号salt_item_len 是在第359 行声明的，并用一个表达式初始化。每个条目的长度都是相同的，用当前汇编地址减去标号salt_4 的汇编地址，即$-salt_4，就是每个条目的长度（字节数）。事实上，这个数值是在编译阶段由编译器计算的，在数值上等于262。

标号salt_items 是在第360 行声明的，并初始化为一个表达式。该表达式的意思是，用整个C-SALT 的长度，除以每个条目的长度，就是条目的个数。

对于内循环的每一次执行，都要把ESI、EDI 和ECX 压栈保护，以免在比对的过程中用到并破坏这些寄存器。每次比对结束后，第506～509 行，依次弹出这些寄存器的值，并把ESI 的内容加上C-SALT 每个条目的长度（262 字节），以指向下一个C-SALT 条目。第510 行，loop 指令执行时，将ECX 的内容减一并判断是否继续循环。

第497～503 行，是整个比对过程的核心部分。每当处理器执行到这里时，DS:ESI 和ES:EDI都各自指向C-SALT 和U-SALT 中的某个条目：

```assembly
         mov ecx,64                         ;检索表中，每条目的比较次数 
         repe cmpsd                         ;每次比较4字节 
         jnz .b4
         mov eax,[esi]                      ;若匹配，esi恰好指向其后的地址数据
         mov [es:edi-256],eax               ;将字符串改写成偏移地址 
         mov ax,[esi+4]
         mov [es:edi-252],ax                ;以及段选择子 
  .b4:
```

因为每个条目的符号名部分是256 字节，每次用cmpsd 指令比较4 字节，故每个条目至多需要比对64 次。第497 行把立即数64 传送到ECX 寄存器以控制整个比对过程。

第498 行，开始比对，直到发现一个不相符的地方。

如果两个字符串相同，则需要连续比对64 次，而且，在比对结束时，ZF＝1，表示最后4字节也相同；如果两个字符串不同，比对过程会提前结束，且ZF＝0。在最坏的情况下，这两个字符串可能只有最后4 字节是不同的。在这种情况下，也需要比对64 次，但ZF＝0。

无论哪种情况，如果在退出repe cmpsd 指令时ZF＝0，即表明两个字符串是不同的。所以，第499 行，如果ZF＝0，则表明两个字符串不同，直接转移到内循环的末尾，以开始下一次内循环。

如果两个字符串是相同的，那么，比较指令执行后，ESI 寄存器正好指向C-SALT 每个条目后的入口数据。要知道，C-SALT 中的每个条目是262 字节，最后的6 字节分别是偏移地址和段选择子。

因此，现在的任务是将这结尾的6 字节传送到U-SALT 当前条目的开始部分，这是第500～503 行的工作。最后的结果是，U-SALT 中的当前条目，其开始的6 字节被改写为一个入口地址。

## 执行用户程序

在load_relocate_program 过程的最后，第517 行，把用户程序头部段的选择子传送到AX 寄存器。第519～528 行，从栈中弹出并恢复各个寄存器的原始内容，并返回到调用者。AX 寄存器中的选择子是作为参数返回到主程序的。主程序将用它来找到用户程序的入口，并从那里进入。

从load_relocate_program 过程返回后，第572、573 行用于在屏幕上显示信息，表示加载和重定位工作已经完成。

第575 行，保存内核的栈指针。这是通过将ESP 寄存器的当前值写入内核数据段中来完成的。写入的位置是由标号esp_pointer 指示的，位于第378 行，初始化为一个双字。在进入用户程序后，用户程序应当切换到它自己的栈。从用户程序返回时，还要从这个内存位置还原内核栈指针。

第577 行，使段寄存器DS 指向用户程序头部。这是通过将用户程序头部段选择子传送到DS 来办到的。在用户程序头部段内偏移0x10 处，是用户程序的入口点，分别是32 位的偏移量和16 位的代码段选择子。第579 行，执行一个间接远转移，进入用户程序内接着执行。

现在转到代码清单13-3。

用户程序的入口点是在第56 行。进入用户程序开始执行时，段寄存器DS 是指向头部段的。第57、58 行，使段寄存器FS 指向头部段，因为后面要调用内核过程，而这些过程都要求使用DS，所以要把DS 解放出来。

第60～62 行，切换到用户程序自己的栈，并初始化栈指针寄存器ESP 的内容为0。

第64、65 行，设置段寄存器DS 到用户程序自己的数据段。

第67、68 行，调用内核过程显示字符串，以表明用户程序正在运行中。该内核过程要求用DS:EBX 指向零终止的字符串。

第70～72 行，调用内核过程，从硬盘读一个扇区。从内核代码清单可以知道，ReadDiskData过程的内部名称是read_hard_disk_0。所以，ReadDiskData 需要传入两个参数，第一个是EAX 寄存器，传入要读的逻辑扇区号；第二个是DS:EBX，传入缓冲区的首地址，毕竟读出来的数据要有个地方保存。缓冲区位于用户程序的数据段中，是在第43 行用标号buffer 声明的，并初始化了1024 字节的空间。要读的逻辑扇区号是100，在此之前，我们应当在这个扇区里写一些东西。这件事我们马上就要讲到。

第74～78 行，先调用内核过程显示一个题头，接着，再次调用内核过程显示刚刚从硬盘读出的内容。

在做完了上述事情之后，用户程序的任务也就完成了。第80 行，调用内核过程，以返回到内核。

再次回到代码清单13-2。

在内核中，用户程序的返回点位于第582 行。

在重新接管了处理器的控制权后，第583、584 行，使段寄存器DS 重新指向内核数据段。

第586～588 行，切换栈，使栈段寄存器SS 重新指向内核栈段，并从内核数据段中取得和恢复原先的栈指针位置。

第590、591 行，显示一条消息，表示现在已经回到了内核。

对于一个操作系统来说，下面的任务是回收前一个用户程序所占用的内存，并启动下一个用户程序。但是，我们现在无事可做，所以，第596 行，使处理器进入停机状态。别忘了，在进入保护模式之前，我们已经用cli 指令关闭了中断，所以，除非有NMI 产生，处理器将一直处于停机状态。

## 代码的编译、运行和调试

c13_mbr.bin 的起始逻辑扇区号是0；c13_core.bin 的起始逻辑扇区号是1；c13.bin 的起始逻辑扇区号是50。

用户程序的功能是读取逻辑扇区100，并显示其内容。为此，需要找一个文本文件，并将它写入该扇区。在配书源代码中，提供了一个文本文件diskdata.txt，其大小是512 字节。如图13-11 所示，它包含了512 字节的英文文本。

随着程序代码量的增大，程序的编写和调试也会变得越来越困难。特别是当问题发生的时候，追查出错的位置和错误的原因都需要花费大量的时间、消耗大量的精力。

有时候，最简单的方法却很有效。比如，可以写一个特殊的过程，用来显示某个寄存器的内容。如果你的程序运行时出了问题，可以在有重大嫌疑的指令前后安排一些调用该过程的代码，看看是哪里不正常。这些用于调试程序的位置，叫做检查点。

为了方便调试程序，代码清单13-2 提供了一个过程put_hex_dword，用于以十六进制的形式显示EDX 寄存器的内容。

该过程位于第202 行，它的工作原理很简单，EDX 寄存器是32 位的，从右到左，将它以4 位为一组，分成8 组。每一组的值都在0～15（0x0～0xf）之间，我们把它转换成相应的字符’0’ ～’F’即可。

为了将数值转换成可显示的ASCII 码，可以使用处理器的查表指令xlat（Table Look-up Translation），该指令要求事先在DS:(E)BX 处定义一个用于转换编码的表格，在16 位模式下，使用BX 寄存器；在32 位模式下，使用EBX 寄存器。指令执行时，处理器访问该表格，用AL 寄存器的内容作为偏移量，从表格中取出一字节，传回AL 寄存器。

代码清单13-2 定义的表格在第374 行。在那里，声明了标号bin_hex，并初始化了16 个字符，这是一个二进制到十六进制的对照（检索）表。偏移（索引）为0 的位置是字符“0”；偏移（索引）为0x0f 的位置是字符“F”。

第209、210 行，使段寄存器DS 指向内核数据段，因为对照表bin_hex 位于内核数据段中。

第212 行，使EBX 寄存器指向检索（对照表）的起始处。

转换过程使用了循环，每次将EDX 寄存器的内容循环左移4 位，共需要循环8 次。每次移位后的内容被传送到EAX 寄存器，并用and 指令保留低4 位，高位清零。第218 行，xlat 指令用AL 寄存器中的值作为索引访问对照表，取出相应的字符，并回传到AL 寄存器。

每次从检索（对照）表中得到一个字符，就要调用put_char 过程显示它。但put_char 过程需要使用CL 寄存器作为参数。因此，第220 行，在显示之前先要将ECX 寄存器压栈保护。

xlat指令不影响任何标志位。
