## chap11 进入保护模式

实模式下，用户对内存访问没有任何限制，随便就能修改任何一个内存单元，如下代码，先保存当前数据段地址，然后修改别人数据，最后再回到原先数据段

```assembly
mov cx, 0x8000		;逻辑段地址
push ds
mov ds, cx
mov [0x05], dx		;逻辑地址0x8000:0x0005，即物理地址0x80005
pop ds
```

物理内存0x80005不属于当前程序，它照样可以切换过去并修改它。

#### 全局描述符表

和一个段有关的信息需要8字节描述，称为段描述符，每个段都需要一个描述符。为了存放段描述符，有一个描述符表。全局描述符表（Global Descriptor Table，GDT），进入保护模式前必须定义全局描述符表。

GDTR为全局段描述符表寄存器，32位线性地址+16位边界，边界为表的大小（总字节数）减1，即表内最后一个字节的偏移量。GDT最大2的16次方字节，即65536（64KB）。每个描述符占8字节，最多8192个描述符。

![屏幕截图 2023-03-21 192003](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-21 192003.png)

必须在进入保护模式前定义GDT。由于实模式只能访问1MB内存，故GDT通常定义在1MB以下内存中。允许在保护模式后换个位置重新定义GDT。

![屏幕截图 2023-03-21 192402](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-21 192402.png)

### 存储器的段描述符

![屏幕截图 2023-03-21 194721](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-21 194721.png)

保护模式访问内存必须先在GDT内定义要访问的内存段。描述符不是由用户程序自己建立，而是在加载时，由操作系统根据你的程序结构而建立的，用户程序通常无法修改和建立GDT。

![屏幕截图 2023-03-21 203719](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-21 203719.png)

20位段界限用来限制段的拓展范围。访问内存的方法是段基地址加偏移量。对向上拓展的段（如代码段数据段）来说，偏移量从0开始递增，段界限决定偏移量最大值。对于向下拓展的段（栈段），段界限决定偏移量最小值。

G位是粒度（Granularity）位，用于解释段界限的含义。G位是0时，段界限以字节为单位（1字节B-1兆字节MB）。G如果是1，段界限以4K为单位。段的拓展范围从4KB到4GB。

S位用于指定描述符的类型（Descriptor Type）。该位是0，表示是一个系统段；为1时，表示是一个代码段或数据段（栈段是特殊的数据段）。

DPL表示描述符特权级（Descripotr Privilege Level，DPL）。共4种特权级，0、1、2、3,0是最高级，3是最低特权级。不同特权级程序互相隔离，其互访是严格限制的。

描述符特权级用于指定访问该段必须具有的特权级。

P是段存在位（Segement Present）。P位用于指示描述符所在段是否存在。有可能只建立了描述符，对应内存空间并不存在。

![屏幕截图 2023-03-21 204647](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-21 204647.png)

![屏幕截图 2023-03-21 205320](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-21 205320.png)

### 安装存储器的段描述符并加载GDTR

![屏幕截图 2023-03-27 191652](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 191652.png)

![屏幕截图 2023-03-27 192504](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 192504.png)

![屏幕截图 2023-03-27 192529](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 192529.png)

### 关于第21条地址线A20的问题

即将进入保护模式之前，有一个历史遗留问题，处理器的第21根地址线，编号A20。“A”是Address，A0是第一根地址线。8086处理器运行不存在A20问题，它只有20根地址线。

在8086处理器时，每当物理地址达到0xFFFF时，再加1，结果为0x100000。进位丢弃，地址又绕回0x00000。早期很多程序依赖回绕特性工作。80286时代，处理器有24根地址线，地址回绕失灵了，0x0FFFFF加1，变成0x100000，进位不会被丢弃。为了能在80286上运行8086程序，将A20强制恒为0就可以解决该问题。

IB,公司使用一个与门控制第21根地址线A20，并把这个与门的控制阀门放在键盘控制器内，端口号是0x60。向该端口写数据，如果第1位是1，name键盘控制器通过与门的输出就为1，与门的输出取决于处理器A20是“0”还是“1”。

在80486处理器后，处理器本身有了A20#引脚，意思是A20屏蔽（A20 Mask），它是低电平有效。

![屏幕截图 2023-03-27 194217](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 194217.png)

### 保护模式下的内存访问

CR0是处理器内部的控制寄存器（Control Register，CR）。

CR0是32位的寄存器，包含一系列用于控制处理器操作模式和运行状态的标志位。第1位（位0）是保护模式允许位（Protection Enable， PE），如果该位置1，则处理器进入保护模式，按保护模式规则开始运行。

![屏幕截图 2023-03-27 194531](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 194531.png)

保护模式下的中断机制和实模式不同，原有的中断向量表不再适用，在保护模式下，BIOS中断都不能再用，它是实模式下的代码。重新设置保护模式中断环境之前，必须关中断，折就是44行用意。

46行，将CR0寄存器送到eax，并修改它，47行将它第1位置1，48行，将其写入CR0，导致处理器运行模式变为保护模式。

8086处理器段寄存器是16位，共4个，CS、DS、ES和SS。32位处理器内，原先基础又增加了两个段寄存器FS和GS。

32位寄存器将6个段寄存器分2部分，前16位和8086相同，实模式下，用于按传统方式寻址1MB内存。每个段寄存器包含不可见部分，称高速缓存器，用来存放段的线性基地址、段界限和段属性。

![屏幕截图 2023-03-27 195632](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 195632.png)

在实模式下，访问内存用逻辑地址，将段地址乘16，再加偏移地址，如下例子

```assembly
mov cx, 0x2000
mov ds, cx
mov [0xc0], al
mov cx, 0xb800
mov ds, cx
mov [0x02], ah
```

在32位处理器上，该过程稍有不同。首先，引用一个段时，处理器自动将段地址左移4位，并传送到描述符高速缓存器。此后，就一直使用描述符高速缓存器的内容作为段地址。所谓引用一个段，就是执行将段地址传送到段寄存器的指令。如

```assembly
jmp 0xf000:0x5000
```

以上是引用代码段的例子，如果引用数据段，一般采用如下形式

```assembly
mov ax, 0x2000
mov ds, ax
```

只要不改变ds，以后每次访问都直接使用DS描述符高速缓存器中的内容。实模式下，只能向段寄存器传送16位逻辑地址（即，处理器不把它看成是描述符选择子），故，处理器仍只能访问1MB内存。实模式下，段寄存器描述符高速缓存器内容仅低20位有效，高12位清零。

实模式下的6个段寄存器CS、DS、ES、FS、SS和GS，保护模式下叫段选择器。保护模式访问内存有它自己的方式，访问内存也需要指定一个段，但传送到段选择器的内容不是逻辑段地址，而是段描述符在描述符表中的索引号。

![屏幕截图 2023-03-27 201354](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 201354.png)

![屏幕截图 2023-03-27 201805](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 201805.png)

### 清空流水线并串行化处理器

第一，在实模式下，段寄存器的描述符高速缓存器也被用于访问内存，低20位有效，高12位全零。在进入保护模式后，这些内容还在，程序可以继续试行，但是，这些残留内容在保护模式无效，迟早会在执行某些指令出问题。因此，安全做法是，尽快刷新CS、SS、DS、ES、FS和GS，包括段选择器和描述符高速缓存器。

第二，进入保护模式前，很多指令已经进入流水线。必须清空流水线。同时，那些通过乱序执行得到的中间结果也是无效的，必须清理掉，让处理器串行化执行，即，重新按指令的自然顺序执行。

怎么办呢？使用远转移指令jmp或者远调用指令call。处理器遇到这种指令，一般会清空流水线，并串行化执行；另一方面，远转移会重新加载段寄存器CS，并刷新描述符高速缓存器中的内容。一个建议方法是在设置CR0的PE位之后，立即用jmp或者call转移到当前指令的吓一跳指令。代码51行，用32位元转移指令来转移到紧挨着当前指令的下一跳指令

```assembly
jmp dword 0x0008:flush
```

该指令和前面指令一样，默认是用“bits 16”编译的，而且使用关键字dword，该关键字修饰偏移地址，意思是要求使用32位偏移量。因此，会有指令前缀0x66，编译后结果如下

```assembly
66 EA 80 00 00 00 08 00
```

实际上，因为处理器现在处于16 位保护模式，说到底还是16 位模式，因此，使用以下的16位远转移指令可能更自然一些：

```assembly
jmp 0x0008:flush	
;如果使用这条指令，那么，同样用“bits 16”编译，生成的机器指令是EA 7B 00 08 00
```

16 位的绝对远转移指令只有5 个字节，使用16 位的偏移量。因此，它会使标号flush 的汇编地址相应地变小，变成0x007B，而不是从前的0x0080。

16 位保护模式是从80286 处理器开始引入的，80286 没有对8086 的寄存器进行扩展，依然使用AX、BX、CX、DX、SI、DI、BP、SP，等等。所以，在16 位保护模式下，段可以起始于任何地方，但每个段的最大长度64KB，只使用16 位的偏移量。

注意，不管你用的是16 位远转移，还是32 位远转移，因为现在已经处于保护模式下，处理器都将把第一个操作数0x0008 视为段选择子，而不是实模式下的逻辑段地址。

因为处理器实际上是在保护模式下执行该指令的，因此，它会重新解释这条指令的含义。我们知道，操作数的默认大小（16 位还是32 位）是由描述符的D 位决定的，确切地说，是由段寄存器的描述符高速缓存器中的D位决定的，毕竟，要访问一个段，必须首先将它的描述符传送到段寄存器的描述符高速缓存器中。当它刚进入保护模式时，CS 的描述符高速缓存器依然保留着实模式时的内容，其D 位是“0”，因此，在那个时刻，处理器运行在16 位保护模式下。

因为处理器已经进入保护模式，所以，0x0008 不再是逻辑段地址，而是保护模式下的段描述符选择子。在前面定义GDT 的时候，它的第2 个（1 号）描述符对应着保护模式下的代码段。因此，其选择子为0x0008（索引号为1，TI 位是0，RPL 为00）。当指令执行时，处理器加载段选择器CS，从GDT 中取出相应的描述符加载到CS 描述符高速缓存。

保护模式下的代码段，基地址为0x00007c00，段界限为0x1ff，长度为0x200，正好对应着当前程序在内存中的区域。在这种情况下，上面那条指令执行时，目标位置在段内的偏移量就是标号flush 的汇编地址，处理器用它的数值来代替指令指针寄存器EIP 的原有内容。

在16 位保护模式下执行带前缀0x66 的指令，处理器会按32 位的方式执行，使用32 位的偏移量。于是，它将0x0008 加载到CS 选择器，并从GDT 中取出对应的描述符，加载CS 描述符高速缓存器；同时，把指令中给出的32 位偏移量传送到指令指针寄存器EIP。处理器就从新的位置开始取指令执行了。

从进入保护模式开始，之后的指令都应当是按32 位操作数方式编译的。因此，第53 行，使用了伪指令[bits 32]。当处理器执行到这里时，它会按32 位模式进行译码。

代码清单11-1 第56～74 行，用于把描述符选择子0x10 加载到段选择器DS，并自动加载描述符高速缓存器。因为该数据段实际上是文本模式下的显示缓冲区，故大部分指令都用于在屏幕上显示字符串“Protect mode OK”。

，在保护模式下，不允许使用mov 指令改变CS 的内容，比如：

```assembly
mov cs, ax		;导致处理器产生一个无效操作码的异常中断。
```

### 保护模式下的栈

#### 关于栈段描述符中的界限值

第77～79 行用于初始化保护模式下的栈。栈段描述符是GDT 中的第4 个（3 号）描述符，栈的32 位线性基地址是0x00000000，段界限为0x07a00，粒度为字节，属于可读可写、向下扩展的数据段。

栈是向下扩展的，描述符中的段界限，和向上扩展的段含义不同。对于向上扩展的段，段内偏移量是从0 开始递增，偏移量的最大值是界限值和粒度的乘积；而对于向下扩展的段来说，栈是从高地址向低地址方向推进的，故段内偏移量的最小值是界限值和粒度的乘积加一。在32 位代码中，是用ESP 作为栈指针的。因此，这里的段界限，用来和段粒度一起，决定ESP 寄存器所能具有的最小值。即，栈操作时，必须符合条件：

```assembly
ESP > 段界限 * 粒度值
```

在当前代码中，ESP 寄存器的内容被初始化为0x00007c00。假如此时执行以下指令：

```assembly
push edx
```

处理器先将ESP 的内容减去4，再压入数据。

```assembly
0x00007c00-4=0x00007BFC
```

段界限为0x07a00，粒度是字节，故作为栈的界限，实际使用的数值是（扩展到32 位）：

```assembly
0x07a00 * 1 = 0x000007a00
```

段界限的值加一，就是段内偏移量的最小值。要访问的段内偏移量0x00007BFC 大于实际使用的段界限值0x00007A00，处理器允许执行该操作，并用描述符高速缓存中的32 位基地址0x00000000 加上这里的偏移量0x00007BFC，共同形成32 位线性地址访问栈，将寄存器EDX 的内容压入。否则，处理器阻止当前操作，引发一个异常中断。

这是一个非常糟糕的栈定义。我们的本意是要定义一个只有512 字节的栈空间，从物理地址0x00007A00 开始，到物理地址0x00007C00 结束，如图11-14 所示。

![屏幕截图 2023-03-27 213715](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 213715.png)

假如一切正常，特别是指令执行正常，不会有什么问题。但是，在程序失控的情况下，ESP 的内容可能会是0xFFFFFFFF。即使是这样，它也是合法的值，它大于0x00007A00。因为当前栈段的线性基地址为0x00000000，所以，实际可以访问的空间是从物理地址0xFFFFFFFF 到0x00007A00。

#### 检验32 位下的栈操作

代码清单11-1 中，最后的指令用于演示保护模式下的栈操作。我们已经知道，对于存储器的段来说，其描述符的D/B 位，对于代码段来说，是D 位；对于栈段来说，是B 位。

隐式的栈操作（push、pop、call、ret 和iret）涉及两个段：一个是指令所在的代码段；另一个是指令执行时，所使用的栈段。16 位下的栈操作，其默认的操作数大小是16 位的，而且使用的栈指针寄存器是SP；32 位下的隐式栈操作，其默认的操作数大小是32 位的，使用ESP 寄存器。

在本章里，当前程序的代码段，其描述符的D 位是“1”，所以，当进行隐式的栈操作时，默认地，每次压栈操作时，压入的是双字；当前程序所使用的栈段，其符述符的B 位也是“1”，默认地，使用栈指针寄存器ESP 进行操作。为此，从第81 行开始的指令用于检验这个事实。

因此，第81 行，先保存当前栈指针的内容到EBP 寄存器；接着，第82 行，向栈中压入立即数。该立即数为字符“.”的ASCII 码，这个值是在编译阶段计算的。

当前正在执行的代码段是32 位的，其描述符的D 位是“1”，故push 指令默认的操作数大小是32 位。关键字“byte”仅仅是给编译器用的，告诉它，该指令对应的格式为push imm8，必须使用操作码0x6A，而不是用来在编译后的机器指令前添加指令前缀。因此，该指令实际在处理器上执行时，压入栈中的是一个双字，也就是4 字节，高24 位是该字节符号的扩展。

当前指令执行时，所访问的栈，其描述符的B 位也是“1”，故处理器在进行栈操作时，用的是32 位栈指针寄存器ESP。它首先将ESP 的内容减去4，再写入数值，数据保存的位置是SS:ESP。

第84～86 行，将原先保存的EBP 内容减去4，再和现行的ESP 比较，看是否相等。如果相等，则立即将刚才压入的字符出栈，并显示在前面的字符串后。不存在从栈中弹出字节的指令，因为名义上可以压入字节，但实际上它们是作为16 位或者32 位有符号数压入的。
当然，如果经过验证，EBP 和ESP 不相等，那么，将不会显示句点，直接转移到程序的最后，执行停机指令。因为现在已经禁止了中断，故除了NMI，没有任何原因会导致处理器被激活。

### 程序的运行和调试

#### 处理器刚加电时的段寄存器状态

在x86 处理器加电后，它的固件会对自身进行初始化，可选地，还可以执行一个内置的自测试（Build-In Self-Test，BIST）。如果执行了BIST，那么，当测试通过后，EAX 寄存器被清零，否则，EAX 的内容为非零。如果不执行BIST，那么，EAX 寄存器的内容默认地也是0。在这些工作完成后，才开始取指令和执行指令。

不管怎样，当处理器初始化完成后，它内部的各个寄存器，包括通用寄存器、段寄存器、控制寄存器、指令指针寄存器EIP、栈指针寄存器ESP，以及我们尚未接触过的其他寄存器，都会有一个预置的值。

要想知道处理器加电后，各个寄存器都预置了什么内容，可以选择在它执行第一条指令之前，使用调试命令来显示它们。比如，可以用“r”命令显示各个通用寄存器的初始内容。
在处理器开始执行它本次加电以来的第一条指令前，可以用“sreg”命令察看各个段寄存器此时的状态。显然，段寄存器CS 的内容是0xF000，而其他段寄存器都是0。

![屏幕截图 2023-03-27 221254](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 221254.png)

“dh”是段描述符的高32 位；“dl”是段描述符的低32 位。因为是加电预置的内容，并非来自于描述符表，所以，“dh”和“dl”的内容是Bochs 根据段寄存器描述符高速缓存器的内容构造的。
与此同时，Bochs 还根据各个段寄存器描述符高速缓存器的内容，给出了摘要信息。其中，“ Data segment ” 表示该段是数据段；“ base ” 指示段的基地址；“ limit ” 指示段的界限；“Read/Write”表示段可读写；“Accessed”指示段曾经被访问过。

8086 处理器访问内存时，是把16 位段寄存器的内容左移4 位，加上16 位偏移地址，比如

```assembly
mov ax, [0x06]
```

在32 位处理器上，每次向段寄存器传送逻辑段地址时，处理器即在段寄存器描述符高速缓存器中存放一个左移后的20 位基地址。一个典型的例子是

```assembly
mov ds, ax
```

即使在实模式下，处理器也是用段寄存器描述符高速缓存器的32 位基地址加上16 位偏移地址访问内存，只不过基地址的高12 位通常是0。当然，也有一个例外，那就是在处理器刚电加时，CS 段描述符高速缓存器中的基地址被预置为0xFFFF0000，这使得处理器取第一条指令时，地址线的高位部分被强制为“1”。又因为加电后，EIP 的预置内容是0x0000FFF0，故，处理器第一次取指令时发出的地址是0xFFFFFFF0。之所以这样做，是因为处理器的设计者希望把ROM-BIOS 放到4GB 可寻址内存范围的最高端，这样，4GB 以下，连同传统的低端1MB 都是连续的RAM 区，连续的、不间断的RAM 能为操作系统管理内存带来方便。

计算机制造商们会考虑很多现实问题。老的硬件和软件依赖于低端1MB 的ROMBIOS 来工作，这涉及到兼容性。最终，这两个地址区段都指向同一块ROM 芯片。

从图中可以看到，即将执行的第一条指令是jmp far f000:e05b（jmp 0xf000:0xe05b）。当这条指令执行后，处理器用0xF000 的值左移4 位，存放到段寄存器描述符高速缓存器。于是，处理器地址线的高位部分不再为“1”，这又转到低地址端的BIOS 执行了。如图所示，当执行远转移指令后，CS 描述符高速缓存器中的基地址变为0x000F0000，下一条指令xor ax,ax 的物理地址是0x000FE05B。

![屏幕截图 2023-03-27 221517](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 221517.png)

图中还显示了全局描述符表寄存器GDTR 的内容。很显然，GDT 的基地址是0，表界限是0xFFFF。
注意，在进入主引导程序时，这些段寄存器的内容（包括GDTR）和处理器刚加电时不再相同。原因很简单，BIOS 的加电自检程序在执行期间要进入保护模式进行测试，这将改变相关段寄存器的内容。

#### 设置PE 位后的段寄存器状态

一旦设置了控制寄存器CR0 的PE 位，处理器就进入了保护模式。但是，除非我们主动刷新段寄存器的内容，否则，段寄存器依然保持实模式下的内容不变。这就是说，设置了PE 位之后，刚进入保护模式时的段寄存器内容，就是实模式下的段寄存器内容。

如图所示，我们在执行mov cr0,eax 指令之后立即显示各个段寄存器的内容。实际上，尽管进入了保护模式，但显示的依然是实模式的内容。

从图中可以看出，代码段寄存器CS 描述符高速缓存器的dh 为0x00009300，即，G=0，D=0，L=0，P=1，DPL=00，S=1，TYPE=0011。通俗地说，这是一个粒度为字节的数据段。在实模式下，这些属性信息是没有作用的，定义成数据段也无所谓。
一旦设置了CR0 寄存器的PE 位，进入了保护模式，那么，理论上，这些属性信息就变得有用了，有意义了，但同时也是无效的。原因在于，它应当是一个代码段，而不是数据段。

![屏幕截图 2023-03-27 222928](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 222928.png)

尽管如此，这对处理器继续取指令和执行指令没有影响。原因是，在保护模式下，对描述符有效与否的检查，通常只在加载段寄存器（选择器），并刷新描述符高速缓存器的时候进行。对代码段来说，典型的例子是远转移或者远过程调用，比如

```assembly
jmp 0x0008:0x0002
```

而对于数据段来说，典型的例子是加载段选择子，比如

```assembly
mov ds, ax
```

当这类指令执行时，处理器用指令中给出的选择子找到描述符，如果描述符有效，就将选择子加载到段寄存器（选择器），并把描述符加载到描述符高速缓存器。因此，一个不合格的、无效的描述符不可能被加载到段寄存器的描述符高速缓存器。不过，当前这个情况比较特殊，因为它是进入保护模式前遗留下来的。

#### JMP 指令执行后的段寄存器状态

x86 处理器的保护模式分为两种：16 位保护模式和32 位保护模式。处理器加电、设置CR0寄存器的PE 位后，CS 描述符高速缓存器中的D 位是0，处理器根据此位将自己的状态设置为16位保护模式。

16 位保护模式和实模式相比，在指令格式和寻址方式上是相同的。因此，如果进入保护模式后的指令是16 位指令，从理论上来说不会有什么问题。实际上，因为各个段寄存器，特别是数据段寄存器中的内容并没有更新，不适当的内存访问将导致不可预知的问题。

以上所说，是解释为什么进入保护模式后，处理器还能接着往下执行的原因。问题在于，它虽然还能按原来的执行流程进行，但后面的代码是用bits 32 编译的。当处理器处在16 位保护模式时，它会按16 位的方式译码32 位指令，这是不行的。

因此，我们使用了jmp dword 0x0008:flush 指令。这是一个默认地用bits 16 编译，在16 位模式下译码，但要求按32 位执行的指令。所以，它必然具有反转操作数大小的前缀0x66。

以下是执行 jmp指令后段寄存器的内容

![屏幕截图 2023-03-27 223038](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 223038.png)

如上图的上图所示，这条远转移指令的机器码是66 EA 7E 00 00 00 08 00，在它执行后，我们又一次显示了段寄存器的状态。从图中可以看出，段寄存器CS 及其描述符高速缓存器的内容都已更新为有效内容。此后，处理器根据描述符高速缓存器的D 位（此时为“1”），把自己设置为32 位模式。

#### 察看全局描述符表GDT

可以察看全局描述符表的内容，但前提是必须加载了全局描述符表寄存器GDTR 才行，因为Bochs 要先访问GDTR 取得GDT 的基地址和界限信息。
如图所示，单步执行本章的程序，在执行指令lgdt [cs: gdt_size+0x7c00]后停下来，输入“info gdt”命令，来显示GDTR 的内容。

![屏幕截图 2023-03-27 223428](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 223428.png)

如图中所示，Bochs 给出了每个描述符的索引和相关信息。比如，它用“GDT[0x01]”表示GDT 的1 号槽位；“Code segment”表示代码段；“base”表示段的32 位基地址；“limit”表示段界限值；“Execute-Only”表示只执行；“Non-Conforming”表示非依从的；“32-bit”表示这是一个32 位的段。

#### 察看控制寄存器的内容

本章在进入保护模式前，需要设置控制寄存器CR0 的PE 位。在往后的学习过程中，有可能要察看控制寄存器的状态，这里简单做一下介绍。

如图所示，可以用命令“creg”（control register）来察看控制寄存器的内容。32 位处理器有多个控制寄存器，不单单是CR0。所以，它会显示所有控制寄存器的内容。如图中所示，CR0 的内容是0x60000010，为了方便起见，Bochs 给出了各个控制位的状态，小写表示该位是“0”，大写表示该位是“1”，即处于置位状态。显然，此时PE 位是“0”，处理器并未工作在保护模式下，这是因为指令mov cr0,eax 指令还没有执行。

![屏幕截图 2023-03-27 223747](/home/cccmmf/操作系统/x86/chap11/屏幕截图 2023-03-27 223747.png)











