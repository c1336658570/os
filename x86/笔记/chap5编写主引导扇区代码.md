## chap5编写主引导扇区代码

ROM-BIOS将主引导扇区加载到0x0000:0x7c00处，然后判断是否有效，有效的主引导扇区最后俩字节为0x55和0xAA。ROM-BIOS先检查这俩字节，如果有效就跳转到0x0000:0x7c00处继续执行。

主引导扇区将检测用来启动计算机的操作系统，并计算出它在硬盘位置。然后它把操作系统的自举代码加载到内存，然后用jmp指令跳转到那里开始执行，知道操作系统完全启动。

显示文字需要显卡和显示器，显卡负责为显示器提供内容，并控制显示器的显示模式和状态。

显卡控制显示器的最小单位是像素，先看有自己的显示存储器，简称显存。通过显存控制像素。显卡周期性的从显存取比特，并按顺序显示在屏幕上，1位亮，0为暗。黑色白色一个比特可以表示，现在最流行的是用24比特，可显示16777216种颜色。

文本模式（专门显示字符）和图形模式是显卡两种基本模式。

![屏幕截图 2023-03-06 123139](/run/media/cccmmf/Data/learn/x86/笔记/屏幕截图 2023-03-06 123139.png)

![屏幕截图 2023-03-06 123238](/home/cccmmf/操作系统/x86/笔记/屏幕截图 2023-03-06 123238.png)

可以将代码存放到显存里，第一个代码对应左上角第一个字符，以此类推。为了给出要显示的字符，处理器要访问显存，把字符的ASCII写进去。显存是外设，访问显存需要和外设打交道，太慢了。把显存直接映射到内存中解决此问题。

![屏幕截图 2023-03-06 123528](/home/cccmmf/操作系统/x86/笔记/屏幕截图 2023-03-06 123528.png)

段寄存器只能用通用寄存器或内存单元进行赋值

mov 段寄存器，通用寄存器

mov 段寄存器，内存单元

![屏幕截图 2023-03-06 130050](/home/cccmmf/操作系统/x86/笔记/屏幕截图 2023-03-06 130050.png)

mov byte[0x00], 'L'  默认为DS寄存器左移4位加上给的偏移0x00找到内存单元，将L放进去

mov byte[es:0x00],'L' 显示给出段寄存器，es左移4位加上偏移0x00找到内存单元 ，将L放进去

mov 操作中包含寄存器不需要byte或者，word，没有寄存器时需要。

mov [0x00], al

mov ah, 0x5

mov word [0x1c], 0xf000

mov ax, bl 错误，寄存器大小不一样

mov的目的操作数不允许为立即数，源操作数和目的操作数不能同时为内存单元。

mov 0x1c, al 错误

mov [0x01], [0x02] 错误，可用两条命令实现

mov ax, [0x02]

mov [0x01], ax

不止mov指令，其他指令都不支持在俩内存单元之间操作，包括加减乘除和逻辑运算等指令。

![屏幕截图 2023-03-06 135740](/home/cccmmf/操作系统/x86/笔记/屏幕截图 2023-03-06 135740.png)

编译时生成汇编地址，即指令在代码中的偏移，程序加载到内存时汇编地址等于段内偏移，段内偏移地址和汇编地址一一对应

可以使用标号代表一个地址，该地址是汇编地址，也是程序加载到内存后的段内偏移地址，不需要我们计算该地址到底是多少，编译时编译器会计算

infi: jmp near infi

infi jmp near infi

infi:

​	jmp near infi

三种写法都对

标号可由字母、数字、"_ "、"$"、"#"、"@"、"~"、"."、"?"组成，必须以字母、"."、" _ "、"?"开头



数据需要用db指令来声明，db意思是声明字节，dw用于声明字数据，dd用于声明双字数据，dq用于声明四字数据，都为伪指令。

8086提供了除法指令div,它可以进行两种除法

第一种类型是用16位的二进制数除以8位的二进制数。在这种情况下被除数必须在AX中。除数可以由8位通用寄存器或内存单元提供。执行指令后商在AL中，余数在AH中。

div cl

div byte [0x0023]

只要在指令中涉及内存地址，都允许使用段超越前缀。比如：

div byte [cs:0x0023]

div byte [es:0x0023]

在源程序中通常不知道汇编地址的具体数值，只能使用标号。

dividnd dw 0x3f0

divisor db 0x3f

......

mov ax, [dividnd]

div byte [divisor]

声明了标号dividnd并初始化了一个字0x3f0作为被除数，然后又声明了标号divisor并初始化一个字节0x3f作为除数。

第二种类型是用32位的二进制数除以16位的二进制数。高16位在DX中，低16位在AX中。通常用DX:AX描述32位被除数。除数可以由16位通用寄存器或者内存单元提供，商在AX中，余数在DX中，如下指令：

div cx

div word [0x0230]

xor指令的目的操作数可以是通用寄存器和内存单元，源操作数可以是通用寄存器、内存单元和立即数（不允许俩操作数都为内存单元）。

xor al, 0x55

xor cl, [0x2000]

xor bl, dl

xor ax, 0xf033

xor bx, [0x2002]

xor dx, bx

xor byte [0x3000], 0xf0

xor [0x06], al

xor word [0x2002], 0x55aa

xor [0x20], dx



mov ax, 0000_0000_0000_0010B

xor ax, 1111_0000_1111_0001B

AX = 1111_0000_1111_0011B，即0xf0f3

俩条指令的操作数都是用二进制表示的，nasm允许下划线分开它们



add是加法指令，需要俩操作数，目的操作数可以是8位或者16位通用寄存器，或者指向8位或16位的内存地址，源操作数是相同宽度的8位或者16位通用寄存器、指向8位或者16位实际操作数的内存地址，或者立即数。不允许俩操作数都是内存单元。

add al, cl

add ax, 0x123f

add [label_a], cx

add ax, [label_a]

add byte [label_a], 0x08



jmp是转移指令，用于使计算机转到指定的地方执行，关键字near表示目标位置依然在当前代码段内。

处理器取指令、执行指令依靠CS和IP，8086将CS左移4位加上IP形成20位物理地址，取得指令然后执行，同时把IP的内容加上当前指令长度，指向下一条指令的偏移地址。

jmp指令有多种形式，一种是绝对地址，操作数直接给出段地址和偏移地址

jmp 0x5000:0xf0c0，指令操作码为0xEA，机器指令为EA C0 F0 00 50

处理器执行时发现操作码为EA，然后将指令中的段地址加载到CS中，将偏移地址加载到IP中，转移到目的地址继续执行。

jmp near leabl

三字节地址，操作码位0xE9，后跟一个两字节操作数。但是该操作数并非目标位置的偏移地址，而是目标位置相对当前指令的偏移量（字节为单位）。用标号（目标位置）处的汇编地址减去当前指令的汇编地址再减去当前指令的长度。

关键字near仅仅用于指示相对量是16位的。

在执行jmp near label阶段，处理器用IP的内容加上该指令的操作数加上该指令长度就得到了要转移的实际偏移地址。

伪指令times用于重复它后面的指令若干次
times 20 mov ax, bx

times 203 db 0 将会在编译时保留203个字节

<img src="/home/cccmmf/操作系统/x86/笔记/屏幕截图 2023-03-08 182300.png" alt="屏幕截图 2023-03-08 182300" style="zoom:80%;" />

bochs使用

s单步调试

b 0x7c00 打断点

c执行到断点处停止

r显示寄存器内容

bochs汇编显示和nasm略有不同

mov byte ptr es:0x0,0x4c等价于mov byte [es:0x0], 'L'，即mov byte [es:0x0], 0x4c

sreg 显示一堆内容，除了显示段寄存器CS,DS,SS,ES外，还多了FS和GS，在32位和64位处理器中，以上寄存器还是16位，但是增加了不可访问部分，叫做段描述符高速缓存器。他在处理器内部使用，不能在程序中访问，里面存放了段的起始地址、段的拓展范围，以及段和各种属性，比如它是代码段还是数据段，是否可写入，是否被访问过等。

xp（eXamine memory at Physical address），即，显示指定物理内存地址处的内容。xp每次只显示一个双字。显示更多双字需要用"/"附加一个数量，然后还应制定一个物理内存地址。

使用案例

xp

xp 0xb8000

 xp /2 0xb8000
