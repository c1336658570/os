初始化内核代码

以下是对kernel执行的操作

```bash
gcc -c -o kernel/main.o kernel/main.c -m32
file kernel/main.o
nm kernel/main.o
ld kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin -melf_i386
```



使用gcc -c -o kernel/main.o kernel/main.c -m32编译mian.c，将其编译为ELF32
经过上面 gcc 的编译后，我们得到了 main.o 文件，目前为止，它还是个“半成品”。为什么这么说呢？因为它只是个目标文件，也称为待重定位文件，重定位指的是文件里面所用的符号还没有安排地址，这些符号的地址需要将来与其他目标文件“组成”一个可执行文件时再重新定位（编排地址），这里的符号就是指该目标文件中所调用的函数或使用的变量，而这里的“组成”就是指链接。这些符号一般是位于其他文件中，所以在编译时不能确定其地址，需要在所有目标文件都到齐了，将它们链接到一起时再重新定位（编排地址）。由于不知道可执行文件由几个目标文件组成，所以一律在链接阶段对符号重新定位（编排地址）。所以说，哪怕是可执行文件只是由一个文件组成的，其目标文件中的符号也是未编址的，编址工作，即重定位，一律统一在链接阶段完成。
使用file kernel/main.o查看main.o的状态
其中有一个为relocatable代表这是一个可重定为目标文件，其中的符号都尚未“定位”，也就是符号（变量名，函数名）的地址尚未确定，这一点我们可以用 Linux 的 nm 命令来查看nm kernel/main.o

在 Linux 下用于链接的程序是 ld，链接有一个好处，可以指定最终生成的可执行文件的起始虚拟地址。它是用-Ttext 参数来指定的，所以咱们可以执行以下命令完成链接。
ld kernel/main.o -Ttext 0xc0001500 -e main -o kernel/kernel.bin -melf_i386

-Ttext 指定起始虚拟地址为 0xc0001500，这个地址是设计好的，为什么用这个地址，咱们将来在加载内核时会告诉大家，在此大伙儿先淡定一下。其中–o 的意义也是指定输出的文件名，至于-e，还是要看一下官方帮助。

ld –help 回车后，输出的信息太多，咱们只看下面的-e 参数。
-e ADDRESS, --entry ADDRESS Set start address
-e 和--entry 一样，字面上的意思是用来指定程序的起始地址。注意，不要被迷惑了，虽然说是指定起始地址，但参数不仅可以是数字形式的地址，而且可以是符号名，这和汇编中的标号也是地址是一样的道理。总之它用来指定程序从哪里开始执行。

不加-e 参数试试，如下：

ld kernel/main.o -Ttext 0xc0001500  -o kernel/kernel.bin -melf_i386 21:06:29
ld: 警告: 无法找到项目符号 _start; 缺省为 00000000c0001500

ld 报错发出了警告，提示找不到入口符号（entry symbol）_start，默认地址为00000000c0001500。这个_start 是什么呢？

一个程序总该有个入口地址，这个地址表示的是程序将从哪里开始执行。要知道，并不是程序体中的第一个字节就是程序的起始地址，因为在程序的开头可能有函数声明或数据定义，想想咱们的汇编文件 loader.S，它最前面的部分可不是指令，而是一堆数据，而我们在设计它的时候，知道它的入口地址不在程序开始处，所以在mbr 中直接跳入了 loader.S 的 loader_start 标号处，跨过了程序开头的数据部分。这还仅仅是由一个 loader.S 生成loader.bin，并且是我们提前知道入口地址的情况，如果当多个文件拼合成一个可执行文件时，计算机如何知道程序的入口在哪里呢？也就编译后的程序应该从哪句代码开始执行呢？这入口代码可说不准是哪一个了。由于程序内的地址是在链接阶段编排（也就是重定位）的，所以在链接阶段必须要明确入口地址才行，于是链接器规定，默认只把名为_start 的函数作为程序的入口地址，即默认的 entry symbol 是_start，除非另行指定。

既然缺少_start 符号，那现在把主函数 main 改成_start 试试，代码如下。

```c
//int main(void) {
int _start(void) {
while(1);
return 0;
}
```

```bash
gcc -c -o kernel/main.o kernel/main.c -m32
ld kernel/main.o -Ttext 0xc0001500 -o kernel/kernel.bin -melf_i386
file kernel/kernel.bin
```

编译链接一气呵成，整个过程没出任何问题。

用 file 命令查看了最终生成的 kernel.bin 文件，它已经是 executable 啦

这里写一个_start 函数，让其调用 main 函数如何？其实这是可以的，main 函数并不是第一个函数，它实际上也是被别人调用的，不过这是编译器背后的策略啦。

虽然把函数名改成_start 可以解决问题，但我们习惯于 main 函数作为主函数，不习惯函数用_start，于是用了-e 来指定起始的函数名为 main。

