# 保护模式进阶，向内核迈进

## 获取物理内存容量

### 学习 Linux 获取内存的方法

通过调用 BIOS 中断 0x15 实现的，分别是 BIOS 中断 0x15 的 3 个子功能

- EAX=0xE820：遍历主机上全部内存。
- AX=0xE801： 分别检测低 15MB 和 16MB～4GB 的内存，最大支持4GB。
- AH=0x88：最多检测出 64MB 内存，实际内存超过此容量也按照 64MB 返回。

### 利用 BIOS 中断 0x15 子功能 0xe820 获取内存

BIOS 中断 0x15 的子功能 0xE820 能够获取系统的内存布局，由于系统内存各部分的类型属性不同，BIOS 就按照类型属性来划分这片系统内存，所以这种查询呈迭代式，每次 BIOS 只返回一种类型的内存信息，直到将所有内存类型返回完毕。子功能 0xE820返回的内存信息较丰富，包括多个属性字段，所以需要一种格式结构来组织这些数据。内存信息的内容是用地址范围描述符来描述的，用于存储这种描述符的结构称之为地址范围描述符（Address Range Descriptor Structure，ARDS）。

![截图 2023-06-16 18-39-48](/home/cccmmf/操作系统/操作系统真象还原/chap5/note/截图 2023-06-16 18-39-48.png)

此结构中的字段大小都是 4 字节，共 5 个字段，所以此结构大小为 20 字节。每次 int 0x15 之后，BIOS就返回这样一个结构的数据。

Type 字段用来描述这段内存的类型，这里所谓的类型是说明这段内存的用途，即其是可以被操作系统使用，还是保留起来不能用。

![截图 2023-06-16 18-41-38](/home/cccmmf/操作系统/操作系统真象还原/chap5/note/截图 2023-06-16 18-41-38.png)

为什么 BIOS 会按类型来返回内存信息呢？原因是这段内存可能是。

- 系统的 ROM。
- ROM 用到了这部分内存。
- 设备内存映射到了这部分内存。
- 由于某种原因，这段内存不适合标准设备使用。

![截图 2023-06-16 18-44-47](/home/cccmmf/操作系统/操作系统真象还原/chap5/note/截图 2023-06-16 18-44-47.png)

![截图 2023-06-16 18-45-07](/home/cccmmf/操作系统/操作系统真象还原/chap5/note/截图 2023-06-16 18-45-07.png)

此中断的调用步骤如下。
（1）填写好“调用前输入”中列出的寄存器。
（2）执行中断调用 int 0x15。
（3）在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

### 利用 BIOS 中断 0x15 子功能 0xe801 获取内存

低于 15MB 的内存以 1KB 为单位大小来记录，单位数量在寄存器 AX 和 CX 中记录，其中 AX 和 CX 的值是一样的，所以在 15MB 空间以下的实际内存容量=AX*1024。AX、CX 最大值为 0x3c00，即 0x3c00*1024=15MB。16MB～4GB 是以 64KB 为单位大小来记录的，单位数量在寄存器 BX 和 DX 中记录，其中 BX 和 DX 的值是一样的，所以 16MB 以上空间的内存实际大小=BX*64*1024

![截图 2023-06-16 18-52-10](/home/cccmmf/操作系统/操作系统真象还原/chap5/note/截图 2023-06-16 18-52-10.png)

和表 5-3 相比，表 5-4 多了“用途”列，而且是英文，中断返回后，AX 和 CX 中，其值的单位是 1KB，而 BX 和 DX 的单位是 64KB。

（1）为什么要分“前 15MB”和“16MB 以上”这两部分来展示 4GB 内存？
（2）为什么寄存器结果是重复的？如寄存器 AX 和 CX 相等，BX 和 DX 相等？
为了解决第 1 个问题，让我们实际测试下，让事实说话。测试方法是修改 bochs 配置文件 bochsrc.disk中的内存容量参数 megs，然后执行 BIOS 中断。测试结果见表 5-5。

![截图 2023-06-16 18-54-54](/home/cccmmf/操作系统/操作系统真象还原/chap5/note/截图 2023-06-16 18-54-54.png)

“实际物理内存”和“检测到的内存大小”，它们之间总是差 1MB，言外之意是总有 1MB内存不可用。这是怎么回事？

80286 拥有 24 位地址线，其寻址空间是 16MB。
当时有一些 ISA 设备要用到地址 15MB 以上的内存作为缓冲区，也就是此缓冲区为 1MB 大小，所以硬件系统就把这部分内存保留下来，操作系统不可以用此段内存空间。保留的这部分内存区域就像不可以访问的黑洞，这就成了内存空洞 memory hole。现在虽然很少很少能碰到这些老 ISA 设备了，但为了兼容，这部分空间还是保留下来，只不过是通过 BIOS 选项的方式由用户自己选择是否开启。BIOS 厂商不同，一般的菜单选项名称也不相同，不过大概意思都差不多。比如咱们开机进入 BIOS 界面后，会有类似这样的选项：

memory hole at address 15m-16m

将此选项设为 enable 或 disable 便开启或关闭对这类扩展 ISA 设备的支持。

如果检测到的内存容量大于等于 16MB，BIOS 0x15 中断返回的结果中，AX * 1024 必然是小于等于15MB，而 BX*64*1024 肯定大于 0。所以，内存容量分成两部分展示，只要符合这两个结果，就能检查出内存空洞。当然如果物理内存在 16MB 以下，此方法就不灵了，但检测到的内存依然会小于实际内存
1MB。所以实际的物理内存大小，在检测结果的基础上一定要加上 1MB。

至于第 2 个疑问，它们似乎是相同的，BIOS 就是这样说的。

此中断的调用步骤如下。
（1）将 AX 寄存器写入 0xE801。
（2）执行中断调用 int 0x15。
（3）在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

### 利用 BIOS 中断 0x15 子功能 0x88 获取内存

该方法使用最简单，但功能也最简单，简单到只能识别最大 64MB 的内存。即使内存容量大于 64MB，也只会显示 63MB，为什么只显示到 63MB 呢？因为此中断只会显示 1MB 之上的内存，不包括这 1MB，在使用的时候记得加上 1MB。

![截图 2023-06-16 19-05-32](/home/cccmmf/操作系统/操作系统真象还原/chap5/note/截图 2023-06-16 19-05-32.png)

中断返回后，AX 寄存器中的值，其单位是 1KB。此中断的调用步骤如下。
（1）将 AX 寄存器写入 0x88。
（2）执行中断调用 int 0x15。
（3）在 CF 位为 0 的情况下，“返回后输出”中对应的寄存器便会有对应的结果。

### 实战内存容量检测

本代码第 28 行定义了 4 字节的变量 total_mem_bytes，此变量用于存储获取到的内存容量，以字节为单位。也是啊，经过千辛万苦才获取到的内存大小当然要赶紧找个地方藏起来了，哈哈，有点夸张了，总之先存起来留着以后用。
在 total_mem_bytes 定义的地方上面有几行注释，阐述了 total_mem_bytes 的地址是 0xb00。理由是它前面有 4 个段描述符的定义，还有预留 60 个段描述槽位 times 60 dq 0。段描述符大小是 8 字节，dq 也是 8 字节，所以偏移量是 (4+60)*8=512=0x200 字节。本程序的加载地址是 0x900，0x900+0x200=0xb00，所以 0xb00便是变量 total_mem_bytes 加载到内存中的地址。将来在内核中实现内存分配系统时还会用到此地址。

第 35～37 行是提前定义的缓冲区，为的是存储 BIOS 0x15 中断 0xe820 子功能返回的 ARDS 结构。每执行该中断一次便会得到一个 ARDS 结构的数据，按理说缓冲区的大小等于 ARDS 结构的大小就行了，但为了编程省事，处理的思路是将所有 ARDS 都得到后再统一遍历，所以我们就申请个大一些的缓冲区。缓冲区地址是 ards_buf，但缓冲区大小是多少合适呢？已知一个 ARDS 结构是 20 字节，具体多大取决于到底会有多少个 ARDS 结构。所以先估计个数吧，不够了再加（在本机实际测试中共返回了 6 个 ARDS 结构）。在这里先为其分配 244 字节，哈哈，有点奇怪是不，为什么有零有整的？这是为了手工对齐下面 39 行的标签 loader_start，使其在文件内的偏移地址为 0x300。这纯属个人喜好，就是想凑个整数，显得好看。您看，total_mem_bytes
是 4 字节，gdt_ptr 是 6 字节，ards_buf 是 244 字节，ards_nr 是 2 字节，加起来的和是 256 字节，即 0x100。加上 total_mem_bytes 在文件内偏移地址是 0x200，所以 loader_start 在文件内的偏移地址是0x100+0x200=0x300。代码“ards_buf times”的大小是 244 字节纯粹是凑出来的，无实际意义，哈哈，这属于传说中的强迫症行为。

上一版本 loader.S（project/c4/a/boot/loader.S）中第 4 行的代码是 jmp loader_start，上一版本 mbr.S（project/c4/a/boot/mbr.S）的第 55 行是跳转指令 jmp LOADER_BASE_ADDR，经过这两个跳转才执行到loader_start 处的代码。在本节版本中，loader_start 是 loader.S 中第一条指令的起始地址，那个跳转指令没有了。所以，在本节主引导记录程序 mbr.S 中的跳转指令已经变成了 jmp LOADER_BASE_ADDR + 0x300，多加了个 0x300 字节，跨过前面的数据部分，直接跳到 loader_start。之所以这样做，是为对齐代码，因为在程序开头加个跳转指令，其机器码要占用 3 字节空间，原本在它之后定义的数据，其地址未对齐到偶数，这会影响硬件执行的速度。而且，将来在内核中引用 total_mem_bytes 的地址时也要用个奇数，感觉很别扭。

从代码的第 41 行开始，采用 BIOS 中断 0x15 的三种子功能来检测内存。在检测内存时，必然是先使用功能最全、检测功能最强大的方法，功能最弱的、检测能力有限的方法应该是在“万般无奈”下才用，要放在最后，以避免无法检测出真实的内存容量。从强到弱的子方法依次是 0xe820、0xe801、0x88。

第 41～69 行用的子功能 0xe820 方法。此方法需要提前准备好一块数据缓冲区用于存放返回的 ARDS结构，此缓冲区我们在上面已经准备好了，就是 ards_buf。按照 0xe820 的调用方法，es：di 存放缓冲区地址，由于 es 在 mbr 中已经赋值了，所以在第 47 行“mov di, ards_buf”，只为 di 赋值便可。

每执行一次 int 0x15 后，寄存器 eax、ebx、ecx 都会更新。eax 的值由之前的子功能号变成了字符串 SMAP的 ASCII 码，ebx 为新的后续值，ecx 为实际写入缓冲区中的字节数。其中 ebx 咱们不用干涉，原方不动地作为输入即可。eax 和 ecx 寄存器每次调用前都要更新为正确的输入参数，所以放在了循环体中。接下来每得到一个ARDS 结构后，便将 di 增加一个 ARDS 结构大小（这里是 20 字节），以指向缓冲区中的下一个 ARDS 存放的位置，然后将变量 ards_nr 加 1，以记录 ARDS 的个数，用于在后面的代码中遍历所有 ARDS，找出最大内存块。

第 56～69 行是找出最大的内存块。思路是对每一个 ARDS 结构中的 BaseAddrLow 与 LengthLow 相加求和，遍历完所有 ARDS，值最大的则为内存容量，由于 BaseAddrLow+LengthLow 的单位是字节而无需转换，之后便
直接跳转到.mem_get_ok，将此容量数写入变量 total_mem_bytes，具体代码为第 113 行的 mov [total_mem_bytes],edx。在此说明下，三种方法探测到的内存容量都是统一跳转到.mem_get_ok 处后以字节形式写入到变量total_mem_bytes，所以三种方法中内存容量都要用 edx 来保存。

第 71～95 行是利用子功能 0xe801 探测内存容量。由于方法本身比较简单，所以代码量很短。在 76行执行中断后，第 79～86 行先计算出低 15MB 内存空间的容量。这里面用到了乘法指令 mul，在 16 位乘法中，由于 mul 指令固定的乘数是寄存器 AX，所以只给提供另一个乘数就行了，于是乘法指令格式是mul 16 位内存或 16 位寄存器。结果（积）是 32 位，高 16 在 DX 寄存器，低 16 位在 AX 寄存器。

由于寄存器 AX 和 CX 的单位是 KB，这里要将获得的结果转换成字节，所以寄存器 AX 或 CX 要乘以 1024。前面说过啦，寄存器 AX 和 CX 值相同，随便用哪个做乘数皆可，由于固定的操作数 AX，所以把 CX 的值覆盖为 0x400，即 1024。这里用的是 16 位操作数乘法，积的高 16 位在 DX 寄存器，低 16 位
在 AX 寄存器。所以将 EDX 左移 16 位后再与 AX 做或运算便得到了完整 32 位的积。在第 85 行将 edx 加了 1MB，原因是获取到的内存总比实际大小少 1MB，故在此“补偿”。后面的乘法指令会破坏寄存器 EDX的值，所以第 86 行将结果备份到寄存器 ESI。

第 88～95 行是计算 16MB 之上的内存容量，结果存放在寄存器 BX 和 DX，单位是 64KB，所以也要将其转换为字节。这里面用到了 32 位操作数的乘法，32 位乘法固定的乘数是 EAX，同样也是再提供一个操作数就行了。所以其指令格式为 mul 32 位内存或 32 位寄存器。积为 64 位结果，高 32 位在 EDX 寄存器，低 32 位在 EAX 寄存器。第 90 行用寄存器 BX 初始化 EAX 寄存器的低 16 位 AX（EAX 的高 16 位已经由 xor eax，eax清 0），EAX 为固定的乘数，另一个乘数是 0x10000，即 64KB。由于 0xe801 子功能只能测出 4GB 之内的内存容量，所以只需要乘积的低 32 位结果，也就是寄存器 EAX 的值就够了，最后再将备份在寄存器 ESI 中的低15MB 空间的内存容量同 EAX 相加，存入变量 total_mem_bytes 中。

第 98～110 行是用子功能 0x88 方法探测内存容量，功能简单，代码更简单。

方法说完了，该是实际运行检测的时候了。虽然内存容量检测出来了，但代码中并没有将它显示出来，原因是我们将很快实现打印函数了，这里就不先“凑合”打印了。不过我们依然能够在 bochs 中检验结果，大家肯定都想到了，对，就是通过调试手段来查看变量 total_mem_bytes 的内存就行啦。事不宜迟，我们看一下实际运行情况吧。

变量 total_mem_bytes 的地址是 0xb00，所以咱们在 bochs 控制台中用 xp 指令来查看该地址就行了，说干就干，先用 Ctrl+C 组合键中断 bochs 的运行，再输入命令 xp 0xb00 回车。







































