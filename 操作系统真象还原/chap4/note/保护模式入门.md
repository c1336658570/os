# 保护模式入门

## 保护模式概述

### 为什么要有保护模式

幸福是比出来的，这一点不假。让我们看看 CPU 实模式的不幸，大家就清楚保护模式的幸福了。
（1）实模式下操作系统和用户程序属于同一特权级，这哥俩平起平坐，没有区别对待。
（2）用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地指哪打哪。
（3）用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住。

（4）访问超过 64KB 的内存区域时要切换段基址，转来转去容易晕乎。
（5）一次只能运行一个程序，无法充分利用计算机资源。
（6）共 20 条地址线，最大可用内存为 1MB，这即使在 20 年前也不够用。

## 初见保护模式

![截图 2023-06-12 19-18-58](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 19-18-58.png)

下面列出三种段描述符缓冲寄存器结构（段描述符缓冲寄存器和段寄存器在一起）

![截图 2023-06-12 19-28-27](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 19-28-27.png)

80286 虽然有了保护模式，但其依然是 16 位的 CPU，其通用寄存器还是 16 位宽。但其与 8086 不同的是其地址线由 20 位变为了 24 位，即寻址空间变成了 2 的 24 次方，等于 16MB 大小。

### 保护模式之寻址扩展

实模式下对于内存寻址来说，其中的基址寻址、变址寻址、基址变址寻址，这三种形式中的基址寄存器只能是 bx、bp，变址寄存器只能是 si、di。其中 bx 默认的段寄存器是 ds，它经常用于访问数据段，bp默认的段寄存器是 ss，它经常用于访问栈。对于寻址中的偏移量，只能是 1 个字以内的立即数，即不能超过 16 位。

在保护模式下，同样是内存寻址中，基址寄存器不再只是 bx、bp，而是所有 32 位的通用寄存器，变址寄存器也是一样，不再只是 si、di，而是除 esp 之外的所有 32 位通用寄存器，偏移量由实模式的 16 位变成了 32 位。并且，还可以对变址寄存器乘以一个比例因子，注意比例因子，只能是 1、2、4、8，如图 4-4 所示。

### ![截图 2023-06-12 19-39-32](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 19-39-32.png)保护模式之运行模式反转

![截图 2023-06-12 19-41-31](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 19-41-31.png)

第 3 个字段用于指定寻址方式和操作数类型，在指令格式不变的情况下，为了兼容保护模式，一种方案是重新定义各寻址方式、寄存器的编码。由于保护模式中的寻址方式和操作数类型同实模式下完全不同，故相应的编码也不同。比如在实模式下，用二进制 010 表示 dx 寄存器，在保护模式下的010 就表示 edx 寄存器（根据编码确定指令、寻址方式、寄存器，这是译码器的工作）。操作 dx 寄存器和edx 寄存器，对于硬件来说是完全不同的，所以编译器必须明确操作对象是哪个。

在实模式下，指令和操作数都是 16 位的，但我们也说过啦，它可以使用 32 位的资源。同样在保护模式下，指令和操作数都是 32 位的，它也可以使用 16 位的资源。

兼容性带来了好处，也带来了坏处，好处是 CPU 很强大，可以同时支持 16 位指令和 32 位指令，运行新老程序畅通无阻。但坏处就是 CPU 也不知道您想生成 16 位，还是 32 位机器码，需要明确告诉编译器一些信息。为此，编译器提供了伪指令 bits，用它来向编译器传达：我下面的指令都要编译成 xx位的，因为我知道下面的代码的运行环境是 xx 模式。

bits 的指令格式是[bits 16]或[bits 32]。
[bits 16]是告诉编译器，下面的代码帮我编译成 16 位的机器码。
[bits 32]是告诉编译器，下面的代码帮我编译成 32 位的机器码。

bits 外面的中括号是可以省略的，另外，在未使用 bits 指令的地方，默认是[bits 16]。

进入保护模式需要三个步骤。
（1）打开 A20。
（2）加载 gdt。
（3）将 cr0 的 pe 位置 1。

在指令格式中，有个“前缀”字段，里面存放的是指令选项之类的东东，比如指令重复前缀 rep、段跨越前缀“段寄存器：”，还有咱们马上要介绍的操作数反转前缀 0x66 和寻址方式反转前缀 0x67。

在不同的模式下，操作数和寻址方式都各不相同。实模式下的操作数大小是 16 位，保护模式下的操作数大小是 32 位。

16 位实模式下可以用 32 位保护模式下的寄存器。但这种福利的得来却是稍费功夫的，如果要用另一模式下的操作数大小，需要在指令前添加指令前缀 0x66，将当前模式临时改变成另一模式。这就是反转的意义，不管是当前模式是什么，总是转变成相反的运行模式。

比如，在指令中添加了 0x66 反转前缀之后：
假设当前运行模式是 16 位实模式，操作数大小将变为 32 位。
假设当前运行模式是 32 位保护模式，操作数大小将变为 16 位。
注意啦，这个转换只是临时的，只在当前指令有效。

下面再介绍个前缀：寻址方式反转前缀 0x67。

不同模式之间不仅可以使用对方模式下的操作数，还可以使用对方模式下的寻址方式。

```assembly
[bits 16]
mov word [bx], 0x1234		;C7073412
mov word [eax], 0x1234		;67C7003412
;eax 寄存器作为基址寻址，并且用到了伪指令 dword，表示在 eax 所表示的内存处，连续写入 4 字节大小的数据。操作数大小也由默认的 2 字节变成了 4 字节，就会添加 0x66 的前缀。所以其机器码是 6667C70034120000，前面 2 字节是前缀 0x66、0x67。
mov dword [eax], 0x1234		;6667C70034120000
[bits32]
mov dword [eax], 0x1234		;C70034120000
;在本行代码中表示从 eax 指定的内存处连续写入 2 字节。这就改变了操作数的大小，当前已经是 32 位机器码了，默认操作数也是 32 位，所以要用操作数大小反转前缀 0x66，见机器码第 1 字节。
mov word [eax], 0x1234		;66C7003412
;实模式下的基址寻址，寄存器是 bx（只能是 bx 或 bp），但由于当前是 32 位保护模式，所以在机器码中要用寻址方式反转前缀 0x67。
mov dword [bx], 0x1234		;67C70734120000
```

bits 伪指令用于指定运行模式，操作数大小反转前缀 0x66 和寻址方式反转前缀 0x67，用于临时将当前运行模式下的操作数大小和寻址方式转变成另外一种模式下的操作数大小及寻址方式。

### 保护模式之指令扩展

add，sub等指令不仅要支持 8 位、16 位，还得支持 32 位的操作数。以上说的是双操作数的指令，还有一些单操作数指令，如 inc、dec 等，也是同时支持 8 位、16 位、32 位寄存器。对于 loop 指令，实模式下要用 cx 寄存器来
存储循环次数，在保护模式下，要用 ecx。

mul 指令是无符号数相乘指令，指令格式是 mul 寄存器/内存。
其中“寄存器/内存”是乘数。
如果乘数是 8 位，则把寄存器 al 当作另一个乘数，结果便是 16 位，存入寄存器 ax。
如果乘数是 16 位，则把寄存器 ax 当作另一个乘数，结果便是 32 位，存入寄存器 eax。
如果乘数是 32 位，则把寄存器 eax 当作另一个乘数，结果便是 64 位，存入 edx：eax，其中 edx 是积的高 32 位，eax 是积的低 32 位。

有符号数相乘指令 imul 也是一样。

对于无符号数除法指令 div，其格式是 div 寄存器/内存，其中的“寄存器/内存”是除法计算中的除数。
如果除数是 8 位，被除数就是 16 位，位于寄存器 ax。所得的结果，商在寄存器 al，余数在寄存器 ah。
如果除数是 16 位，被除数就是 32 位，被除数的高 16 位则位于寄存器 dx，被除数的低 16 位则位于
寄存器 ax。所得的结果，商在寄存器 ax，余数在寄存器 dx。
如果除数是 32 位，被除数就是 64 位，被除数的高 32 位则位于寄存器 edx，被除数的低 32 位则位于寄存器 eax，所得的结果，商在寄存器 eax，余数在寄存器 edx。

在 16 位的实模式下，CPU照样可以处理 32 位的数据，大家不要感到奇怪。最典型的例子就是 push，这是往栈中添加数据的指令。同样的指令，在实模式和保护模式下都可以同时处理 16 位和 32 位的数据，让咱们看看 push 是怎样应对这两种局面的。

对于 push 指令，需要根据其操作数的类型，分别讨论，操作数类型如下。
（1）立即数。
（2）寄存器。
（3）内存。
下面咱们看看各方面的内容。
先看第 1 种情况，对于立即数来说，可以分别压入 8 位、16 位、32 位数据。
指令格式是：
push 8 位立即数
push 16 位立即数
push 32 位立即数
虽说可以压入 8 位立即数，但实际上，对于 CPU 来说，出于对齐的考虑，操作数要么是 16 位，要么是 32 位，所以 8 位立即数会被扩展成各模式下的默认操作数宽度，即实模式下 8 位立即数扩展成为 16 位后再入栈，保护模式下扩展成为 32 位后再入栈。

在实模式环境下：
当压入 8 位立即数时，由于实模式下默认操作数是 16 位，CPU 会将其扩展为 16 位后再将其入栈，sp-2。当压入 16 位立即数时，CPU 会将其直接入栈，sp-2。当压入 32 位立即数时，CPU 会将其直接入栈，sp-4。

```assembly
;                   下一条指令机器码    当前esp值
section loader vstart=0x900
mov sp,0x900        ;bc0009           0x00007c00
push byte 0x7       ;6a07             0x00000900
push word 0x8       ;6a08             0x000008fe  0x900-0x8fe=2
;该指令66是操作数反转前缀，将当前的默认操作数反转成32位
push dword 0x90     ;666a09           0x000008fc  0x8fe-0x8fc=2
jmp $               ;ebfe             0x000008f8  0x8fc-0x8f8=4
```



在保护模式下，同样是这些压入立即数的指令，栈指针会有怎样的变化呢？
当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp 指针减 4。
当压入 16 位立即数时，CPU 直接压入 2 字节，esp 指针减 2。
当压入 32 位立即数时，CPU 直接压入 4 字节，esp 指针减 4。

```assembly
;                    下一条的指令的机器码    当前 esp 值
   push byte 0x7  ;  6a07                 0x00000900
   ;word 是伪指令，表示2字节大小的数据类型，66是反转操作数前缀,这是操作数大小反转前缀。
   ;编译器添加此反转前缀的原因是在32位下的操作数是4字节，此处要压入2字节，
   ;这是16位模式下的操作数尺寸。
   push word 0x8  ;  666a08               0x000008fc  0x900-0x8fc=4
   push dword 0x9 ;  6a09                 0x000008fa  0x8fc-0x8fa=2

   jmp $          ;  ebfe                 0x000008f6  0x8fa-0x8f6=4
```



对于段寄存器的入栈，即 cs、ds、es、fs、gs、ss，无论在哪种模式下，都是按当前模式的默认操作数大小压入的。例如，在 16 位模式下，CPU 直接压入 2 字节，栈指针 sp 减 2。在 32 位模式下，CPU 直接压入 4 字节，栈指针 esp 减 4。

```assembly
;实模式下压入段寄存器
;           下一条指令的机器码    当前esp值
section loader vstart=0x900
mov sp,0x900    ;以下sp均减2
push cs  ;  0x0e                0x900 
push ds  ;  0x1e                0x8fe
push es  ;  0x06                0x8fc
jmp $    ;  0xebfe              0x8fa
```

```assembly
section loader vstart=0x900
mov sp,0x900
push cs        ;  0x0e                 0x900
push ds        ;  0x1e  0x             0x8fc
push es        ;  0x06                 0x8f8
```

对于通用寄存器和内存，无论是在实模式或保护模式：
如果压入的是 16 位数据，栈指针减 2。
如果压入的是 32 位数据，栈指针减 4。
咱们先验证下实模式压入 16 位、32 位数据后栈指针的变化

```assembly
;                 下一条的指令的机器码    当前 esp 值
section loader vstart=0x900
mov sp, 0x900
push ax         ; 50                   0x900
;66反转操作数大小
push eax        ; 6650                 0x8fe
push word [0x1234]  ;ff363412          0x8fa
push dword [0x1234] ;66ff363412        0x8f8
jmp $           ; ebfe                 0x8f4
```

保护模式下同样是压入通用寄存器和内存的情况。

```assembly
 ;在保护模式每次压入16位数据时栈指针esp就减2，每次压入32位数据时栈指针esp就减4。
   push ax        ;  6650                 0x900
   push eax       ;  50                   0x8fe
   push word [0x1234];66ff3534120000      0x8fa
   push dword [0x1234];ff3534120000       0x8f8
```

## 全局描述符表

### 段描述符

![截图 2023-06-12 22-03-24](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-03-24.png)

段界限表示段边界的扩展最值，即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种。对于数据段和代码段，段的扩展方向是向上，即地址越来越高，此时的段界限用来表示段内偏移的最大值。对于栈段，段的扩展方向是向下，即地址越来越低，此时的段界限用来表示段内偏移的最小值。无论是向上
扩展，还是向下扩展，段界限的作用如同其名，表示段的边界、大小、范围。段界限用 20 个二进制位来表示。只不过此段界限只是个单位量，它的单位要么是字节，要么是 4KB，这是由描述符中的 G 位来指定的。最终段的边界是此段界限值*单位，故段的大小要么是 2 的 20 次方等于 1MB，要么是 2 的 32 次方
（4KB 等于 2 的 12 次方，12+20=32）等于 4GB。上面所说的 1MB 和 4GB 只是个范围，并不是具体的边界值。由于段界限只是个偏移量，是从 0 算起
的，所以实际的段界限边界值=（描述符中段界限+1） * （段界限的粒度大小：4KB 或者 1）-1。由于描述符中的段界限是从 0 起的，所以左边第 1
个括号中要加个 1，表示 4KB 或 1 的实际数量。由于地址是以 0 为起始的，所以公式的最后又减了 1。

如果 G 位为 0，表示段界限粒度大小为 1 字节，根据上面的公式，实际段界限=（描述符中段界限+1） * 1 -1=描述符中段界限，段界限实际大小就等于描述符中的段界限值。

如果 G 位为 1，表示段界限粒度大小为 4KB 字节，故实际段界限=（描述符中段界限+1） * 4k-1。举个例子，如果是平坦模型，段界限为 0xFFFFF，G 位为 1，套用上面公式，段界限边界值=0x100000*0x1000-1=0xFFFFFFFF。

段界限*单位便是段内偏移地址的最大值（向上扩展）或最小值（向下扩展）
，任何超过此值的偏移地址都被认为是非法访问，CPU 会将此错误捕获。

高 32 位的8～11 位是 type 字段，共 4 位，用来指定本描述符的类型。这里要提前说下段描述符的 S 字段了。是这样的，一个段描述符，在 CPU 眼里分为两大类，要么描述的是系统段，要么描述的是数据段，这是由段描述符中的 S 位决定的，用它指示是否是系统段。在 CPU 眼里，凡是硬件运行需要用到的东西都可称之为系统，凡是软件（操作系统也属于软件，CPU 眼中，它与用户程序无区别）需要的东西都称为数据，无论是代码，还是数据，甚至包括栈，它们都作为硬件的输入，都是给硬件的数据而已，所以代码段在段描述符中也属于数据段（非系统段）。S 为 0 时表示系统段，S 为 1 时表示数据段。type 字段是要和 S 字段配合在一起才能确定段描述符的确切类型，只有 S 字段的值确定后，type 字段的值才有具体意义。

什么是系统段？各种称为“门”的结构便是系统段，也就是硬件系统需要的结构，非软件使用的，如调用门、任务门。简而言之，门的意思就是入口，它通往一段程序。

type 字段，该字段共 4 位，用于表示内存段或门的子类型。

![截图 2023-06-12 22-26-28](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-26-28.png)

表中的 A 位表示 Accessed 位，这是由 CPU 来设置的，每当该段被 CPU 访问过后，CPU 就将此位置 1。所以，创建一个新段描述符时，应该将此位置 0。我们在调试时，根据此位便能判断该描述符是否可用啦。

C 表示一致性代码段，也称为依从代码段，Conforming。一致性代码段是指如果自己是转移的目标段，并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL 为主，而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为 1 时则表示该段是一致性代码段，C 为 0 时则表示该段为非一致性代码段。

R 表示可读，R 为 1 表示可读，R 为 0 表示不可读。这个属性一般用来限制代码段的访问。如果指令执行过程中，CPU 发现某些指令对 R 为 0 的段进行访问，如使用段超越前缀 CS 来访问代码段，CPU 将抛出异常。啰嗦一小下，内存中的数据对 CPU 来说是要处理的数据，仅仅是 CPU 的输入而已，CPU 的铁
骑可以踏遍任意角落。所以，不可读的代码段只是来限制代码指令的，并不是连 CPU 也不能看。

X 表示该段是否可执行，EXecutable。我们所说的指令和数据，在 CPU 眼中是没有任何区别的，都是010101 这样类似的二进制。所以要用 type 中的 X 位来标识出是否是可执行的代码。代码段是可执行的，即 X 为 1。而数据段是不可执行的，即 X 为 0。

E 是用来标识段的扩展方向，Extend。E 为 0 表示向上扩展，即地址越来越高，通常用于代码段和数据段。E 为 1 表示向下扩展，地址越来越低，通常用于栈段。

W 是指段是否可写，Writable。W 为 1 表示可写，通常用于数据段。W 为 0
表示不可写入，通常用于代码段。对于 W 为 0 的段有写入行为，同样会引发 CPU 抛出异常。

段描述符的第 12 位是 S 字段，前面在介绍 type 时已解释过啦，用来指出当前描述符是否是系统段。S 为 0 表示系统段，S 为 1 表示非系统段。

段描述符的第 13～14 位是 DPL 字段，Descriptor Privilege Level，即描述符特权级，这是保护模式提供的安全解决方案，将计算机世界按权力划分成不同等级，每一种等级称为一种特权级。

由于段描述符用来描述一个内存段或一段代码的情况（若描述符类型为“门”
），所以描述符中的 DPL是指所代表的内存段的特权级。

这两位能表示 4 种特权级，分别是 0、1、2、3 级特权，数字越小，特权级越大。特权级是保护模式下才有的东西，CPU 由实模式进入保护模式后，特权级自动为 0。因为保护模式下的代码已经是操作系统的一部分啦，所以操作系统应该处于最高的 0 特权级。用户程序通常处于 3 特权级，权限最小。某些指令
只能在 0 特权级下执行，从而保证了安全。

段描述符的第 15 位是 P 字段，Present，即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。P 字段是由 CPU 来检查的，如果为 0，CPU 将抛出异常，转到相应的异常处理程序，此异常处理程序是咱们来写的，在异常处理程序处理完成后要将 P 置 1。也就是说，对于 P 字段，CPU 只负责检查，咱们负责赋值。不过在通常情况下，段都是在内存中的。当初 CPU 的设计是当内存不足时，可以将段描述符中对应的内存段换出，也就是可以把不常用的段直接换出到硬盘，待使用时再加载进来。但现在即使内存不足时，也没有将整个段都换出去的，现在基本都是平坦模型，一般情况下，段都要 4GB 大小，换到硬盘不也是很占空间吗？而且这些平坦的段都是公用的，换出去就麻烦啦。所以这些是未开启分页时的解决方案，保护模式下有分页功能，可以按页（4KB）的单位来将内存换入换出。

段描述符的第 16～19 位是段界限的第 16～19 位。这样共 20 位的段界限就齐全啦。

段描述符的第 20 位为 AVL 字段，从名字上看它是 AVaiLable，可用的。不过这“可用的”是对用户来说的，也就是操作系统可以随意用此位。对硬件来说，它没有专门的用途，就当作是硬件给软件的馈赠吧。

段描述符的第 21 位为 L 字段，用来设置是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32位代码段。这目前属于保留位，在我们 32 位 CPU 下编程，将其置为 0 便可。

段描述符的第 22 位是 D/B 字段，用来指示有效地址（段内偏移地址）及操作数的大小。有没有觉得奇怪，实模式已经是 32 位的地址线和操作数了，难道操作数不是 32 位大小吗？其实这是为了兼容 286 的保护模式，286 的保护模式下的操作数是 16 位。既然是指定“操作数”的大小，也就是对“指令”来说的，与指令相关的内存段是代码段和栈段，所以此字段是 D 或 B。

对于代码段来说，此位是 D 位，若 D 为 0，表示指令中的有效地址和操作数是 16 位，指令有效地址用 IP 寄存器。若 D 为 1，表示指令中的有效地址及操作数是 32 位，指令有效地址用 EIP 寄存器。

对于栈段来说，此位是 B 位，用来指定操作数大小，此操作数涉及到栈指针寄存器的选择及栈的地址上限。若 B 为 0，使用的是 sp 寄存器，也就是栈的起始地址是 16 位寄存器的最大寻址范围，0xFFFF。若 B 为 1，使用的是 esp 寄存器，也就是栈的起始地址是 32 位寄存器的最大寻址范围，0xFFFFFFFF。

段描述符的第 23 位是 G 字段，Granularity，粒度，用来指定段界限的单位大小。所以此位是用来配合段界限的，它与段界限一起来决定段的大小。若 G 为 0，表示段界限的单位是 1 字节，这样段最大是 2的 20 次方*1 字节，即 1MB。若 G 为 1，表示段界限的单位是 4KB，这样段最大是 2 的 20 次方*4KB 字
节，即 4GB。

段描述符的第 24～31 位是段基址的第 24～31 位，这是段基址的最后 8 位。

### 全局描述符表 GDT、局部描述符表 LDT 及选择子

一个段描述符只用来定义（描述）一个内存段。代码段要占用一个段描述符、数据段和栈段等，多个内存段也要各自占用一个段描述符，描述符放在全局描述符表GDT（Global Descriptor Table）。GDTR，即GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器。

![截图 2023-06-12 22-38-38](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-38-38.png)

lgdt 指令用来初始化GDTR。lgdt 的指令格式是：lgdt 48位内存数据。

前 16 位是 GDT 以字节为单位的界限值，所以这 16 位相当于GDT 的字节大小减 1。后 32 位是 GDT 的起始地址。GDT 的大小是 16 位二进制，其表示的范围是 2的 16 次方等于 65536 字节。每个描述符大小是 8 字节，故，GDT 中最多可容纳的描述符数量是 65536/8=8192个，即 GDT 中可容纳 8192 个段或门。

段寄存器 CS、DS、ES、FS、GS、SS，在实模式下时，段中存储的是段基地址，即内存段的起始地址。而在保护模式下时，段寄存器中存入的是一个叫作选择子的东西—selector。选择子是 16 位，在其低 2 位即第 0～1 位，用来存储 RPL，即请求特权级，可以表示 0、1、2、3 四种特权级。在选择子的第 2 位是 TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是 LDT 中索引描述符。TI为 0 表示在 GDT 中索引描述符，TI 为 1 表示在 LDT 中索引描述符。选择子的高 13 位，即第 3～15 位是描述符的索引值，用此值在 GDT 中索引描述符。前面说过 GDT 相当于一个描述符数组，所以此选择子中的索引值就是 GDT 中的下标。

![截图 2023-06-12 22-47-22](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-47-22.png)

GDT 中的第 0 个段描述符是不可用的，原因是定义在 GDT 中的段描述符是要用选择子来访问的，如果使用的选择子忘记初始化，选择子的值便会是 0，这便会访问到第 0 个段描述符。为了避免出现这种因忘记初始化选择子而选择到第 0 个段描述符的情况，GDT 中的第 0 个段描述符不可用。也就是说，若选择到了 GDT 中的第 0 个描述符，处理器将发出异常。

LDT，Local Descriptor Table，它是 CPU厂商为在硬件一级原生支持多任务而创造的表，按照 CPU 的设想，一个任务对应一个 LDT。其实在现代操作系统中很少有用 LDT 的，我们系统中也未用 LDT。

CPU 厂商建议每个任务的私有内存段都应该放到自己的段描述符表中，该表就是 LDT，即每个任务都有自己的 LDT，随着任务切换，也要切换相应任务的 LDT。LDT 也位于内存中，其地址需要先被加载到某个寄存器后，CPU 才能使用 LDT，该寄存器是 LDTR，即 LDT Register。同样也有专门的指令用于加载 LDT，即 lldt。以后每切换任务时，都要用 lldt 指令重新加载任务的私有内存段。

回顾一下段描述符中的 type 字段，其中 LDT 为系统段，换句话说，LDT 虽然是个表，但其也是一片内存区域，所以也需要用个描述符在 GDT 中先注册。段描述符是需要用选择子去访问的。故，lldt 的指令格式为：lldt 16 位寄存器/16 位内存。无论是寄存器，还是内存，其内容一定是个选择子，该选择子用来在 GDT 中索引 LDT 的段描述符。

LDT 中的段描述符和 GDT 中的一样，与 GDT 不同的是 LDT 中的第 0 个段描述符是可用的，因为提交的选择子中的 TI 位，TI 位用于指定是 GDT，还是 LDT，TI 为 1 则表示在 LDT 中索引段描述符，即 TI为 1 必然是经过显式初始化的结果，完全排除了忘记初始化的可能。

在表 4-10 中列出的系统段，它们都有各自的描述符，或者说描述符结构相同，只是用 type 和 S 字段予以区分不同的描述符。任何描述符的大小都是 8 字节。但无论描述符的种类有多少，它们的高 32 位中的第 8～12 字节内容都是不变的，第 12 位必须是 S，第 8～11 位必须为 type，描述符中的其他位的内容不强制要求。这样“局部”格式统一，便于 CPU 识别段类型。虽然列出了众多系统段，但很多都不是在全局描述符表中的，如中断门、陷阱门、任务门等都是在中断描述符表中存在的，将来说到中断的时候咱们再展开这方面内容。

### 打开 A20 地址线

还记得实模式下的 wrap-around 吗？也就是地址回绕。咱们一起来复习一下。
实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以 16 后再加上段内偏移地址。实模式下寄存器都是 16 位的，如果段基址和段内偏移地址都为 16 位的最大值，即 0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，
即 0x10FFEF。由于实模式下的地址线是 20 位，最大寻址空间是 1MB，即 0x00000～0xFFFFF。超出 1MB 内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”策略继续可用，CPU 采取的做法是将超过 1MB 的部分自动回绕到 0 地址，继续从 0地址开始映射。相当于把地址对 1MB 求模。超过 1MB 多余出来的内存被称为高端内存区 HMA。

这种地址回绕是如何做到的呢？要分两种情况分别讨论啦。
对于只有 20 位地址线的 CPU，不需要任何额外操作便能自动实现地址回绕。
地址（Address）线从 0 开始编号，在 8086/8088 中，只有 20 位地址线，即 A0～A19。20 位地址线表示的内存是 2 的 20 次方，最大是 1MB，即 0x0～0xFFFFF。内存若超过 1MB，是需要第 21 条地址线支持的。所以说，若地址进位到 1MB 以上，如 0x100000，由于没有第 21 位地址线，相当于丢掉了进位 1，变成了 0x00000。这一“缺陷”甚至成了当时很多程序员利用的技巧。地址回绕如图 4-9 所示。

![截图 2023-06-12 22-54-49](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-54-49.png)

对于 80286 后续的 CPU，通过 A20GATE 来控制 A20 地址线。

CPU 发展到了 80286 后，虽然地址总线从原来的 20 位发展到了 24 位，从而能够访问的内存范围可达到 2 的 24 次方，等于 16MB。但任何时候，Intel 都会把兼容放在第一位。80286 是第一款具有保护模式的 CPU，它在实模式下时，其表现也应该和 8086/8088 一模一样。按照兼容的要求，这意味着 80286 以及后续 CPU 的实模式都应该与 8086/8088 完全一样，即仍然只使用 20 条地址线。但 80286 有 24 条地址线，即 A0～A23，也就是说 A20 地址线是开启的。如果访问 0x100000～0x10FFEF 之间的内存，系统将直接访问这块物理内存，并不会像 8086/8088 那样回绕到 0。

为了解决此问题，IBM 在键盘控制器上的一些输出线来控制第 21 根地址线（A20）的有效性，故被称为 A20Gate。

- 如果 A20Gate 被打开，当访问到 0x100000～0x10FFEF 之间的地址时，CPU 将真正访问这块物理内存。
- 如果 A20Gate 被禁止，当访问 0x100000～0x10FFEF 之间的地址时，CPU 将采用 8086/8088 的地址回绕。

上面描述了地址回绕的原理，但地址回绕是为了兼容 8086/8088 的实模式。如今我们是在保护模式下，我们需要突破第 20 条地址线（A20）去访问更大的内存空间。而这一切，只有关闭了地址回绕才能实现。而关闭地址回绕，就是上面所说的打开 A20Gate。

其实打开 A20Gate 的方式是极其简单的，将端口 0x92 的第 1 位置 1 就可以了，以下三个步骤就可以实现啦。

```assembly
in al，0x92
or al，0000_0010B
out 0x92，al
```

### 保护模式的开关，CR0 寄存器的 PE 位

在前面说寄存器的时候，有讲到过控制寄存器系列 CRx。控制寄存器是 CPU 的窗口，既可以用来展示 CPU的内部状态，也可用于控制 CPU 的运行机制。CR0
寄存器的第 0 位，即 PE 位，Protection Enable，此位用于启用保护模式，是保护模式的开关。

![截图 2023-06-12 22-58-35](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-58-35.png)

![截图 2023-06-12 22-59-20](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-59-20.png)

PE 为 0 表示在实模式下运行，PE 为 1 表示在保护模式下运行。所以，我们的任务是将此位置 1。示例代码如下。

```assembly
mov eax, cr0
or eax 0x00000001
mov cr0, eax
```

### 让我们进入保护模式

creg 是 bochs 中用来查看控制寄存器的命令。在 bochs 中，控制寄存器和状态寄存器
中的相应位若为 1，bochs 会将该名称以大写来表示。



































