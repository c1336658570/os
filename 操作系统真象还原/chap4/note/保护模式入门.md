保护模式入门

## 保护模式概述

### 为什么要有保护模式

幸福是比出来的，这一点不假。让我们看看 CPU 实模式的不幸，大家就清楚保护模式的幸福了。
（1）实模式下操作系统和用户程序属于同一特权级，这哥俩平起平坐，没有区别对待。
（2）用户程序所引用的地址都是指向真实的物理地址，也就是说逻辑地址等于物理地址，实实在在地指哪打哪。
（3）用户程序可以自由修改段基址，可以不亦乐乎地访问所有内存，没人拦得住。

（4）访问超过 64KB 的内存区域时要切换段基址，转来转去容易晕乎。
（5）一次只能运行一个程序，无法充分利用计算机资源。
（6）共 20 条地址线，最大可用内存为 1MB，这即使在 20 年前也不够用。

## 初见保护模式

![截图 2023-06-12 19-18-58](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 19-18-58.png)

下面列出三种段描述符缓冲寄存器结构（段描述符缓冲寄存器和段寄存器在一起）

![截图 2023-06-12 19-28-27](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 19-28-27.png)

80286 虽然有了保护模式，但其依然是 16 位的 CPU，其通用寄存器还是 16 位宽。但其与 8086 不同的是其地址线由 20 位变为了 24 位，即寻址空间变成了 2 的 24 次方，等于 16MB 大小。

### 保护模式之寻址扩展

实模式下对于内存寻址来说，其中的基址寻址、变址寻址、基址变址寻址，这三种形式中的基址寄存器只能是 bx、bp，变址寄存器只能是 si、di。其中 bx 默认的段寄存器是 ds，它经常用于访问数据段，bp默认的段寄存器是 ss，它经常用于访问栈。对于寻址中的偏移量，只能是 1 个字以内的立即数，即不能超过 16 位。

在保护模式下，同样是内存寻址中，基址寄存器不再只是 bx、bp，而是所有 32 位的通用寄存器，变址寄存器也是一样，不再只是 si、di，而是除 esp 之外的所有 32 位通用寄存器，偏移量由实模式的 16 位变成了 32 位。并且，还可以对变址寄存器乘以一个比例因子，注意比例因子，只能是 1、2、4、8，如图 4-4 所示。

### ![截图 2023-06-12 19-39-32](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 19-39-32.png)保护模式之运行模式反转

![截图 2023-06-12 19-41-31](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 19-41-31.png)

第 3 个字段用于指定寻址方式和操作数类型，在指令格式不变的情况下，为了兼容保护模式，一种方案是重新定义各寻址方式、寄存器的编码。由于保护模式中的寻址方式和操作数类型同实模式下完全不同，故相应的编码也不同。比如在实模式下，用二进制 010 表示 dx 寄存器，在保护模式下的010 就表示 edx 寄存器（根据编码确定指令、寻址方式、寄存器，这是译码器的工作）。操作 dx 寄存器和edx 寄存器，对于硬件来说是完全不同的，所以编译器必须明确操作对象是哪个。

在实模式下，指令和操作数都是 16 位的，但我们也说过啦，它可以使用 32 位的资源。同样在保护模式下，指令和操作数都是 32 位的，它也可以使用 16 位的资源。

兼容性带来了好处，也带来了坏处，好处是 CPU 很强大，可以同时支持 16 位指令和 32 位指令，运行新老程序畅通无阻。但坏处就是 CPU 也不知道您想生成 16 位，还是 32 位机器码，需要明确告诉编译器一些信息。为此，编译器提供了伪指令 bits，用它来向编译器传达：我下面的指令都要编译成 xx位的，因为我知道下面的代码的运行环境是 xx 模式。

bits 的指令格式是[bits 16]或[bits 32]。
[bits 16]是告诉编译器，下面的代码帮我编译成 16 位的机器码。
[bits 32]是告诉编译器，下面的代码帮我编译成 32 位的机器码。

bits 外面的中括号是可以省略的，另外，在未使用 bits 指令的地方，默认是[bits 16]。

进入保护模式需要三个步骤。
（1）打开 A20。
（2）加载 gdt。
（3）将 cr0 的 pe 位置 1。

在指令格式中，有个“前缀”字段，里面存放的是指令选项之类的东东，比如指令重复前缀 rep、段跨越前缀“段寄存器：”，还有咱们马上要介绍的操作数反转前缀 0x66 和寻址方式反转前缀 0x67。

在不同的模式下，操作数和寻址方式都各不相同。实模式下的操作数大小是 16 位，保护模式下的操作数大小是 32 位。

16 位实模式下可以用 32 位保护模式下的寄存器。但这种福利的得来却是稍费功夫的，如果要用另一模式下的操作数大小，需要在指令前添加指令前缀 0x66，将当前模式临时改变成另一模式。这就是反转的意义，不管是当前模式是什么，总是转变成相反的运行模式。

比如，在指令中添加了 0x66 反转前缀之后：
假设当前运行模式是 16 位实模式，操作数大小将变为 32 位。
假设当前运行模式是 32 位保护模式，操作数大小将变为 16 位。
注意啦，这个转换只是临时的，只在当前指令有效。

下面再介绍个前缀：寻址方式反转前缀 0x67。

不同模式之间不仅可以使用对方模式下的操作数，还可以使用对方模式下的寻址方式。

```assembly
[bits 16]
mov word [bx], 0x1234		;C7073412
mov word [eax], 0x1234		;67C7003412
;eax 寄存器作为基址寻址，并且用到了伪指令 dword，表示在 eax 所表示的内存处，连续写入 4 字节大小的数据。操作数大小也由默认的 2 字节变成了 4 字节，就会添加 0x66 的前缀。所以其机器码是 6667C70034120000，前面 2 字节是前缀 0x66、0x67。
mov dword [eax], 0x1234		;6667C70034120000
[bits32]
mov dword [eax], 0x1234		;C70034120000
;在本行代码中表示从 eax 指定的内存处连续写入 2 字节。这就改变了操作数的大小，当前已经是 32 位机器码了，默认操作数也是 32 位，所以要用操作数大小反转前缀 0x66，见机器码第 1 字节。
mov word [eax], 0x1234		;66C7003412
;实模式下的基址寻址，寄存器是 bx（只能是 bx 或 bp），但由于当前是 32 位保护模式，所以在机器码中要用寻址方式反转前缀 0x67。
mov dword [bx], 0x1234		;67C70734120000
```

bits 伪指令用于指定运行模式，操作数大小反转前缀 0x66 和寻址方式反转前缀 0x67，用于临时将当前运行模式下的操作数大小和寻址方式转变成另外一种模式下的操作数大小及寻址方式。

### 保护模式之指令扩展

add，sub等指令不仅要支持 8 位、16 位，还得支持 32 位的操作数。以上说的是双操作数的指令，还有一些单操作数指令，如 inc、dec 等，也是同时支持 8 位、16 位、32 位寄存器。对于 loop 指令，实模式下要用 cx 寄存器来
存储循环次数，在保护模式下，要用 ecx。

mul 指令是无符号数相乘指令，指令格式是 mul 寄存器/内存。
其中“寄存器/内存”是乘数。
如果乘数是 8 位，则把寄存器 al 当作另一个乘数，结果便是 16 位，存入寄存器 ax。
如果乘数是 16 位，则把寄存器 ax 当作另一个乘数，结果便是 32 位，存入寄存器 eax。
如果乘数是 32 位，则把寄存器 eax 当作另一个乘数，结果便是 64 位，存入 edx：eax，其中 edx 是积的高 32 位，eax 是积的低 32 位。

有符号数相乘指令 imul 也是一样。

对于无符号数除法指令 div，其格式是 div 寄存器/内存，其中的“寄存器/内存”是除法计算中的除数。
如果除数是 8 位，被除数就是 16 位，位于寄存器 ax。所得的结果，商在寄存器 al，余数在寄存器 ah。
如果除数是 16 位，被除数就是 32 位，被除数的高 16 位则位于寄存器 dx，被除数的低 16 位则位于
寄存器 ax。所得的结果，商在寄存器 ax，余数在寄存器 dx。
如果除数是 32 位，被除数就是 64 位，被除数的高 32 位则位于寄存器 edx，被除数的低 32 位则位于寄存器 eax，所得的结果，商在寄存器 eax，余数在寄存器 edx。

在 16 位的实模式下，CPU照样可以处理 32 位的数据，大家不要感到奇怪。最典型的例子就是 push，这是往栈中添加数据的指令。同样的指令，在实模式和保护模式下都可以同时处理 16 位和 32 位的数据，让咱们看看 push 是怎样应对这两种局面的。

对于 push 指令，需要根据其操作数的类型，分别讨论，操作数类型如下。
（1）立即数。
（2）寄存器。
（3）内存。
下面咱们看看各方面的内容。
先看第 1 种情况，对于立即数来说，可以分别压入 8 位、16 位、32 位数据。
指令格式是：
push 8 位立即数
push 16 位立即数
push 32 位立即数
虽说可以压入 8 位立即数，但实际上，对于 CPU 来说，出于对齐的考虑，操作数要么是 16 位，要么是 32 位，所以 8 位立即数会被扩展成各模式下的默认操作数宽度，即实模式下 8 位立即数扩展成为 16 位后再入栈，保护模式下扩展成为 32 位后再入栈。

在实模式环境下：
当压入 8 位立即数时，由于实模式下默认操作数是 16 位，CPU 会将其扩展为 16 位后再将其入栈，sp-2。当压入 16 位立即数时，CPU 会将其直接入栈，sp-2。当压入 32 位立即数时，CPU 会将其直接入栈，sp-4。

```assembly
;                   下一条指令机器码    当前esp值
section loader vstart=0x900
mov sp,0x900        ;bc0009           0x00007c00
push byte 0x7       ;6a07             0x00000900
push word 0x8       ;6a08             0x000008fe  0x900-0x8fe=2
;该指令66是操作数反转前缀，将当前的默认操作数反转成32位
push dword 0x90     ;666a09           0x000008fc  0x8fe-0x8fc=2
jmp $               ;ebfe             0x000008f8  0x8fc-0x8f8=4
```



在保护模式下，同样是这些压入立即数的指令，栈指针会有怎样的变化呢？
当压入 8 位立即数时，由于保护模式下默认操作数是 32 位，CPU 将其扩展为 32 位后入栈，esp 指针减 4。
当压入 16 位立即数时，CPU 直接压入 2 字节，esp 指针减 2。
当压入 32 位立即数时，CPU 直接压入 4 字节，esp 指针减 4。

```assembly
;                    下一条的指令的机器码    当前 esp 值
   push byte 0x7  ;  6a07                 0x00000900
   ;word 是伪指令，表示2字节大小的数据类型，66是反转操作数前缀,这是操作数大小反转前缀。
   ;编译器添加此反转前缀的原因是在32位下的操作数是4字节，此处要压入2字节，
   ;这是16位模式下的操作数尺寸。
   push word 0x8  ;  666a08               0x000008fc  0x900-0x8fc=4
   push dword 0x9 ;  6a09                 0x000008fa  0x8fc-0x8fa=2

   jmp $          ;  ebfe                 0x000008f6  0x8fa-0x8f6=4
```



对于段寄存器的入栈，即 cs、ds、es、fs、gs、ss，无论在哪种模式下，都是按当前模式的默认操作数大小压入的。例如，在 16 位模式下，CPU 直接压入 2 字节，栈指针 sp 减 2。在 32 位模式下，CPU 直接压入 4 字节，栈指针 esp 减 4。

```assembly
;实模式下压入段寄存器
;           下一条指令的机器码    当前esp值
section loader vstart=0x900
mov sp,0x900    ;以下sp均减2
push cs  ;  0x0e                0x900 
push ds  ;  0x1e                0x8fe
push es  ;  0x06                0x8fc
jmp $    ;  0xebfe              0x8fa
```

```assembly
section loader vstart=0x900
mov sp,0x900
push cs        ;  0x0e                 0x900
push ds        ;  0x1e  0x             0x8fc
push es        ;  0x06                 0x8f8
```

对于通用寄存器和内存，无论是在实模式或保护模式：
如果压入的是 16 位数据，栈指针减 2。
如果压入的是 32 位数据，栈指针减 4。
咱们先验证下实模式压入 16 位、32 位数据后栈指针的变化

```assembly
;                 下一条的指令的机器码    当前 esp 值
section loader vstart=0x900
mov sp, 0x900
push ax         ; 50                   0x900
;66反转操作数大小
push eax        ; 6650                 0x8fe
push word [0x1234]  ;ff363412          0x8fa
push dword [0x1234] ;66ff363412        0x8f8
jmp $           ; ebfe                 0x8f4
```

保护模式下同样是压入通用寄存器和内存的情况。

```assembly
 ;在保护模式每次压入16位数据时栈指针esp就减2，每次压入32位数据时栈指针esp就减4。
   push ax        ;  6650                 0x900
   push eax       ;  50                   0x8fe
   push word [0x1234];66ff3534120000      0x8fa
   push dword [0x1234];ff3534120000       0x8f8
```

## 全局描述符表

### 段描述符

![截图 2023-06-12 22-03-24](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-03-24.png)

段界限表示段边界的扩展最值，即最大扩展到多少或最小扩展到多少。扩展方向只有上下两种。对于数据段和代码段，段的扩展方向是向上，即地址越来越高，此时的段界限用来表示段内偏移的最大值。对于栈段，段的扩展方向是向下，即地址越来越低，此时的段界限用来表示段内偏移的最小值。无论是向上
扩展，还是向下扩展，段界限的作用如同其名，表示段的边界、大小、范围。段界限用 20 个二进制位来表示。只不过此段界限只是个单位量，它的单位要么是字节，要么是 4KB，这是由描述符中的 G 位来指定的。最终段的边界是此段界限值*单位，故段的大小要么是 2 的 20 次方等于 1MB，要么是 2 的 32 次方
（4KB 等于 2 的 12 次方，12+20=32）等于 4GB。上面所说的 1MB 和 4GB 只是个范围，并不是具体的边界值。由于段界限只是个偏移量，是从 0 算起
的，所以实际的段界限边界值=（描述符中段界限+1） * （段界限的粒度大小：4KB 或者 1）-1。由于描述符中的段界限是从 0 起的，所以左边第 1
个括号中要加个 1，表示 4KB 或 1 的实际数量。由于地址是以 0 为起始的，所以公式的最后又减了 1。

如果 G 位为 0，表示段界限粒度大小为 1 字节，根据上面的公式，实际段界限=（描述符中段界限+1） * 1 -1=描述符中段界限，段界限实际大小就等于描述符中的段界限值。

如果 G 位为 1，表示段界限粒度大小为 4KB 字节，故实际段界限=（描述符中段界限+1） * 4k-1。举个例子，如果是平坦模型，段界限为 0xFFFFF，G 位为 1，套用上面公式，段界限边界值=0x100000*0x1000-1=0xFFFFFFFF。

段界限*单位便是段内偏移地址的最大值（向上扩展）或最小值（向下扩展）
，任何超过此值的偏移地址都被认为是非法访问，CPU 会将此错误捕获。

高 32 位的8～11 位是 type 字段，共 4 位，用来指定本描述符的类型。这里要提前说下段描述符的 S 字段了。是这样的，一个段描述符，在 CPU 眼里分为两大类，要么描述的是系统段，要么描述的是数据段，这是由段描述符中的 S 位决定的，用它指示是否是系统段。在 CPU 眼里，凡是硬件运行需要用到的东西都可称之为系统，凡是软件（操作系统也属于软件，CPU 眼中，它与用户程序无区别）需要的东西都称为数据，无论是代码，还是数据，甚至包括栈，它们都作为硬件的输入，都是给硬件的数据而已，所以代码段在段描述符中也属于数据段（非系统段）。S 为 0 时表示系统段，S 为 1 时表示数据段。type 字段是要和 S 字段配合在一起才能确定段描述符的确切类型，只有 S 字段的值确定后，type 字段的值才有具体意义。

什么是系统段？各种称为“门”的结构便是系统段，也就是硬件系统需要的结构，非软件使用的，如调用门、任务门。简而言之，门的意思就是入口，它通往一段程序。

type 字段，该字段共 4 位，用于表示内存段或门的子类型。

![截图 2023-06-12 22-26-28](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-26-28.png)

表中的 A 位表示 Accessed 位，这是由 CPU 来设置的，每当该段被 CPU 访问过后，CPU 就将此位置 1。所以，创建一个新段描述符时，应该将此位置 0。我们在调试时，根据此位便能判断该描述符是否可用啦。

C 表示一致性代码段，也称为依从代码段，Conforming。一致性代码段是指如果自己是转移的目标段，并且自己是一致性代码段，自己的特权级一定要高于当前特权级，转移后的特权级不与自己的 DPL 为主，而是与转移前的低特权级一致，也就是听从、依从转移前的低特权级。C 为 1 时则表示该段是一致性代码段，C 为 0 时则表示该段为非一致性代码段。

R 表示可读，R 为 1 表示可读，R 为 0 表示不可读。这个属性一般用来限制代码段的访问。如果指令执行过程中，CPU 发现某些指令对 R 为 0 的段进行访问，如使用段超越前缀 CS 来访问代码段，CPU 将抛出异常。啰嗦一小下，内存中的数据对 CPU 来说是要处理的数据，仅仅是 CPU 的输入而已，CPU 的铁
骑可以踏遍任意角落。所以，不可读的代码段只是来限制代码指令的，并不是连 CPU 也不能看。

X 表示该段是否可执行，EXecutable。我们所说的指令和数据，在 CPU 眼中是没有任何区别的，都是010101 这样类似的二进制。所以要用 type 中的 X 位来标识出是否是可执行的代码。代码段是可执行的，即 X 为 1。而数据段是不可执行的，即 X 为 0。

E 是用来标识段的扩展方向，Extend。E 为 0 表示向上扩展，即地址越来越高，通常用于代码段和数据段。E 为 1 表示向下扩展，地址越来越低，通常用于栈段。

W 是指段是否可写，Writable。W 为 1 表示可写，通常用于数据段。W 为 0
表示不可写入，通常用于代码段。对于 W 为 0 的段有写入行为，同样会引发 CPU 抛出异常。

段描述符的第 12 位是 S 字段，前面在介绍 type 时已解释过啦，用来指出当前描述符是否是系统段。S 为 0 表示系统段，S 为 1 表示非系统段。

段描述符的第 13～14 位是 DPL 字段，Descriptor Privilege Level，即描述符特权级，这是保护模式提供的安全解决方案，将计算机世界按权力划分成不同等级，每一种等级称为一种特权级。

由于段描述符用来描述一个内存段或一段代码的情况（若描述符类型为“门”
），所以描述符中的 DPL是指所代表的内存段的特权级。

这两位能表示 4 种特权级，分别是 0、1、2、3 级特权，数字越小，特权级越大。特权级是保护模式下才有的东西，CPU 由实模式进入保护模式后，特权级自动为 0。因为保护模式下的代码已经是操作系统的一部分啦，所以操作系统应该处于最高的 0 特权级。用户程序通常处于 3 特权级，权限最小。某些指令
只能在 0 特权级下执行，从而保证了安全。

段描述符的第 15 位是 P 字段，Present，即段是否存在。如果段存在于内存中，P 为 1，否则 P 为 0。P 字段是由 CPU 来检查的，如果为 0，CPU 将抛出异常，转到相应的异常处理程序，此异常处理程序是咱们来写的，在异常处理程序处理完成后要将 P 置 1。也就是说，对于 P 字段，CPU 只负责检查，咱们负责赋值。不过在通常情况下，段都是在内存中的。当初 CPU 的设计是当内存不足时，可以将段描述符中对应的内存段换出，也就是可以把不常用的段直接换出到硬盘，待使用时再加载进来。但现在即使内存不足时，也没有将整个段都换出去的，现在基本都是平坦模型，一般情况下，段都要 4GB 大小，换到硬盘不也是很占空间吗？而且这些平坦的段都是公用的，换出去就麻烦啦。所以这些是未开启分页时的解决方案，保护模式下有分页功能，可以按页（4KB）的单位来将内存换入换出。

段描述符的第 16～19 位是段界限的第 16～19 位。这样共 20 位的段界限就齐全啦。

段描述符的第 20 位为 AVL 字段，从名字上看它是 AVaiLable，可用的。不过这“可用的”是对用户来说的，也就是操作系统可以随意用此位。对硬件来说，它没有专门的用途，就当作是硬件给软件的馈赠吧。

段描述符的第 21 位为 L 字段，用来设置是否是 64 位代码段。L 为 1 表示 64 位代码段，否则表示 32位代码段。这目前属于保留位，在我们 32 位 CPU 下编程，将其置为 0 便可。

段描述符的第 22 位是 D/B 字段，用来指示有效地址（段内偏移地址）及操作数的大小。有没有觉得奇怪，实模式已经是 32 位的地址线和操作数了，难道操作数不是 32 位大小吗？其实这是为了兼容 286 的保护模式，286 的保护模式下的操作数是 16 位。既然是指定“操作数”的大小，也就是对“指令”来说的，与指令相关的内存段是代码段和栈段，所以此字段是 D 或 B。

对于代码段来说，此位是 D 位，若 D 为 0，表示指令中的有效地址和操作数是 16 位，指令有效地址用 IP 寄存器。若 D 为 1，表示指令中的有效地址及操作数是 32 位，指令有效地址用 EIP 寄存器。

对于栈段来说，此位是 B 位，用来指定操作数大小，此操作数涉及到栈指针寄存器的选择及栈的地址上限。若 B 为 0，使用的是 sp 寄存器，也就是栈的起始地址是 16 位寄存器的最大寻址范围，0xFFFF。若 B 为 1，使用的是 esp 寄存器，也就是栈的起始地址是 32 位寄存器的最大寻址范围，0xFFFFFFFF。

段描述符的第 23 位是 G 字段，Granularity，粒度，用来指定段界限的单位大小。所以此位是用来配合段界限的，它与段界限一起来决定段的大小。若 G 为 0，表示段界限的单位是 1 字节，这样段最大是 2的 20 次方*1 字节，即 1MB。若 G 为 1，表示段界限的单位是 4KB，这样段最大是 2 的 20 次方*4KB 字
节，即 4GB。

段描述符的第 24～31 位是段基址的第 24～31 位，这是段基址的最后 8 位。

### 全局描述符表 GDT、局部描述符表 LDT 及选择子

一个段描述符只用来定义（描述）一个内存段。代码段要占用一个段描述符、数据段和栈段等，多个内存段也要各自占用一个段描述符，描述符放在全局描述符表GDT（Global Descriptor Table）。GDTR，即GDT Register，专门用来存储 GDT 的内存地址及大小。GDTR 是个 48 位的寄存器。

![截图 2023-06-12 22-38-38](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-38-38.png)

lgdt 指令用来初始化GDTR。lgdt 的指令格式是：lgdt 48位内存数据。

前 16 位是 GDT 以字节为单位的界限值，所以这 16 位相当于GDT 的字节大小减 1。后 32 位是 GDT 的起始地址。GDT 的大小是 16 位二进制，其表示的范围是 2的 16 次方等于 65536 字节。每个描述符大小是 8 字节，故，GDT 中最多可容纳的描述符数量是 65536/8=8192个，即 GDT 中可容纳 8192 个段或门。

段寄存器 CS、DS、ES、FS、GS、SS，在实模式下时，段中存储的是段基地址，即内存段的起始地址。而在保护模式下时，段寄存器中存入的是一个叫作选择子的东西—selector。选择子是 16 位，在其低 2 位即第 0～1 位，用来存储 RPL，即请求特权级，可以表示 0、1、2、3 四种特权级。在选择子的第 2 位是 TI 位，即 Table Indicator，用来指示选择子是在 GDT 中，还是 LDT 中索引描述符。TI为 0 表示在 GDT 中索引描述符，TI 为 1 表示在 LDT 中索引描述符。选择子的高 13 位，即第 3～15 位是描述符的索引值，用此值在 GDT 中索引描述符。前面说过 GDT 相当于一个描述符数组，所以此选择子中的索引值就是 GDT 中的下标。

![截图 2023-06-12 22-47-22](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-47-22.png)

GDT 中的第 0 个段描述符是不可用的，原因是定义在 GDT 中的段描述符是要用选择子来访问的，如果使用的选择子忘记初始化，选择子的值便会是 0，这便会访问到第 0 个段描述符。为了避免出现这种因忘记初始化选择子而选择到第 0 个段描述符的情况，GDT 中的第 0 个段描述符不可用。也就是说，若选择到了 GDT 中的第 0 个描述符，处理器将发出异常。

LDT，Local Descriptor Table，它是 CPU厂商为在硬件一级原生支持多任务而创造的表，按照 CPU 的设想，一个任务对应一个 LDT。其实在现代操作系统中很少有用 LDT 的，我们系统中也未用 LDT。

CPU 厂商建议每个任务的私有内存段都应该放到自己的段描述符表中，该表就是 LDT，即每个任务都有自己的 LDT，随着任务切换，也要切换相应任务的 LDT。LDT 也位于内存中，其地址需要先被加载到某个寄存器后，CPU 才能使用 LDT，该寄存器是 LDTR，即 LDT Register。同样也有专门的指令用于加载 LDT，即 lldt。以后每切换任务时，都要用 lldt 指令重新加载任务的私有内存段。

回顾一下段描述符中的 type 字段，其中 LDT 为系统段，换句话说，LDT 虽然是个表，但其也是一片内存区域，所以也需要用个描述符在 GDT 中先注册。段描述符是需要用选择子去访问的。故，lldt 的指令格式为：lldt 16 位寄存器/16 位内存。无论是寄存器，还是内存，其内容一定是个选择子，该选择子用来在 GDT 中索引 LDT 的段描述符。

LDT 中的段描述符和 GDT 中的一样，与 GDT 不同的是 LDT 中的第 0 个段描述符是可用的，因为提交的选择子中的 TI 位，TI 位用于指定是 GDT，还是 LDT，TI 为 1 则表示在 LDT 中索引段描述符，即 TI为 1 必然是经过显式初始化的结果，完全排除了忘记初始化的可能。

在表 4-10 中列出的系统段，它们都有各自的描述符，或者说描述符结构相同，只是用 type 和 S 字段予以区分不同的描述符。任何描述符的大小都是 8 字节。但无论描述符的种类有多少，它们的高 32 位中的第 8～12 字节内容都是不变的，第 12 位必须是 S，第 8～11 位必须为 type，描述符中的其他位的内容不强制要求。这样“局部”格式统一，便于 CPU 识别段类型。虽然列出了众多系统段，但很多都不是在全局描述符表中的，如中断门、陷阱门、任务门等都是在中断描述符表中存在的，将来说到中断的时候咱们再展开这方面内容。

### 打开 A20 地址线

还记得实模式下的 wrap-around 吗？也就是地址回绕。咱们一起来复习一下。
实模式下内存访问是采取“段基址：段内偏移地址”的形式，段基址要乘以 16 后再加上段内偏移地址。实模式下寄存器都是 16 位的，如果段基址和段内偏移地址都为 16 位的最大值，即 0xFFFF：0xFFFF，最大地址是 0xFFFF0+0xFFFF，
即 0x10FFEF。由于实模式下的地址线是 20 位，最大寻址空间是 1MB，即 0x00000～0xFFFFF。超出 1MB 内存的部分在逻辑上也是正常的，但物理内存中却没有与之对应的部分。为了让“段基址：段内偏移地址”策略继续可用，CPU 采取的做法是将超过 1MB 的部分自动回绕到 0 地址，继续从 0地址开始映射。相当于把地址对 1MB 求模。超过 1MB 多余出来的内存被称为高端内存区 HMA。

这种地址回绕是如何做到的呢？要分两种情况分别讨论啦。
对于只有 20 位地址线的 CPU，不需要任何额外操作便能自动实现地址回绕。
地址（Address）线从 0 开始编号，在 8086/8088 中，只有 20 位地址线，即 A0～A19。20 位地址线表示的内存是 2 的 20 次方，最大是 1MB，即 0x0～0xFFFFF。内存若超过 1MB，是需要第 21 条地址线支持的。所以说，若地址进位到 1MB 以上，如 0x100000，由于没有第 21 位地址线，相当于丢掉了进位 1，变成了 0x00000。这一“缺陷”甚至成了当时很多程序员利用的技巧。地址回绕如图 4-9 所示。

![截图 2023-06-12 22-54-49](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-54-49.png)

对于 80286 后续的 CPU，通过 A20GATE 来控制 A20 地址线。

CPU 发展到了 80286 后，虽然地址总线从原来的 20 位发展到了 24 位，从而能够访问的内存范围可达到 2 的 24 次方，等于 16MB。但任何时候，Intel 都会把兼容放在第一位。80286 是第一款具有保护模式的 CPU，它在实模式下时，其表现也应该和 8086/8088 一模一样。按照兼容的要求，这意味着 80286 以及后续 CPU 的实模式都应该与 8086/8088 完全一样，即仍然只使用 20 条地址线。但 80286 有 24 条地址线，即 A0～A23，也就是说 A20 地址线是开启的。如果访问 0x100000～0x10FFEF 之间的内存，系统将直接访问这块物理内存，并不会像 8086/8088 那样回绕到 0。

为了解决此问题，IBM 在键盘控制器上的一些输出线来控制第 21 根地址线（A20）的有效性，故被称为 A20Gate。

- 如果 A20Gate 被打开，当访问到 0x100000～0x10FFEF 之间的地址时，CPU 将真正访问这块物理内存。
- 如果 A20Gate 被禁止，当访问 0x100000～0x10FFEF 之间的地址时，CPU 将采用 8086/8088 的地址回绕。

上面描述了地址回绕的原理，但地址回绕是为了兼容 8086/8088 的实模式。如今我们是在保护模式下，我们需要突破第 20 条地址线（A20）去访问更大的内存空间。而这一切，只有关闭了地址回绕才能实现。而关闭地址回绕，就是上面所说的打开 A20Gate。

其实打开 A20Gate 的方式是极其简单的，将端口 0x92 的第 1 位置 1 就可以了，以下三个步骤就可以实现啦。

```assembly
in al，0x92
or al，0000_0010B
out 0x92，al
```

### 保护模式的开关，CR0 寄存器的 PE 位

在前面说寄存器的时候，有讲到过控制寄存器系列 CRx。控制寄存器是 CPU 的窗口，既可以用来展示 CPU的内部状态，也可用于控制 CPU 的运行机制。CR0
寄存器的第 0 位，即 PE 位，Protection Enable，此位用于启用保护模式，是保护模式的开关。

![截图 2023-06-12 22-58-35](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-58-35.png)

![截图 2023-06-12 22-59-20](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-12 22-59-20.png)

PE 为 0 表示在实模式下运行，PE 为 1 表示在保护模式下运行。所以，我们的任务是将此位置 1。示例代码如下。

```assembly
mov eax, cr0
or eax 0x00000001
mov cr0, eax
```

### 让我们进入保护模式

creg 是 bochs 中用来查看控制寄存器的命令。在 bochs 中，控制寄存器和状态寄存器
中的相应位若为 1，bochs 会将该名称以大写来表示。

## 处理器微架构简介

### 流水线

CPU 的指令执行过程分为取指令、译码、执行三个步骤。每个步骤都是独立执行的，CPU 可以一边执行指令，一边取指令，一边译码。CPU 中的时序不是秒，对 CPU 来说，秒就是天文数字。它的时序是时钟周期。按照这三个步骤，其三级流水线见表 4-14。

![截图 2023-06-14 17-17-57](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-14 17-17-57.png)

虽然在一个时钟周期内 CPU 同时干了三件事，但一定要清楚，这三件事不属于同一个指令，是三个指令重叠在一起了。

CPU 是按照程序中指令顺序来填充流水线的，也就是说按照程序计数器 PC（x86中是 cs：ip）中的值来装载流水线的，当前指令和下一条指令在空间上是挨着的。如果当前执行的指令是jmp，下一条指令已经被送上流水线译码了，第三条指令已经被送上流水线取指啦。仔细想想看，其实这个流水线没用了，因为 CPU 早已经跳到别处去执行了，第二、三条指令用不上了，所以 CPU 在遇到无条件转移指令 jmp 时，会清空流水线。

### 乱序执行

乱序执行，是指在 CPU 中运行的指令并不按照代码中的顺序执行，而是按照一定的策略打乱顺序执行，也许后面的指令先执行，当然，得保证指令之间不具备相关性。

如下两行代码就无法乱序执行。

```assembly
mov eax, [0x1234]
add eax, ebx
```

第 2 行的 add 加法，需要知道 eax 的值，但 eax 的值需要在第 1 行中的 mov 操作后才能确定，而且内存访问相对来说非常慢，第 2 步不得不等待第 1 步完成后才能进行。所以只能是先执行第 1 步，再执行第 2 步。如果将上面第 2 步的代码修改一下，如下：

```assembly
mov eax, [0x1234]
add ecx,ebx｡
```

执行第 1 步内存访问后的等待中执行第 2 步啦。由于第 2 步不依赖第 1 步，所以有利于放在流水线上。

x86 最初用的指令集是 CISC（Complex Instruction Set Computer）
，意为复杂指令集计算机。当初的 CPU 工程师们为了让 CPU 更加强大，不断地往 CPU 中添加各种指令，甚至在 CPU 硬件一级直接支持软件中的某些操作，以至于指令集越来越庞大笨重复杂。例如 push 指令，它相当于多个子操
作的合成，拿保护模式中的栈来说，push eax 相当于：

- push 指令先将栈指针 esp 减去操作数的字长，如 sub esp,4。
- 再将操作数 mov 到新的 esp 指向的地址，如 mov [esp],eax。

与 CISC 指令集相对应的是 RISC（Reduced Instruction Set Computer）
，意为精简指令集计算机。根据二八定律，最常用的指令只有 20%，但它们占了整个程序指令数的 80%。而不常用的指令占 80%，但它们只占整个程序指令数的 20%。这就是 RISC 指令集的由来，它精简保留了那些常用的指令，这些指令大多数都是不可再细分的，也就是，它们基本上都是属于微操作级别的指令啦。

x86 发展到后来，虽然还是 CISC 指令集，但其内部已经采用 RISC 内核，译码对于 x86 体系来说，除了按照指令格式分析机器码外，还要将 CISC 指令分解成多个 RISC 指令。当一个“大”操作被分解成多个“微”操作时，它们之间通常独立无关联，所以非常适合乱序执行。

```assembly
mov eax , [0x1234]
push eax
call function
```

第 1 步需要内存访问，由于内存较慢，所以寻址等待过程中可以做其他事。
第 2 步的 push 指令拆分成 sub esp ，4 和 mov [esp]， eax。
第 3 步的 call 函数调用，需要在栈中压入返回地址，所以说 call 指令需要用栈指针。
由于第 2 步中的微操作 sub esp，4，可以让 CPU 知道 esp 的最新值，不用等到 mov [esp], eax 完成，第 3 步 call 指令向栈中压入返回地址的操作就可以执行了。故第 2 步未执行完就开始第 3 步的执行了，也许第 3 步先于第 2 步完成。
总结一下，乱序执行的好处就是后面的操作可以放到前面来做，利于装载到流水线上提高效率。

### 缓存

其原理是用一些存取速度较快的存储设备作为数据缓冲区，避免频繁访问速度较慢的低速存储设备，归根结底的原因是低速存储设备是整个系统的瓶颈，缓存用来缓解“瓶颈设备”的压力。

CPU 为什么要用缓存？因为待执行的指令和相关数据存储在低速的内存中，让 CPU 这种高速设备等待慢速的内存，着实太浪费 CPU 资源了。SRAM是CPU的救世主，成为 CPU 和内存之间数据缓存的不二之选。

CPU 中有一级缓存 L1、二级缓存 L2，甚至三级缓存 L3 等。它们都是 SRAM，即静态随机访问存储器，它是最快的存储器啦。

寄存器和SRAM速度上是同一级别的东西，因为寄存器和 SRAM 都是用相同的存储电路实现的。

无论是程序中的数据，还是指令，在 CPU 眼里全是一样形式的二进制 01串，没有任何区别，都是 CPU 待处理的“数据”。所以我们眼中的指令和数据都可以被缓存到 SRAM 中。
什么时候能缓存呢？可以根据程序的局部性原理采取缓存策略。局部性原理是：程序 90%的时间都运行在程序中 10%的代码上。
局部性分为以下两个方面。
一方面是时间局部性：最近访问过的指令和数据，在将来一段时间内依然经常被访问。
另一方面是空间局部性：靠近当前访问内存空间的内存地址，在将来一段时间也会被访问。

### 分支预测

CPU 中的指令是在流水线上执行。分支预测，是指当处理器遇到一个分支指令时，是该把分支左边的指令放到流水线上，还是把分支右边的指令放在流水线上呢？

如 C 语言程序中的 if、switch、for 等语言结构。

如下面的测试代码。

```assembly
void main () {
	int i = 0;

	while (i < 10) {
		i++;
	}
}
```

```assembly
;使用的AT&T语法	上面哪个函数通过gcc -S汇编出来的代码
;前 4 行用于声明代码段
	.file"while.c"
	.text
 .globl main
	.type	main, @function
;第5行是main函数的起始地址
main:
;第 6～8 行是在创建堆栈框架，也就是为局部变量 i 在栈中分配空间，-4（%ebp）便是指局部变量 i。
	pushl %ebp
	movl %esp, %ebp
	subl $16, %esp
;第 9 行是为变量 i 赋值为 0。AT&T 语法中，寄存器前要用%来指示，立即数前要用$来指示。
	movl $0, -4(%ebp)
	jmp .L2
.L3:	;此处是 while 的循环体
	addl $1, -4(%ebp)
.L2:	;此处是 while 循环条件表达式
;第14行就是while括号中的条件表达式
	cmpl $9, -4(%ebp)
;第15行的jle意思是若第14行的比较结果是小于等于9，则跳到11行，继续执行第12行的加法。
	jle .L3
;leave用于堆栈框架的回收工作。
	leave
	ret
	.size	main, .-main
	.ident	"GCC: (GNU) 4.4.6 20120305 (Red Hat 4.4.6-4)"
	.section .note.GNU-stack,"",@progbits
```

jle 指令就是程序中的分支结构。类似这样的分支结构很多，它们只有两种结果，要么转移到这一边，要么转移到那一边。分支结构虽然让程序更加灵活多样，但这却成了 CPU 执行效率的诟病。

之前说流水线的时候，我和大家强调了两次“重叠”，即同一时间周期内完成的是当前指令的执行，下一条指令的译码，第三条指令的取指。其中最重要的是“执行”，指令只有执行了，才真正是泼出去的水，收不回来了。另外的译码和取指并不重要，首先它们并不是执行，其次它们也不属于当前指令，当前
指令的“取指”和“译码”早就在前两个周期内完成了。

拿表 4-14 的周期 3 来说，这一时钟周期内的“执行”指的是当前指令的执行阶
段，“取指”和“译码”这两个工序分别隶属于未来要执行的下一条指令和下下一条指令。想到这里不禁要有个疑问，这两个未来的指令，CPU 是如何确定的？如果程序一直是顺序执行的，未来无论多少条指令都可以轻易得到，都可以提前放到流水线上。可是，程序是有分支啊，到底该把哪个分支的指令放到流水线上呢？

流水线是有效提升 CPU 效率的方式，但流水线最大的问题是程序中的分支结构，如何把握好转移的方向，才是使流水线保持高效的关键，因为如果流水线上的指令放错了的话，必须要清空那些已经在流水线上的指令，一定不能执行错误的指令。随着流水线级数越多，要清空的指令也将越多，清空流水线的代
价就越大，这严重影响 CPU 效率。

当遇到一个分岔口时，是往左走，还是往右走呢？对于这种分支情况，就需要预测出哪一侧的指令将被执行，然后将预测出的那一分支上的指令放入流水线。从统计学的角度来看，某些事情一旦出现，下一次出现的机率还会很大。纵观历史，很多事情都是在重复地发生，很多伟人都拿这些历史样本来预测未来发生的事情。

对于无条件跳转，没啥可犹豫的，直接跳过去就是了。所谓的预测是针对有条件跳转来说的，因为不知道条件成不成立。最简单的统计是根据上一次跳转的结果来预测本次，如果上一次跳转啦，这一次也预测为跳转，否则不跳。

最简单的方法是 2 位预测法。用 2 位 bit 的计数器来记录跳转状态，每跳转一次就加 1，直到加到最大值 3 就不再加啦，如果未跳转就减 1，直到减到最小值 0 就不再减了。当遇到跳转指令时，如果计数器的值大于 1 则跳转，如果小于等于 1 则不跳。

Intel 的分支预测部件中用了分支目标缓冲器（Branch Target Buffer，BTB）。其结构如图 4-14 所示。

![截图 2023-06-14 18-44-49](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-14 18-44-49.png)

BTB 中记录着分支指令地址，CPU 遇到分支指令时，先用分支指令的地址在 BTB 中查找，若找到相同地址的指令，根据跳转统计信息判断是否把相应的预测分支地址上的指令送上流水线。在真正执行时，根据实际分支流向，更新 BTB 中跳转统计信息。

如果 BTB 中没有相同记录该怎么办呢？这时候可以使用 Static Predictor，静态预测器。为什么称为静态呢？这是因为存储在里面的预测策略是固定写死的，它是由人们经过大量统计之后，根据某些特征总结出来的。比如，转移目标的地址若小于当前转移指令的地址，则认为转移会发生，因为通常循环结构中都用这种转移策略，为的是组成循环回路。所以静态预测器的策略是：若向上跳转则转移会发生，若向下跳转则转移不发生，如图 4-15 所示。

![截图 2023-06-14 18-46-52](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-14 18-46-52.png)

程序在实际执行转移分支指令后，再将转移记录录入到 BTB。还记得之前反复强调的重叠吗？其实是用在这的。如果分支预测错了，也就是说，当前指令执行结果与预测的结果不同，这也没关系，只要将流水线清空就好了。因为处于执行阶段的是当前指令，即分支跳转指令。处于“译码”“取指”的是尚未执行的指令，即错误分支上的指令。只要错误分支上的指令还没到执行阶段就可以挽回，所以，直接清空流水线就是把流水线上错误分支上的指令清掉，再把正确分支上的指令加入到流水线，只是清空流水。

## 使用远跳转指令清空流水线，更新段描述符缓冲寄存器

段描述符缓冲寄存器在 CPU 的实模式和保护模式中都同时使用，在不重新引用一个段时，段描述符缓冲寄存器中的内容是不会更新的，无论是在实模式，还是保护模式下，CPU 都以段描述符缓冲寄存器中的内容为主。实模式进入保护模式时，由于段描述符缓冲寄存器中的内容仅仅是实模式下的 20 位的段基址，很多属性位都是错误的值，这对保护模式来说必然会造成错误，所以需要马上更新段描述符缓冲寄存器，也就是要想办法往相应段寄存器中加载选择子。

其次，流水线中指令译码错误。
在默认情况下，如果未使用 bits 伪指令来设置运行环境，编译器就将代码按照 16 位实模式编译。代码 4-3，即 loader.S 中唯一的 bits 指令是在 81 行，所以 80 行之前的代码运行在实模式之下，它们是 16 位指令格式。第 81 行的[bits 32]是让编译器将此行后面的指令编译成为 32 位。因为此处已经是在保护模式下了，我们知道保护模式下的指令是 32 位，所以要编译成符合保护模式的指令格式。

我们已经知道，CPU 为了提高效率而采用了流水线，这样，指令间是重叠执行的。第 76 行之前的指令都是 16 位指令，自 76 行之后，CPU 便进入了保护模式，故第 78 行的指令已经是在保护模式下了，但它依然还是 16 位的指令，相当于处于 16 位保护模式下。为了让其使用 32 位偏移地址，所以添加了伪指令 dword，故其机器码前会加 0x66 反转前缀。而第 81 行后的代码是在[bits 32]之后，所以全是 32 位指令。

流水线的工作是这样的：在第 76 行代码执行的同时，第 78 行和之后的部分指令已经被送上流水线了，但是，段描述符缓冲寄存器在实模式下时已经在使用了，其低 20 位是段基址，但其他位默认为 0，也就是描述符中的 D 位为 0，这表示当前的操作数大小是 16 位。流水线上的指令全是按照 16 位操作数来译码的，这就坏了，人家 83 行开始的指令明明是 32 位指令，16 位和 32 位的指令都有各自不同的意义，这怎么能不出错呢？所以，如果将第 78 行的跳转指令去掉，程序将在第 83 行开始出错，原因就是 83 行的代码是 32 位指令格式，而 CPU 是将其按照 16 位指令格式来译码的，译码之后在其执行时，必然是错误的。

综上所述，解决问题的关键就是既要改变代码段描述符缓冲寄存器的值，又要清空流水线。
代码段寄存器 cs，只有用远过程调用指令 call、远转移指令 jmp、远返回指令 retf 等指令间接改变，没有直接改变 cs 的方法，如直接 mov cs，xx 是不行的。另外，之前介绍过了流水线原理，CPU 遇到 jmp指令时，之前已经送上流水线上的指令只有清空，所以 jmp 指令有清空流水线的神奇功效。

故，用无条件远跳转指令 jmp 来解决上述两个问题将是一举两得的做法。
补充一下，代码 4-3 的第 78 行 jmp dword SELECTOR_CODE p_mode_start，由于已经身处保护模式，所以 CPU 将此指令中的 SELECTOR_CODE 认为是选择子。因为当前段描述符缓冲寄存器中的 D 位是 0，所以操作数是 16 位，当前属于 16 位保护模式。故，在这里也可以把 dword 去掉，毕竟当前操作数大小就是 16 位。而且 p_mode_start 的地址并没有超过 16 位，用 dword 表示的 32 位地址并没有发挥其功效。这两者的区别见表 4-16。

![截图 2023-06-14 18-56-04](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-14 18-56-04.png)

第一行的机器码为 66ea4b0b00000800。加了伪指令 dword 后，编译器引用 32 位地址，所以加了 0x66是指反转操作数大小前缀。
第二行的机器码为 ea480b0800，这是引用的 16 位地址。
至于操作数中的偏移地址，一个是 0xb4b，一个是 0xb48，它们之间差了 3，是由不同指令本身所占空间不同导致的。

## 保护模式之内存段的保护

### 向段寄存器加载选择子时的保护

当引用一个内存段时，实际上就是往段寄存器中加载个选择子，为了避免出现非法引用内存段的情况，在这时候，处理器会在以下几方面做出检查。
首先根据选择子的值验证段描述符是否超越界限。

选择子的高 13 位是段描述符的索引值，第 0～1 位是 RPL，第 2 位是 TI 位。首先处理器得保证选择子是正确的，判断的标准是选择子的索引值一定要小于等于描述符表（GDT 或 LDT）中描述符的个数。也就是说，段描述符的最后 1 字节一定要在描述符表（GDT 或 LDT）的界限地址之内。每个段描述符的大小是 8 字节，所以在往段寄存器中加载选择子时，处理器要求选择子中的索引值要满足下面表达式：描述符表基地址+选择子中的索引值*8+7 <=描述符表基地址+描述符表界限值。

检查过程如下：处理器先检查 TI 的值，如果TI 是 0，则从全局描述符表寄存器 gdtr 中拿到 GDT基地址和 GDT 界限值。如果 TI 是 1，则从局部描述符表寄存器 ldtr 中拿到 LDT 基地址和 LDT 界限值。有了描述符表基地址和描述符表界限值后，把选择子的高 13 位代入上面的表达式，若不成立，处理器则抛出异常。过程如图 4-16 所示。

![截图 2023-06-14 19-20-48](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-14 19-20-48.png)

GDT 中的第 0 个描述符是空描述符，如果选择子的索引值为 0 则会引用到它。所以，不允许往 CS 和 SS 段寄存器中加载索引值为 0 的选择子。虽然可以往 DS、ES、FS、GS 寄存器中加载值为 0 的选择子，但真正在使用时 CPU 将会抛出异常，毕竟第 0 个段描述符是哑的，不可用。

段描述符中还有个 type 字段，这用来表示段的类型，也就是不同的段有不同的作用。在选择子检查过后，就要检查段的类型了。

这里主要是检查段寄存器的用途和段类型是否匹配。大的原则如下。

- 只有具备可执行属性的段（代码段）才能加载到 CS 段寄存器中。
- 只具备执行属性的段（代码段）不允许加载到除 CS 外的段寄存器中。
- 只有具备可写属性的段（数据段）才能加载到 SS 栈段寄存器中。
- 至少具备可读属性的段才能加载到 DS、ES、FS、GS 段寄存器中。

如果 CPU 发现有任意上述规则不符，检查就不会通过。以上所述可见表 4-17。

![截图 2023-06-14 19-23-09](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-14 19-23-09.png)

检查完 type 后，还会再检查段是否存在。CPU 通过段描述符中的 P 位来确认内存段是否存在，如果P 位为 1，则表示存在，这时候就可以将选择子载入段寄存器了，同时段描述符缓冲寄存器也会更新为选择子对应的段描述符的内容，随后处理器将段描述符中的 A 位置为 1，表示已经访问过了。如果 P 位为 0，则表示该内存段不存在,这时候处理器会抛出异常，自动转去执行相应的异常处理程序，异常处理程序将段从硬盘加载到内存后并将 P 位置为 1，随后返回。CPU 继续执行刚才的操作，判断 P 位。

注意啦，以上所涉及到的 P 位，其值由软件（通常是操作系统）来设置，由 CPU 来检查。A 位由 CPU来设置。

### 代码段和数据段的保护

对于代码段和数据段来说，CPU 每访问一个地址，都要确认该地址不能超过其所在内存段的范围。
前面说过啦，实际段界限的值为：
（描述符中段界限+1）*（段界限的粒度大小：4k 或者 1）-1。
对于 G 位为 1 的 4k 粒度大小的段来说，其实用下面这个公式更为直接。
实际段界限大小 = 描述符中段界限*0x1000+0xFFF
其中，0xFFF 是 4k（0x1000）中以 0 为起始的最后一字节。所以此公式的意义是以 0 为起始的段偏移量，即段界限。推导过程也很简单，就是将原公式展开：
（描述符中段界限+1）*4k-1=描述符中段界限*4k+4k-1 =描述符中段界限*0x1000+0xFFF。
实际的段界限大小，是段内最后一个可访问的有效地址。由于有了段界限的限制，我们给 CPU 提交的每一个内存地址，无论是指令的地址，还是数据的地址，CPU 都要帮我们检查地址的有效性。首先地址指向的数据是有宽度的，CPU 要保证该数据一定要落在段内，不能“骑”在段边界上。下面我们分情况讨论。

对于代码段来说，段中的“数据”是各种机器指令。在 IA32 体系结构中，访问内存就要用分段策略。代码段既然也是内存中的区域，所以对于代码段的访问也要用“段基址：段内偏移地址”的形式，在 32 位保护模式下，段基址存放在 CS 寄存器中，段内偏移地址，即有效地址，存放在 EIP 寄存器中。

CS：EIP 只是指令的起始地址，指令本身也是有长度的，之前我们见过各种各样的机器码，它们的长度有 2 字节的、3 字节的等，如 jmp .-2，其机器码为 ebfe，大小就是 2 字节。CPU 得确保指令“完全、完整”地任意一部分都在当前的代码段内，也就是要满足以下条件：
EIP 中的偏移地址+指令长度-1≤实际段界限大小
如果不满足条件，如图 4-17 所示，指令未完整地落在本段内，CPU 则会抛出异常。

![截图 2023-06-14 19-33-32](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-14 19-33-32.png)

这种边界检查对于数据段也是一样，数据也是有长度的（不同类型数据的长度不一致，这就是数据类型的作用），CPU 也要保证操作数要“完全、完整”地任意部分都要在当前数据段内。所以，数据地址也要遵循此原则：
偏移地址+数据长度-1≤实际段界限大小

同图 4-17 类似，数据段的段界限也是段内可访问的最后一个地址，所以不允许出现数据“骑”在段边界的情况。

举个例子，假设数据段描述符的段界限是 0x12345，段基址为0x00000000。
如果 G 位为 0，那么实际段界限便是 0x12345。如果 G 位为 1，那么实际段界限便是 0x12345*0x1000+0xFFF=0x12345FFF。如果访问的数据地址是 0x12345FFF，还要看访问的数据宽度。

若数据大小是 1 字节，如 mov ax，byte [0x12345fff]，这种内存操作一点问题都没有，数据完全在实际段界限之内。

若该数据大小是 2 字节，如 mov ax，word [0x12345fff]，这种内存操作超过了实际的段界限，数据所在地址分别是 0x12345FFF 和 0x12346000 这两个字节，CPU 会抛异常。

### 栈段的保护

虽然段描述符 type 中的 e 位用来表示段的扩展方向，但它和别的描述符属性一样，仅仅是用来描述段的性质，即使 e 等于 1 向下扩展，依然可以引用不断向上递增的内存地址，即使 e 等于 0 向上扩展，也依然可以引用不断向下递减的内存地址。栈顶指针esp 的值逐渐降低，这是 push 指令的作用，与描述符是否向下扩展无关，也就是说，是数据段就可以用作栈。

CPU 对数据段的检查，其中一项就是看地址是否超越段界限。如果将向上扩展的数据段用作栈，那
CPU 将按照上一节提到的数据段的方式检查该段。如果用向下扩展的段做栈的话，情况有点复杂，这体现在段界限的意义上。

- 对于向上扩展的段，实际的段界限是段内可以访问的最后一字节。
- 对于向下扩展的段，实际的段界限是段内不可以访问的第一个字节。

由于栈段是向下扩展的，也许有同学觉得段界限似乎用负数更为“贴切”。但段界限本质上就是段的大小范围，范围可没有负数之说，所以段界限肯定是个正数。如果您觉得栈的段界限应该是负数的话，可能的原因是您把位于高地址处的栈底当成了基准，心想：“在基准之上为正，在基准之下当然为负了”，其
实不然，栈的段界限是以栈段的基址为基准的，并不是以栈底，因此栈的段界限肯定是位于栈顶之下。地址本身由低向高发展，段界限也是个地址，而栈的扩展方向是由高地址向低地址，与段界限有个碰撞的趋势。为了避免碰撞，将段界限地址+1 视为栈可以访问的下限。段界限+1，才是栈指针可达的下边界，如图 4-18 所示。

![截图 2023-06-14 19-44-45](/home/cccmmf/操作系统/操作系统真象还原/chap4/note/截图 2023-06-14 19-44-45.png)

32 位保护模式下栈的栈顶指针是 esp 寄存器，栈的操作数大小是由 B 位决定的，我们这里假设 B 为1，即操作数是 32 位。栈段也是位于内存中，所以它也要受控于段描述符中的 G 位。

- 如果 G 为 0，实际的段界限大小=描述符中的段界限。
- 如果 G 为 1，实际的段界限大小=描述符中段界限*0x1000+0xFFF。

同代码段的操作数一样，用于压栈的操作数也有其长度，push 指令每向栈中压入操作数时，实际上就是将 esp 指针减去操作数的大小（2 字节或 4 字节）后，再将操作数复制到 esp 减 4 后的新地址。栈指针可访问的最低地址是由实际段界限决定的，但栈段最大可访问的地址是由 B 位决定的，我们这里 B 位为 1，表示 32 位操作数，所以栈指针最大可访问地址是 0xFFFFFFFF。综上所述，每次向栈中压入数据时就是CPU 检查栈段的时机，它要求必须满足以下条件。

实际段界限+1≤esp-操作数大小≤ 0xFFFFFFFF

假设现在 esp 指针为 0xFFFFE002，段描述符的 G 位为 1，描述符中的段界限为 0xFFFFD。故实际段
界限为 0x1000*FFFFD+0xFFF=0xFFFFDFFF。当执行 push ax，压入 2 字节的操作数，即 esp-2=0xFFFFE000，新的 esp 值≥实际段界限 0xFFFFDFFF +1。如果执行 push eax，压入 4 字节的数据，esp-4=0xFFFFDFFE，小于实际段界限 0xFFFFDFFF，故 CPU 会抛出异常。

由于 esp 只是栈段内的偏移地址，其真正物理地址还要加上段基址。假设段基址为 0，故该栈段：

最大可访问地址为 0+0xFFFFFFFF=0xFFFFFFFF。

最小可访问地址为 0+0xFFFFDFFF+1=0xFFFFE000。

栈段空间大小为 0xFFFFFFFF-0xFFFFE000=8KB。
