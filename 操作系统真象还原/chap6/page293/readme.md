在最后，我们说下扩展内联汇编中的clobber/modify 部分，这部分用于通知 gcc，我们修改了哪些寄存器或内存。
由于我们在 C 程序中嵌入了汇编代码，这必然会造成一些资源的破坏，本来嘛，人家 C 代码翻译后也要用到寄存器，突然来了一堆抢寄存器用的汇编指令，这肯定会使 gcc 重新为 C 代码安排寄存器等资源。为了解决资源冲突，我们得让 gcc 知道，我们改变了哪些寄存器或内存，这样 gcc 才能合理安排。
如果在 output 和 input 中通过寄存器约束指定了寄存器，gcc 必然会知道这些寄存器会被修改，所以，需要在 clobber/modify 中通知的寄存器肯定不是在 output 和 input 中出现过的。
也许您会认为，牵扯到修改寄存器或内存的部分，只差 assembly code 没说了，这部分还需要咱们明确告诉编译器吗？编译器不会自己扫描汇编指令？用到了哪些寄存器它还不知道吗？是的，gcc 还真不是很有把握知道哪些资源会被修改。在“明处”的指令确实可以检测到所修改的资源，比如 incl %%eax，eax 寄存器被+1 了，这种明显的改变 gcc 当然能扫描出来。可“暗处”的指令就无法保证了，比如在汇编中调用了一个函数，该函数内部会修改一些资源，或者该函数中又调用了其他函数，这保不准在哪一层调用有修改资源的代码，简直无法跟踪。所以必须要人为显式地告诉 gcc 我们动了哪些资源，这个资源就是寄存器和内存。怎样通知 gcc 我们修改了哪些寄存器？

只要在 clobber/modify 部分明确写出来就行了，记得要用双引号把寄存器名称引起来，多个寄存器之间用逗号'，'分隔，这里的寄存器不用再加两个'%'啦，只写名称即可，如：
asm("movl %%eax, %0;movl %%eax,%%ebx":"=m" (ret_value)::"bx")
虽然修改的是寄存器 ebx，但只要在 clobber/modify 声明 bx 就可以了，甚至可以声明 al。原因是即使寄存器只变动一部分，它的整体也会全跟着受影响，所以在 clobber/modify 中声明寄存器时，可以用低 8 位名称、低 16 位名称或全 32 位名称，如”al”/”ax”/”eax”都是指 eax 寄存器，其他通用寄存器也是一样的，不再举例。
如果我们的内联汇编代码修改了标志寄存器 eflags 中的标志位，同样需要在 clobber/modify 中用”cc”声明。
如果我们修改了内存，我们需要在 clobber/modify 中”memory”声明。
如果我们在 output 中使用了内存约束，gcc 自然会得到哪块内存被修改。但如果被修改的内容并未在output 中，我们就需要用”memory”告诉 gcc 啦。
举个例子，还记得之前咱们所说的复制大块数据的三剑客指令吗？字符串指令 movsd 配合 cld 和 rep，通过指针 esi 和 edi 的不断变化使源数据被复制到新目的地，后来数据被复制到了哪里，修改了哪些内存，gcc 可就不知道了，咱得主动用”memory”坦白才行。
另外一个用”memory”声明的原因就是清除寄存器缓存。
内存相对寄存器来说还是比较慢的，gcc 为了提速，编译中有时会把内存中的数据缓存到寄存器，之后的处理都是直接读取寄存器。编译过程中编译器无法检测到内存的变化，只有编译出来的程序在实际运行中才会出现变量的值被改变，也就是出现了内存变化的情况。您想，如果程序在编译阶段就能检测程序行为的话，那还运行程序干吗，直接在该程序的编译阶段输出程序运行结果不就完了吗^_^。于是问题来
了，编译器编译程序时，将变量的值缓存到寄存器。程序在运行时，当变量所在的内存有变化时，寄存器中的缓存还是旧数据，运行结果肯定就错了。于是，gcc 也为我们提供了选项，用来设置是否将变量缓存到寄存器中，这个选项就是 C 语言中的关键字 volatile，它表示该变量是不稳定的，容易被改变，这样 gcc就不会将其缓存到寄存器。注意啦，这个关键字并不是内联汇编 asm 后面的可选项[volatile]，虽然名字是一样的，但汇编中的 volatile 是定义的宏 #define__volatile__volatile，在编译前的预处理阶段，汇编中的volatile 最终会变成__volatile__，这和 C 语言中的 volatile 不冲突。用 C 语言中的 volatile 定义的变量，编译器就不会将该变量的值缓存到寄存器中，每次访问该变量时都会老老实实地从内存中获取。也就是说，只要编译器知道变量所在的内存有变化，它就会放弃寄存器缓存，到内存中取数据。
利用这个原理，不管变量的值是否会被编译器缓存到寄存器中，当我们需要绕过寄存器缓存，也就是希望读取到内存中最新的数据时，我们就可以在内联汇编中的 clobber/modify 部分用”memory”声明，通知编译器变量所在的内存数据变啦，这样它就会从内存再读取一次新数据啦。当然我们也可以在 C 代码中用 volatile 去修饰所定义的变量，但变量多了就有些麻烦了，所以还是用”memory”来声明更加方便。