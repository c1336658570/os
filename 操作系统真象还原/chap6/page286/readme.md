如果汇编代码想把 C 代码中的变量作为操作数加载到寄存器，如何找到可用的寄存器，这可是个大问题，程序员并不知道哪个寄存器已经被分配了，哪些寄存器是空闲的。即使知道了寄存器的分配情况也还不够，有些底层操作，对寄存器的要求是固定的（比如 in/out 指令，就得使用 al 作为数据寄存器），万一那个固定的寄存器已经被占用了，咱们在使用前还得把它备份。所以有了以下指令格式。
格式：asm [volatile] (“assembly code”:output : input : clobber/modify)
其中的每一部分都可以省略，甚至包括 assembly code。省略的部分要保留冒号分隔符来占位，如果省略的是后面的一个或多个连续的部分，分隔符也不用保留，比如省略了 clobber/modify，不需要保留 input 后面的冒号。
assembly code：还是用户写入的汇编指令，和基本内联汇编一样。
output:output 用来指定汇编代码的数据如何输出给 C 代码使用。内嵌的汇编指令运行结束后，如果想将运行结果存储到 c 变量中，就用此项指定输出的位置。output 中每个操作数的格式为：
“操作数修饰符约束名”（C 变量名）
其中的引号和圆括号不能少，操作数修饰符通常为等号'='。多个操作数之间用逗号'，'分隔。
input：input 用来指定 C 中数据如何输入给汇编使用。要想让汇编使用 C 中的变量作为参数，就要在此指定。input 中每个操作数的格式为：
“[操作数修饰符] 约束名”（C 变量名）
其中的引号和圆括号不能少，操作数修饰符为可选项。多个操作数之间用逗号'，'分隔。
以上的 output()和 input()括号中的是 C 代码中的变量，output（c 变量）和 input（c 变量）就像 C 语言中的函数，将 C 变量（值或变量地址）转换成汇编代码的操作数。
clobber/modify：汇编代码执行后会破坏一些内存或寄存器资源，通过此项通知编译器，可能造成寄存器或内存数据的破坏，这样 gcc 就知道哪些寄存器或内存需要提前保护起来。
assembly code 中引用的所有操作数其实是经过 gcc 转换后的复本，“原件”都是在 output 和 input 括号中的 c 变量。

扩展内联汇编中“约束”，它所起的作用就是把 C 代码中的操作数（变量、立即数）映射为汇编中所使用的操作数，实际就是描述 C 中的操作数如何变成汇编操作数。约束分为四大类。
寄存器约束
寄存器约束就是要求 gcc 使用哪个寄存器，将 input 或 output 中变量约束在某个寄存器中。常见的寄存器约束有：
a：表示寄存器 eax/ax/al
b：表示寄存器 ebx/bx/bl
c：表示寄存器 ecx/cx/cl
d：表示寄存器 edx/dx/dl
D：表示寄存器 edi/di
S：表示寄存器 esi/si
q：表示任意这 4 个通用寄存器之一：eax/ebx/ecx/edx
r：表示任意这 6 个通用寄存器之一：eax/ebx/ecx/edx/esi/edi
g：表示可以存放到任意地点（寄存器和内存）。相当于除了同 q 一样外，还可以让 gcc 安排在内存中
A：把 eax 和 edx 组合成 64 位整数
f：表示浮点寄存器
t：表示第 1 个浮点寄存器
u：表示第 2 个浮点寄存器

在基本内联汇编中的寄存器用单个%做前缀，在扩展内联汇编中，单个%有了新的用途，用来表示占位符（一会儿细讲），所以在扩展内联汇编中的寄存器前面用两个%做前缀。
看代码
内存约束
下一个文件...