# mem.S别删，里面有注释
内存约束
内存约束是要求 gcc 直接将位于 input 和 output 中的 C 变量的内存地址作为内联汇编代码的操作数，不需要寄存器做中转，直接进行内存读写，也就是汇编代码的操作数是 C 变量的指针。
m：表示操作数可以使用任意一种内存形式。
o：操作数为内存变量，但访问它是通过偏移量的形式访问，即包含 offset_address 的格式。
内存约束也不是乱用的，至少在 assembly code 中的指令得允许操作数是内存，比如asm("movl %0, %1;"::"m"(in_a),"m"(in_b))就会出问题。movl 指令不允许“内存”到“内存”的复制，编译阶段就会报错。
立即数约束
立即数即常数，此约束要求 gcc 在传值的时候不通过内存和寄存器，直接作为立即数传给汇编代码。由于立即数不是变量，只能作为右值，所以只能放在 input 中。
i：表示操作数为整数立即数
F：表示操作数为浮点数立即数
I：表示操作数为 0～31 之间的立即数
J：表示操作数为 0～63 之间的立即数
N：表示操作数为 0～255 之间的立即数
O：表示操作数为 0～32 之间的立即数
X：表示操作数为任何类型立即数
案例在后文
通用约束
0～9：此约束只用在 input 部分，但表示可与 output 和 input 中第 n 个操作数用相同的寄存器或内存。
案例在后文