强调与总结：
无论是哪种占位符，它都是指代 C 变量经过约束后、由 gcc 分配的对应于汇编代码中的操作数，和 C 变量本身无关。这个操作数就是通过约束名所指定的寄存器、内存、立即数等，最终编译器要将占位符转换成这三种操作数类型之一。
在约束中还有操作数类型修饰符，用来修饰所约束的操作数：内存、寄存器，分别在 ouput 和 input中有以下几种。
在 output 中有以下 3 种。
=：表示操作数是只写，相当于为 output 括号中的 C 变量赋值，如=a(c_var)，此修饰符相当于 c_var=eax。
+：表示操作数是可读写的，告诉 gcc 所约束的寄存器或内存先被读入，再被写入。
&：表示此 output 中的操作数要独占所约束（分配）的寄存器，只供 output 使用，任何 input 中所分配的寄存器不能与此相同。注意，当表达式中有多个修饰符时，&要与约束名挨着，不能分隔。
在 input 中：
%：该操作数可以和下一个输入操作数互换。
一般情况下，input 中的 C 变量是只读的，output 中的 C 变量是只写的。
修饰符'='只用在 output 中，表示 C 变量是只写的，功能相当于 output 中的 C 变量=约束的汇编操作数，如”=a”(c_var)，相当于 c_var=eax 的值。
修饰符'+'也只用在 output 中，但它具备读、写的属性，也就是它既可作为输入，同时也可以作为输出，所以省去了在 input 中声明约束。通过实例演示，见文件reg6.c。



另一个'+'常用的场合是在“rep+字符串操作指令+cld 或std”指令组合中，原因是在字符串操作指令中，esi 作为源变址，保存数据所在的源地址，在字符串操作指令执行前，esi 要作为数据源地址，所以当作参数被读入，成了输入对象，在字符串操作指令执行后，esi 也要被更新为下一个数据源的地址，此时 esi 又被写入，成了输出对象，所以 esi 是先被读入后被写入，非常适合用'+'来修饰。edi 作为目的变址，保存数据写入的目的地址。在字符串操作指令执行前，edi 要作为数据写入的目的地址，所以当作参数被读入，成了输入对象，在字符串操作指令执行后，edi 也要被更新为下一个数据所写入的目的地址，此时 edi 又被写入，成了输出对象，所以 edi 也是先被读入，后被写入，非常适合用'+'来修饰。
常见的字符串操作指令有 movs[bwd]、ins[bwd]和 outs[bwd]、lods[bwd]和 stos[bwd]。只有 movs[bwd]才同时使用 esi 和 edi，它是把 esi 所指向的地址处的数据复制到 edi 所指向的内存地址处。ns[bwd]是从端口读入数据到内存的目的地址，故只涉及到 edi。outs[bwd]是把内存中的源数据写入端口，故只涉及到 esi。lods[bwd]是把内存中的源数据加载到寄存器 al、ax 或 eax，故只涉及到 esi。stos[bwd]是将寄存器 al、ax 或 eax 中的值写入内存中的目的地址，故只涉及到 edi。以上字符串指令每执行一次，所涉及到的源变址寄存器 esi 或目的变址寄存器 edi 都要根据操作数大小有所增减，至于是增加，还是减少，要取决于标志寄存器中的方向位 DF，若 DF 为 0，esi 和 edi 都自增，地址值越来越大，否则 DF 为 1，esi 和 edi 都自减，地址值越来越小。这些字符串操作指令在读写数据时，esi 和 edi 作为它们的输入操作数，执行完成后，根据 DF 位的情况自增或自减，这时又作为输出。
修饰符'&'用来表示此寄存器只能分配给 output 中的某个 C 变量使用，不能再分给 input 中某变量了。函数在执行完成时，返回值会存储在寄存器 eax 中。通常我们会将返回值获取到 C 变量中再处理。如果是让 gcc自由分配寄存器，gcc 有可能把 eax 分配出去另做他用，有可能的一种情况是先调用函数，函数返回后又执行了其他操作，这个操作中用到了 gcc 分配的 eax 寄存器，于是函数的返回值便被破坏，见文件 reg7.c。
别删reg7.S，有注释
reg7.S的38和40行为ret_cnt和test分配空间，49行是内联汇编，call printf后，把立即数 6 movl 到了寄存器 eax，这破坏了 printf 的返回值。
这时候修饰符'&'就派上用场了，只要为 test 约束的寄存器不要和 ret_cnt 相同就行，可以在 reg7.c 的第 9 行加个'&'，修改后的文件为 reg8.c。