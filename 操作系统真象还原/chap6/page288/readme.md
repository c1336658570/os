由于我们是在 C 语言中插入汇编代码，所以约束的作用是让 C 代码的操作数变成汇编代码能使用的操作数，所有的约束形式其实都是给汇编用的。故，约束是 C 语言中的操作数（变量或立即数）与汇编代码中的操作数之间的映射，它告诉 gcc，同一个操作数在两种环境下如何变换身份，如何对接沟通。编译过程中 C 代码是要先变成汇编代码的，内联汇编中的约束就相当于 gcc 让咱们指定 C 中数据的编译形式。在内联汇编中 assembly code 中用到的操作数，都是位于 output 和 input 中 C 操作数的副本，多数通过赋值的方式传给汇编代码，或者顶多是通过指针的形式，当操作数的副本在汇编中处理完成后，又重新赋值给 C 操作数。也可以这么说，C 操作数通过约束后，在汇编中的操作数是约束所指定的那个操作数载体，即内存或寄存器，如果是寄存器约束，汇编中操作的并不是 C 变量本身，而是 C 变量通过值传递到汇编的副本。举个例子，比如：
int in_a = 1, in_b = 2;
asm("movl %%eax, %%ebx"::"a"(in_a),"b"(in_b));
声明了两个 C 变量 in_a 和 in_b，在汇编代码中，表面上看是把变量 in_a 复制到了变量 in_b 中。但我们知道 movl 指令不能是从内存到内存的复制，所以，您一定知道或者早已经知道了，movl 的操作数是 C变量 in_a 和 in_b 通过约束指定的操作数载体：寄存器 eax 和 ebx。