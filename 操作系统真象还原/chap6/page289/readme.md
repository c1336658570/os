假设，我们用 a 指定寄存器为 eax，我们在汇编代码中可以用 eax 作为操作数。但有时我们对寄存器的要求并不严格，使用哪个都可以，所以我们可以用 r 来告诉 gcc 替我们自由安排。于是问题来了，由于r 表示可以用 6 个寄存器之一，我们并不知道 gcc 为操作数分配了哪个寄存器。或者，我们对操作数用了内存约束，操作数没有名称可以引用，这时候我们在汇编代码中该如何引用操作数呢？
为方便对操作数的引用，扩展内联汇编提供了占位符，它的作用是代表约束指定的操作数（寄存器、内存、立即数），我们更多的是在内联汇编中使用占位符来引用操作数。
占位符分为序号占位符和名称占位符两种。
序号占位符
序号占位符是对在 output 和 input 中的操作数，按照它们从左到右出现的次序从 0 开始编号，一直到9，也就是说最多支持 10 个序号占位符。
操作数用在 assembly code 中，引用它的格式是%0～9。
在操作数自身的序号前面加 1 个百分号'%'便是对相应操作数的引用。一定要切记，占位符指代约束所对应的操作数，也就是在汇编中的操作数，并不是圆括号中的 C 变量。
asm("addl %%ebx, %%eax":"=a"(out_sum):"a"(in_a),"b"(in_b));
等价于
asm("addl %2, %1":"=a"(out_sum):"a"(in_a),"b"(in_b));
其中：
"=a"(out_sum)序号为 0，%0 对应的是 eax。
"a"(in_a)序号为 1，%1 对应的是 eax。
"b"(in_b)序号为 2，%2 对应的是 ebx。
由于扩展内联汇编中的占位符要有前缀%，为了区别占位符和寄存器，只好在寄存器前用两个%做前缀啦。
占位符所表示的操作数默认情况下为 32 位数据。指令的操作数大小并不一致，有的指令操作数大小是 32 位，有的是 16 位，有的是 8 位。当为这些指令提供操作数时，编译器会自动取 32 位数据的低 16 位给需要 16 位操作数的指令，取 32 位的低 8 位给需要 8 位操作数的指令。由于 32 位数据中，高 16 位没法直接使用，所以对于 16 位操作数只能取 32 位中的低 16 位。但对于 8 位操作数就不一样了，尽管默认情况下会用低 8 位（0～7 位）作为字节指令的操作数，但 32 位数据中能直接使用的字节不只是低 8 位，还有第 8～15 位，所以，对于字节指令，gcc 为我们提供了改变默认操作数的机会，我们可以自由选择是用0～7 位，还是 8～15 位。这么说有点抽象，拿 32 位的寄存器 eax 举例，其常用的部分是 eax、ax、al（高16 位没法直接用）。有些指令的操作数是字，所以用 ax 做操作数即可。有些指令操作数是字节，用 al 或ah 都可以，默认情况下会将 al 当作操作数。这时候我们可以在%和序号之间插入字符'h'来表示操作数为ah（第 8～15 位），或者插入字符'b'来表示操作数为 al（第 0～7 位）。
看代码
由于序号占位符只支持 10 个操作数，虽然大多数情况下都够用了，但 gcc 还是提供了一种不受个数限制的占位符—名称占位符。下一节...